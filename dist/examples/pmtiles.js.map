{"version":3,"file":"pmtiles.js","mappings":"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","sources":["webpack://ol-mapbox-style/./node_modules/pmtiles/dist/index.js","webpack://ol-mapbox-style/./node_modules/pmtiles-protocol/index.js","webpack://ol-mapbox-style/./examples/pmtiles.js"],"sourcesContent":["var __pow = Math.pow;\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// node_modules/fflate/esm/browser.js\nvar u8 = Uint8Array;\nvar u16 = Uint16Array;\nvar i32 = Int32Array;\nvar fleb = new u8([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]);\nvar fdeb = new u8([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]);\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar freb = function(eb, start) {\n  var b = new u16(31);\n  for (var i = 0; i < 31; ++i) {\n    b[i] = start += 1 << eb[i - 1];\n  }\n  var r = new i32(b[30]);\n  for (var i = 1; i < 30; ++i) {\n    for (var j = b[i]; j < b[i + 1]; ++j) {\n      r[j] = j - b[i] << 5 | i;\n    }\n  }\n  return { b, r };\n};\nvar _a = freb(fleb, 2);\nvar fl = _a.b;\nvar revfl = _a.r;\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0);\nvar fd = _b.b;\nvar revfd = _b.r;\nvar rev = new u16(32768);\nfor (i = 0; i < 32768; ++i) {\n  x = (i & 43690) >> 1 | (i & 21845) << 1;\n  x = (x & 52428) >> 2 | (x & 13107) << 2;\n  x = (x & 61680) >> 4 | (x & 3855) << 4;\n  rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n}\nvar x;\nvar i;\nvar hMap = function(cd, mb, r) {\n  var s = cd.length;\n  var i = 0;\n  var l = new u16(mb);\n  for (; i < s; ++i) {\n    if (cd[i])\n      ++l[cd[i] - 1];\n  }\n  var le = new u16(mb);\n  for (i = 1; i < mb; ++i) {\n    le[i] = le[i - 1] + l[i - 1] << 1;\n  }\n  var co;\n  if (r) {\n    co = new u16(1 << mb);\n    var rvb = 15 - mb;\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        var sv = i << 4 | cd[i];\n        var r_1 = mb - cd[i];\n        var v = le[cd[i] - 1]++ << r_1;\n        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n          co[rev[v] >> rvb] = sv;\n        }\n      }\n    }\n  } else {\n    co = new u16(s);\n    for (i = 0; i < s; ++i) {\n      if (cd[i]) {\n        co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];\n      }\n    }\n  }\n  return co;\n};\nvar flt = new u8(288);\nfor (i = 0; i < 144; ++i)\n  flt[i] = 8;\nvar i;\nfor (i = 144; i < 256; ++i)\n  flt[i] = 9;\nvar i;\nfor (i = 256; i < 280; ++i)\n  flt[i] = 7;\nvar i;\nfor (i = 280; i < 288; ++i)\n  flt[i] = 8;\nvar i;\nvar fdt = new u8(32);\nfor (i = 0; i < 32; ++i)\n  fdt[i] = 5;\nvar i;\nvar flrm = /* @__PURE__ */ hMap(flt, 9, 1);\nvar fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\nvar max = function(a) {\n  var m = a[0];\n  for (var i = 1; i < a.length; ++i) {\n    if (a[i] > m)\n      m = a[i];\n  }\n  return m;\n};\nvar bits = function(d, p, m) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n};\nvar bits16 = function(d, p) {\n  var o = p / 8 | 0;\n  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n};\nvar shft = function(p) {\n  return (p + 7) / 8 | 0;\n};\nvar slc = function(v, s, e) {\n  if (s == null || s < 0)\n    s = 0;\n  if (e == null || e > v.length)\n    e = v.length;\n  var n = new u8(e - s);\n  n.set(v.subarray(s, e));\n  return n;\n};\nvar ec = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n];\nvar err = function(ind, msg, nt) {\n  var e = new Error(msg || ec[ind]);\n  e.code = ind;\n  if (Error.captureStackTrace)\n    Error.captureStackTrace(e, err);\n  if (!nt)\n    throw e;\n  return e;\n};\nvar inflt = function(dat, st, buf, dict) {\n  var sl = dat.length, dl = dict ? dict.length : 0;\n  if (!sl || st.f && !st.l)\n    return buf || new u8(0);\n  var noBuf = !buf || st.i != 2;\n  var noSt = st.i;\n  if (!buf)\n    buf = new u8(sl * 3);\n  var cbuf = function(l2) {\n    var bl = buf.length;\n    if (l2 > bl) {\n      var nbuf = new u8(Math.max(bl * 2, l2));\n      nbuf.set(buf);\n      buf = nbuf;\n    }\n  };\n  var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n  var tbts = sl * 8;\n  do {\n    if (!lm) {\n      final = bits(dat, pos, 1);\n      var type = bits(dat, pos + 1, 3);\n      pos += 3;\n      if (!type) {\n        var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n        if (t > sl) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + l);\n        buf.set(dat.subarray(s, t), bt);\n        st.b = bt += l, st.p = pos = t * 8, st.f = final;\n        continue;\n      } else if (type == 1)\n        lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n      else if (type == 2) {\n        var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n        var tl = hLit + bits(dat, pos + 5, 31) + 1;\n        pos += 14;\n        var ldt = new u8(tl);\n        var clt = new u8(19);\n        for (var i = 0; i < hcLen; ++i) {\n          clt[clim[i]] = bits(dat, pos + i * 3, 7);\n        }\n        pos += hcLen * 3;\n        var clb = max(clt), clbmsk = (1 << clb) - 1;\n        var clm = hMap(clt, clb, 1);\n        for (var i = 0; i < tl; ) {\n          var r = clm[bits(dat, pos, clbmsk)];\n          pos += r & 15;\n          var s = r >> 4;\n          if (s < 16) {\n            ldt[i++] = s;\n          } else {\n            var c = 0, n = 0;\n            if (s == 16)\n              n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n            else if (s == 17)\n              n = 3 + bits(dat, pos, 7), pos += 3;\n            else if (s == 18)\n              n = 11 + bits(dat, pos, 127), pos += 7;\n            while (n--)\n              ldt[i++] = c;\n          }\n        }\n        var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n        lbt = max(lt);\n        dbt = max(dt);\n        lm = hMap(lt, lbt, 1);\n        dm = hMap(dt, dbt, 1);\n      } else\n        err(1);\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n    }\n    if (noBuf)\n      cbuf(bt + 131072);\n    var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n    var lpos = pos;\n    for (; ; lpos = pos) {\n      var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n      pos += c & 15;\n      if (pos > tbts) {\n        if (noSt)\n          err(0);\n        break;\n      }\n      if (!c)\n        err(2);\n      if (sym < 256)\n        buf[bt++] = sym;\n      else if (sym == 256) {\n        lpos = pos, lm = null;\n        break;\n      } else {\n        var add = sym - 254;\n        if (sym > 264) {\n          var i = sym - 257, b = fleb[i];\n          add = bits(dat, pos, (1 << b) - 1) + fl[i];\n          pos += b;\n        }\n        var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n        if (!d)\n          err(3);\n        pos += d & 15;\n        var dt = fd[dsym];\n        if (dsym > 3) {\n          var b = fdeb[dsym];\n          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n        }\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (noBuf)\n          cbuf(bt + 131072);\n        var end = bt + add;\n        if (bt < dt) {\n          var shift2 = dl - dt, dend = Math.min(dt, end);\n          if (shift2 + bt < 0)\n            err(3);\n          for (; bt < dend; ++bt)\n            buf[bt] = dict[shift2 + bt];\n        }\n        for (; bt < end; bt += 4) {\n          buf[bt] = buf[bt - dt];\n          buf[bt + 1] = buf[bt + 1 - dt];\n          buf[bt + 2] = buf[bt + 2 - dt];\n          buf[bt + 3] = buf[bt + 3 - dt];\n        }\n        bt = end;\n      }\n    }\n    st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n    if (lm)\n      final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n  } while (!final);\n  return bt == buf.length ? buf : slc(buf, 0, bt);\n};\nvar et = /* @__PURE__ */ new u8(0);\nvar gzs = function(d) {\n  if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n    err(6, \"invalid gzip data\");\n  var flg = d[3];\n  var st = 10;\n  if (flg & 4)\n    st += (d[10] | d[11] << 8) + 2;\n  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n    ;\n  return st + (flg & 2);\n};\nvar gzl = function(d) {\n  var l = d.length;\n  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;\n};\nvar zls = function(d, dict) {\n  if ((d[0] & 15) != 8 || d[0] >> 4 > 7 || (d[0] << 8 | d[1]) % 31)\n    err(6, \"invalid zlib data\");\n  if ((d[1] >> 5 & 1) == +!dict)\n    err(6, \"invalid zlib data: \" + (d[1] & 32 ? \"need\" : \"unexpected\") + \" dictionary\");\n  return (d[1] >> 3 & 4) + 2;\n};\nfunction inflateSync(data, opts) {\n  return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction gunzipSync(data, opts) {\n  var st = gzs(data);\n  if (st + 8 > data.length)\n    err(6, \"invalid gzip data\");\n  return inflt(data.subarray(st, -8), { i: 2 }, opts && opts.out || new u8(gzl(data)), opts && opts.dictionary);\n}\nfunction unzlibSync(data, opts) {\n  return inflt(data.subarray(zls(data, opts && opts.dictionary), -4), { i: 2 }, opts && opts.out, opts && opts.dictionary);\n}\nfunction decompressSync(data, opts) {\n  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, opts) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, opts) : unzlibSync(data, opts);\n}\nvar td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\nvar tds = 0;\ntry {\n  td.decode(et, { stream: true });\n  tds = 1;\n} catch (e) {\n}\n\n// v2.ts\nvar shift = (n, shift2) => {\n  return n * __pow(2, shift2);\n};\nvar unshift = (n, shift2) => {\n  return Math.floor(n / __pow(2, shift2));\n};\nvar getUint24 = (view, pos) => {\n  return shift(view.getUint16(pos + 1, true), 8) + view.getUint8(pos);\n};\nvar getUint48 = (view, pos) => {\n  return shift(view.getUint32(pos + 2, true), 16) + view.getUint16(pos, true);\n};\nvar compare = (tz, tx, ty, view, i) => {\n  if (tz !== view.getUint8(i))\n    return tz - view.getUint8(i);\n  const x = getUint24(view, i + 1);\n  if (tx !== x)\n    return tx - x;\n  const y = getUint24(view, i + 4);\n  if (ty !== y)\n    return ty - y;\n  return 0;\n};\nvar queryLeafdir = (view, z, x, y) => {\n  const offsetLen = queryView(view, z | 128, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: true\n    };\n  }\n  return null;\n};\nvar queryTile = (view, z, x, y) => {\n  const offsetLen = queryView(view, z, x, y);\n  if (offsetLen) {\n    return {\n      z,\n      x,\n      y,\n      offset: offsetLen[0],\n      length: offsetLen[1],\n      isDir: false\n    };\n  }\n  return null;\n};\nvar queryView = (view, z, x, y) => {\n  let m = 0;\n  let n = view.byteLength / 17 - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = compare(z, x, y, view, k * 17);\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return [getUint48(view, k * 17 + 7), view.getUint32(k * 17 + 13, true)];\n    }\n  }\n  return null;\n};\nvar entrySort = (a, b) => {\n  if (a.isDir && !b.isDir) {\n    return 1;\n  }\n  if (!a.isDir && b.isDir) {\n    return -1;\n  }\n  if (a.z !== b.z) {\n    return a.z - b.z;\n  }\n  if (a.x !== b.x) {\n    return a.x - b.x;\n  }\n  return a.y - b.y;\n};\nvar parseEntry = (dataview, i) => {\n  const zRaw = dataview.getUint8(i * 17);\n  const z = zRaw & 127;\n  return {\n    z,\n    x: getUint24(dataview, i * 17 + 1),\n    y: getUint24(dataview, i * 17 + 4),\n    offset: getUint48(dataview, i * 17 + 7),\n    length: dataview.getUint32(i * 17 + 13, true),\n    isDir: zRaw >> 7 === 1\n  };\n};\nvar sortDir = (a) => {\n  const entries = [];\n  const view = new DataView(a);\n  for (let i = 0; i < view.byteLength / 17; i++) {\n    entries.push(parseEntry(view, i));\n  }\n  return createDirectory(entries);\n};\nvar createDirectory = (entries) => {\n  entries.sort(entrySort);\n  const buffer = new ArrayBuffer(17 * entries.length);\n  const arr = new Uint8Array(buffer);\n  for (let i = 0; i < entries.length; i++) {\n    const entry = entries[i];\n    let z = entry.z;\n    if (entry.isDir)\n      z = z | 128;\n    arr[i * 17] = z;\n    arr[i * 17 + 1] = entry.x & 255;\n    arr[i * 17 + 2] = entry.x >> 8 & 255;\n    arr[i * 17 + 3] = entry.x >> 16 & 255;\n    arr[i * 17 + 4] = entry.y & 255;\n    arr[i * 17 + 5] = entry.y >> 8 & 255;\n    arr[i * 17 + 6] = entry.y >> 16 & 255;\n    arr[i * 17 + 7] = entry.offset & 255;\n    arr[i * 17 + 8] = unshift(entry.offset, 8) & 255;\n    arr[i * 17 + 9] = unshift(entry.offset, 16) & 255;\n    arr[i * 17 + 10] = unshift(entry.offset, 24) & 255;\n    arr[i * 17 + 11] = unshift(entry.offset, 32) & 255;\n    arr[i * 17 + 12] = unshift(entry.offset, 48) & 255;\n    arr[i * 17 + 13] = entry.length & 255;\n    arr[i * 17 + 14] = entry.length >> 8 & 255;\n    arr[i * 17 + 15] = entry.length >> 16 & 255;\n    arr[i * 17 + 16] = entry.length >> 24 & 255;\n  }\n  return buffer;\n};\nvar deriveLeaf = (view, tile) => {\n  if (view.byteLength < 17)\n    return null;\n  const numEntries = view.byteLength / 17;\n  const entry = parseEntry(view, numEntries - 1);\n  if (entry.isDir) {\n    const leafLevel = entry.z;\n    const levelDiff = tile.z - leafLevel;\n    const leafX = Math.trunc(tile.x / (1 << levelDiff));\n    const leafY = Math.trunc(tile.y / (1 << levelDiff));\n    return { z: leafLevel, x: leafX, y: leafY };\n  }\n  return null;\n};\nfunction getHeader(source) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 512e3);\n    const dataview = new DataView(resp.data);\n    const jsonSize = dataview.getUint32(4, true);\n    const rootEntries = dataview.getUint16(8, true);\n    const dec = new TextDecoder(\"utf-8\");\n    const jsonMetadata = JSON.parse(\n      dec.decode(new DataView(resp.data, 10, jsonSize))\n    );\n    let tileCompression = 0 /* Unknown */;\n    if (jsonMetadata.compression === \"gzip\") {\n      tileCompression = 2 /* Gzip */;\n    }\n    let minzoom = 0;\n    if (\"minzoom\" in jsonMetadata) {\n      minzoom = +jsonMetadata.minzoom;\n    }\n    let maxzoom = 0;\n    if (\"maxzoom\" in jsonMetadata) {\n      maxzoom = +jsonMetadata.maxzoom;\n    }\n    let centerLon = 0;\n    let centerLat = 0;\n    let centerZoom = 0;\n    let minLon = -180;\n    let minLat = -85;\n    let maxLon = 180;\n    let maxLat = 85;\n    if (jsonMetadata.bounds) {\n      const split = jsonMetadata.bounds.split(\",\");\n      minLon = +split[0];\n      minLat = +split[1];\n      maxLon = +split[2];\n      maxLat = +split[3];\n    }\n    if (jsonMetadata.center) {\n      const split = jsonMetadata.center.split(\",\");\n      centerLon = +split[0];\n      centerLat = +split[1];\n      centerZoom = +split[2];\n    }\n    const header = {\n      specVersion: dataview.getUint16(2, true),\n      rootDirectoryOffset: 10 + jsonSize,\n      rootDirectoryLength: rootEntries * 17,\n      jsonMetadataOffset: 10,\n      jsonMetadataLength: jsonSize,\n      leafDirectoryOffset: 0,\n      leafDirectoryLength: void 0,\n      tileDataOffset: 0,\n      tileDataLength: void 0,\n      numAddressedTiles: 0,\n      numTileEntries: 0,\n      numTileContents: 0,\n      clustered: false,\n      internalCompression: 1 /* None */,\n      tileCompression,\n      tileType: 1 /* Mvt */,\n      minZoom: minzoom,\n      maxZoom: maxzoom,\n      minLon,\n      minLat,\n      maxLon,\n      maxLat,\n      centerZoom,\n      centerLon,\n      centerLat,\n      etag: resp.etag\n    };\n    return header;\n  });\n}\nfunction getZxy(header, source, cache, z, x, y, signal) {\n  return __async(this, null, function* () {\n    let rootDir = yield cache.getArrayBuffer(\n      source,\n      header.rootDirectoryOffset,\n      header.rootDirectoryLength,\n      header\n    );\n    if (header.specVersion === 1) {\n      rootDir = sortDir(rootDir);\n    }\n    const entry = queryTile(new DataView(rootDir), z, x, y);\n    if (entry) {\n      const resp = yield source.getBytes(entry.offset, entry.length, signal);\n      let tileData = resp.data;\n      const view = new DataView(tileData);\n      if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n        tileData = decompressSync(new Uint8Array(tileData));\n      }\n      return {\n        data: tileData\n      };\n    }\n    const leafcoords = deriveLeaf(new DataView(rootDir), { z, x, y });\n    if (leafcoords) {\n      const leafdirEntry = queryLeafdir(\n        new DataView(rootDir),\n        leafcoords.z,\n        leafcoords.x,\n        leafcoords.y\n      );\n      if (leafdirEntry) {\n        let leafDir = yield cache.getArrayBuffer(\n          source,\n          leafdirEntry.offset,\n          leafdirEntry.length,\n          header\n        );\n        if (header.specVersion === 1) {\n          leafDir = sortDir(leafDir);\n        }\n        const tileEntry = queryTile(new DataView(leafDir), z, x, y);\n        if (tileEntry) {\n          const resp = yield source.getBytes(\n            tileEntry.offset,\n            tileEntry.length,\n            signal\n          );\n          let tileData = resp.data;\n          const view = new DataView(tileData);\n          if (view.getUint8(0) === 31 && view.getUint8(1) === 139) {\n            tileData = decompressSync(new Uint8Array(tileData));\n          }\n          return {\n            data: tileData\n          };\n        }\n      }\n    }\n    return void 0;\n  });\n}\nvar v2_default = {\n  getHeader,\n  getZxy\n};\n\n// adapters.ts\nvar leafletRasterLayer = (source, options) => {\n  let loaded = false;\n  let mimeType = \"\";\n  const cls = L.GridLayer.extend({\n    createTile: (coord, done) => {\n      const el = document.createElement(\"img\");\n      const controller = new AbortController();\n      const signal = controller.signal;\n      el.cancel = () => {\n        controller.abort();\n      };\n      if (!loaded) {\n        source.getHeader().then((header) => {\n          if (header.tileType === 1 /* Mvt */) {\n            console.error(\n              \"Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.\"\n            );\n          } else if (header.tileType === 2) {\n            mimeType = \"image/png\";\n          } else if (header.tileType === 3) {\n            mimeType = \"image/jpeg\";\n          } else if (header.tileType === 4) {\n            mimeType = \"image/webp\";\n          } else if (header.tileType === 5) {\n            mimeType = \"image/avif\";\n          }\n        });\n        loaded = true;\n      }\n      source.getZxy(coord.z, coord.x, coord.y, signal).then((arr) => {\n        if (arr) {\n          const blob = new Blob([arr.data], { type: mimeType });\n          const imageUrl = window.URL.createObjectURL(blob);\n          el.src = imageUrl;\n          el.cancel = void 0;\n          done(void 0, el);\n        }\n      }).catch((e) => {\n        if (e.name !== \"AbortError\") {\n          throw e;\n        }\n      });\n      return el;\n    },\n    _removeTile: function(key) {\n      const tile = this._tiles[key];\n      if (!tile) {\n        return;\n      }\n      if (tile.el.cancel)\n        tile.el.cancel();\n      tile.el.width = 0;\n      tile.el.height = 0;\n      tile.el.deleted = true;\n      L.DomUtil.remove(tile.el);\n      delete this._tiles[key];\n      this.fire(\"tileunload\", {\n        tile: tile.el,\n        coords: this._keyToTileCoords(key)\n      });\n    }\n  });\n  return new cls(options);\n};\nvar v3compat = (v4) => (requestParameters, arg2) => {\n  if (arg2 instanceof AbortController) {\n    return v4(requestParameters, arg2);\n  }\n  const abortController = new AbortController();\n  v4(requestParameters, abortController).then(\n    (result) => {\n      return arg2(\n        void 0,\n        result.data,\n        result.cacheControl || \"\",\n        result.expires || \"\"\n      );\n    },\n    (err2) => {\n      return arg2(err2);\n    }\n  ).catch((e) => {\n    return arg2(e);\n  });\n  return { cancel: () => abortController.abort() };\n};\nvar Protocol = class {\n  /**\n   * Initialize the MapLibre PMTiles protocol.\n   *\n   * * metadata: also load the metadata section of the PMTiles. required for some \"inspect\" functionality\n   * and to automatically populate the map attribution. Requires an extra HTTP request.\n   */\n  constructor(options) {\n    /** @hidden */\n    this.tilev4 = (params, abortController) => __async(this, null, function* () {\n      if (params.type === \"json\") {\n        const pmtilesUrl2 = params.url.substr(10);\n        let instance2 = this.tiles.get(pmtilesUrl2);\n        if (!instance2) {\n          instance2 = new PMTiles(pmtilesUrl2);\n          this.tiles.set(pmtilesUrl2, instance2);\n        }\n        if (this.metadata) {\n          return {\n            data: yield instance2.getTileJson(params.url)\n          };\n        }\n        const h = yield instance2.getHeader();\n        return {\n          data: {\n            tiles: [`${params.url}/{z}/{x}/{y}`],\n            minzoom: h.minZoom,\n            maxzoom: h.maxZoom,\n            bounds: [h.minLon, h.minLat, h.maxLon, h.maxLat]\n          }\n        };\n      }\n      const re = new RegExp(/pmtiles:\\/\\/(.+)\\/(\\d+)\\/(\\d+)\\/(\\d+)/);\n      const result = params.url.match(re);\n      if (!result) {\n        throw new Error(\"Invalid PMTiles protocol URL\");\n      }\n      const pmtilesUrl = result[1];\n      let instance = this.tiles.get(pmtilesUrl);\n      if (!instance) {\n        instance = new PMTiles(pmtilesUrl);\n        this.tiles.set(pmtilesUrl, instance);\n      }\n      const z = result[2];\n      const x = result[3];\n      const y = result[4];\n      const header = yield instance.getHeader();\n      const resp = yield instance == null ? void 0 : instance.getZxy(+z, +x, +y, abortController.signal);\n      if (resp) {\n        return {\n          data: new Uint8Array(resp.data),\n          cacheControl: resp.cacheControl,\n          expires: resp.expires\n        };\n      }\n      if (header.tileType === 1 /* Mvt */) {\n        return { data: new Uint8Array() };\n      }\n      return { data: null };\n    });\n    this.tile = v3compat(this.tilev4);\n    this.tiles = /* @__PURE__ */ new Map();\n    this.metadata = (options == null ? void 0 : options.metadata) || false;\n  }\n  /**\n   * Add a {@link PMTiles} instance to the global protocol instance.\n   *\n   * For remote fetch sources, references in MapLibre styles like pmtiles://http://...\n   * will resolve to the same instance if the URLs match.\n   */\n  add(p) {\n    this.tiles.set(p.source.getKey(), p);\n  }\n  /**\n   * Fetch a {@link PMTiles} instance by URL, for remote PMTiles instances.\n   */\n  get(url) {\n    return this.tiles.get(url);\n  }\n};\n\n// index.ts\nfunction toNum(low, high) {\n  return (high >>> 0) * 4294967296 + (low >>> 0);\n}\nfunction readVarintRemainder(l, p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let h = (b & 112) >> 4;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 3;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 10;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 17;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 127) << 24;\n  if (b < 128)\n    return toNum(l, h);\n  b = buf[p.pos++];\n  h |= (b & 1) << 31;\n  if (b < 128)\n    return toNum(l, h);\n  throw new Error(\"Expected varint not more than 10 bytes\");\n}\nfunction readVarint(p) {\n  const buf = p.buf;\n  let b = buf[p.pos++];\n  let val = b & 127;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 7;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 14;\n  if (b < 128)\n    return val;\n  b = buf[p.pos++];\n  val |= (b & 127) << 21;\n  if (b < 128)\n    return val;\n  b = buf[p.pos];\n  val |= (b & 15) << 28;\n  return readVarintRemainder(val, p);\n}\nfunction rotate(n, xy, rx, ry) {\n  if (ry === 0) {\n    if (rx === 1) {\n      xy[0] = n - 1 - xy[0];\n      xy[1] = n - 1 - xy[1];\n    }\n    const t = xy[0];\n    xy[0] = xy[1];\n    xy[1] = t;\n  }\n}\nfunction idOnLevel(z, pos) {\n  const n = __pow(2, z);\n  let rx = pos;\n  let ry = pos;\n  let t = pos;\n  const xy = [0, 0];\n  let s = 1;\n  while (s < n) {\n    rx = 1 & t / 2;\n    ry = 1 & (t ^ rx);\n    rotate(s, xy, rx, ry);\n    xy[0] += s * rx;\n    xy[1] += s * ry;\n    t = t / 4;\n    s *= 2;\n  }\n  return [z, xy[0], xy[1]];\n}\nvar tzValues = [\n  0,\n  1,\n  5,\n  21,\n  85,\n  341,\n  1365,\n  5461,\n  21845,\n  87381,\n  349525,\n  1398101,\n  5592405,\n  22369621,\n  89478485,\n  357913941,\n  1431655765,\n  5726623061,\n  22906492245,\n  91625968981,\n  366503875925,\n  1466015503701,\n  5864062014805,\n  23456248059221,\n  93824992236885,\n  375299968947541,\n  1501199875790165\n];\nfunction zxyToTileId(z, x, y) {\n  if (z > 26) {\n    throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n  }\n  if (x > __pow(2, z) - 1 || y > __pow(2, z) - 1) {\n    throw Error(\"tile x/y outside zoom level bounds\");\n  }\n  const acc = tzValues[z];\n  const n = __pow(2, z);\n  let rx = 0;\n  let ry = 0;\n  let d = 0;\n  const xy = [x, y];\n  let s = n / 2;\n  while (s > 0) {\n    rx = (xy[0] & s) > 0 ? 1 : 0;\n    ry = (xy[1] & s) > 0 ? 1 : 0;\n    d += s * s * (3 * rx ^ ry);\n    rotate(s, xy, rx, ry);\n    s = s / 2;\n  }\n  return acc + d;\n}\nfunction tileIdToZxy(i) {\n  let acc = 0;\n  const z = 0;\n  for (let z2 = 0; z2 < 27; z2++) {\n    const numTiles = (1 << z2) * (1 << z2);\n    if (acc + numTiles > i) {\n      return idOnLevel(z2, i - acc);\n    }\n    acc += numTiles;\n  }\n  throw Error(\"Tile zoom level exceeds max safe number limit (26)\");\n}\nvar Compression = /* @__PURE__ */ ((Compression2) => {\n  Compression2[Compression2[\"Unknown\"] = 0] = \"Unknown\";\n  Compression2[Compression2[\"None\"] = 1] = \"None\";\n  Compression2[Compression2[\"Gzip\"] = 2] = \"Gzip\";\n  Compression2[Compression2[\"Brotli\"] = 3] = \"Brotli\";\n  Compression2[Compression2[\"Zstd\"] = 4] = \"Zstd\";\n  return Compression2;\n})(Compression || {});\nfunction defaultDecompress(buf, compression) {\n  return __async(this, null, function* () {\n    if (compression === 1 /* None */ || compression === 0 /* Unknown */) {\n      return buf;\n    }\n    if (compression === 2 /* Gzip */) {\n      if (typeof globalThis.DecompressionStream === \"undefined\") {\n        return decompressSync(new Uint8Array(buf));\n      }\n      const stream = new Response(buf).body;\n      if (!stream) {\n        throw Error(\"Failed to read response stream\");\n      }\n      const result = stream.pipeThrough(\n        // biome-ignore lint: needed to detect DecompressionStream in browser+node+cloudflare workers\n        new globalThis.DecompressionStream(\"gzip\")\n      );\n      return new Response(result).arrayBuffer();\n    }\n    throw Error(\"Compression method not supported\");\n  });\n}\nvar TileType = /* @__PURE__ */ ((TileType2) => {\n  TileType2[TileType2[\"Unknown\"] = 0] = \"Unknown\";\n  TileType2[TileType2[\"Mvt\"] = 1] = \"Mvt\";\n  TileType2[TileType2[\"Png\"] = 2] = \"Png\";\n  TileType2[TileType2[\"Jpeg\"] = 3] = \"Jpeg\";\n  TileType2[TileType2[\"Webp\"] = 4] = \"Webp\";\n  TileType2[TileType2[\"Avif\"] = 5] = \"Avif\";\n  return TileType2;\n})(TileType || {});\nfunction tileTypeExt(t) {\n  if (t === 1 /* Mvt */)\n    return \".mvt\";\n  if (t === 2 /* Png */)\n    return \".png\";\n  if (t === 3 /* Jpeg */)\n    return \".jpg\";\n  if (t === 4 /* Webp */)\n    return \".webp\";\n  if (t === 5 /* Avif */)\n    return \".avif\";\n  return \"\";\n}\nvar HEADER_SIZE_BYTES = 127;\nfunction findTile(entries, tileId) {\n  let m = 0;\n  let n = entries.length - 1;\n  while (m <= n) {\n    const k = n + m >> 1;\n    const cmp = tileId - entries[k].tileId;\n    if (cmp > 0) {\n      m = k + 1;\n    } else if (cmp < 0) {\n      n = k - 1;\n    } else {\n      return entries[k];\n    }\n  }\n  if (n >= 0) {\n    if (entries[n].runLength === 0) {\n      return entries[n];\n    }\n    if (tileId - entries[n].tileId < entries[n].runLength) {\n      return entries[n];\n    }\n  }\n  return null;\n}\nvar FileSource = class {\n  constructor(file) {\n    this.file = file;\n  }\n  getKey() {\n    return this.file.name;\n  }\n  getBytes(offset, length) {\n    return __async(this, null, function* () {\n      const blob = this.file.slice(offset, offset + length);\n      const a = yield blob.arrayBuffer();\n      return { data: a };\n    });\n  }\n};\nvar FetchSource = class {\n  constructor(url, customHeaders = new Headers()) {\n    this.url = url;\n    this.customHeaders = customHeaders;\n    this.mustReload = false;\n    let userAgent = \"\";\n    if (\"navigator\" in globalThis) {\n      userAgent = globalThis.navigator.userAgent || \"\";\n    }\n    const isWindows = userAgent.indexOf(\"Windows\") > -1;\n    const isChromiumBased = /Chrome|Chromium|Edg|OPR|Brave/.test(userAgent);\n    this.chromeWindowsNoCache = false;\n    if (isWindows && isChromiumBased) {\n      this.chromeWindowsNoCache = true;\n    }\n  }\n  getKey() {\n    return this.url;\n  }\n  /**\n   * Mutate the custom [Headers](https://developer.mozilla.org/en-US/docs/Web/API/Headers) set for all requests to the remote archive.\n   */\n  setHeaders(customHeaders) {\n    this.customHeaders = customHeaders;\n  }\n  getBytes(offset, length, passedSignal, etag) {\n    return __async(this, null, function* () {\n      let controller;\n      let signal;\n      if (passedSignal) {\n        signal = passedSignal;\n      } else {\n        controller = new AbortController();\n        signal = controller.signal;\n      }\n      const requestHeaders = new Headers(this.customHeaders);\n      requestHeaders.set(\"range\", `bytes=${offset}-${offset + length - 1}`);\n      let cache;\n      if (this.mustReload) {\n        cache = \"reload\";\n      } else if (this.chromeWindowsNoCache) {\n        cache = \"no-store\";\n      }\n      let resp = yield fetch(this.url, {\n        signal,\n        cache,\n        headers: requestHeaders\n        //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n      });\n      if (offset === 0 && resp.status === 416) {\n        const contentRange = resp.headers.get(\"Content-Range\");\n        if (!contentRange || !contentRange.startsWith(\"bytes */\")) {\n          throw Error(\"Missing content-length on 416 response\");\n        }\n        const actualLength = +contentRange.substr(8);\n        resp = yield fetch(this.url, {\n          signal,\n          cache: \"reload\",\n          headers: { range: `bytes=0-${actualLength - 1}` }\n          //biome-ignore lint: \"cache\" is incompatible between cloudflare workers and browser\n        });\n      }\n      let newEtag = resp.headers.get(\"Etag\");\n      if (newEtag == null ? void 0 : newEtag.startsWith(\"W/\")) {\n        newEtag = null;\n      }\n      if (resp.status === 416 || etag && newEtag && newEtag !== etag) {\n        this.mustReload = true;\n        throw new EtagMismatch(\n          `Server returned non-matching ETag ${etag} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`\n        );\n      }\n      if (resp.status >= 300) {\n        throw Error(`Bad response code: ${resp.status}`);\n      }\n      const contentLength = resp.headers.get(\"Content-Length\");\n      if (resp.status === 200 && (!contentLength || +contentLength > length)) {\n        if (controller)\n          controller.abort();\n        throw Error(\n          \"Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.\"\n        );\n      }\n      const a = yield resp.arrayBuffer();\n      return {\n        data: a,\n        etag: newEtag || void 0,\n        cacheControl: resp.headers.get(\"Cache-Control\") || void 0,\n        expires: resp.headers.get(\"Expires\") || void 0\n      };\n    });\n  }\n};\nfunction getUint64(v, offset) {\n  const wh = v.getUint32(offset + 4, true);\n  const wl = v.getUint32(offset + 0, true);\n  return wh * __pow(2, 32) + wl;\n}\nfunction bytesToHeader(bytes, etag) {\n  const v = new DataView(bytes);\n  const specVersion = v.getUint8(7);\n  if (specVersion > 3) {\n    throw Error(\n      `Archive is spec version ${specVersion} but this library supports up to spec version 3`\n    );\n  }\n  return {\n    specVersion,\n    rootDirectoryOffset: getUint64(v, 8),\n    rootDirectoryLength: getUint64(v, 16),\n    jsonMetadataOffset: getUint64(v, 24),\n    jsonMetadataLength: getUint64(v, 32),\n    leafDirectoryOffset: getUint64(v, 40),\n    leafDirectoryLength: getUint64(v, 48),\n    tileDataOffset: getUint64(v, 56),\n    tileDataLength: getUint64(v, 64),\n    numAddressedTiles: getUint64(v, 72),\n    numTileEntries: getUint64(v, 80),\n    numTileContents: getUint64(v, 88),\n    clustered: v.getUint8(96) === 1,\n    internalCompression: v.getUint8(97),\n    tileCompression: v.getUint8(98),\n    tileType: v.getUint8(99),\n    minZoom: v.getUint8(100),\n    maxZoom: v.getUint8(101),\n    minLon: v.getInt32(102, true) / 1e7,\n    minLat: v.getInt32(106, true) / 1e7,\n    maxLon: v.getInt32(110, true) / 1e7,\n    maxLat: v.getInt32(114, true) / 1e7,\n    centerZoom: v.getUint8(118),\n    centerLon: v.getInt32(119, true) / 1e7,\n    centerLat: v.getInt32(123, true) / 1e7,\n    etag\n  };\n}\nfunction deserializeIndex(buffer) {\n  const p = { buf: new Uint8Array(buffer), pos: 0 };\n  const numEntries = readVarint(p);\n  const entries = [];\n  let lastId = 0;\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    entries.push({ tileId: lastId + v, offset: 0, length: 0, runLength: 1 });\n    lastId += v;\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].runLength = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    entries[i].length = readVarint(p);\n  }\n  for (let i = 0; i < numEntries; i++) {\n    const v = readVarint(p);\n    if (v === 0 && i > 0) {\n      entries[i].offset = entries[i - 1].offset + entries[i - 1].length;\n    } else {\n      entries[i].offset = v - 1;\n    }\n  }\n  return entries;\n}\nfunction detectVersion(a) {\n  const v = new DataView(a);\n  if (v.getUint16(2, true) === 2) {\n    console.warn(\n      \"PMTiles spec version 2 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 2;\n  }\n  if (v.getUint16(2, true) === 1) {\n    console.warn(\n      \"PMTiles spec version 1 has been deprecated; please see github.com/protomaps/PMTiles for tools to upgrade\"\n    );\n    return 1;\n  }\n  return 3;\n}\nvar EtagMismatch = class extends Error {\n};\nfunction getHeaderAndRoot(source, decompress) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(0, 16384);\n    const v = new DataView(resp.data);\n    if (v.getUint16(0, true) !== 19792) {\n      throw new Error(\"Wrong magic number for PMTiles archive\");\n    }\n    if (detectVersion(resp.data) < 3) {\n      return [yield v2_default.getHeader(source)];\n    }\n    const headerData = resp.data.slice(0, HEADER_SIZE_BYTES);\n    const header = bytesToHeader(headerData, resp.etag);\n    const rootDirData = resp.data.slice(\n      header.rootDirectoryOffset,\n      header.rootDirectoryOffset + header.rootDirectoryLength\n    );\n    const dirKey = `${source.getKey()}|${header.etag || \"\"}|${header.rootDirectoryOffset}|${header.rootDirectoryLength}`;\n    const rootDir = deserializeIndex(\n      yield decompress(rootDirData, header.internalCompression)\n    );\n    return [header, [dirKey, rootDir.length, rootDir]];\n  });\n}\nfunction getDirectory(source, decompress, offset, length, header) {\n  return __async(this, null, function* () {\n    const resp = yield source.getBytes(offset, length, void 0, header.etag);\n    const data = yield decompress(resp.data, header.internalCompression);\n    const directory = deserializeIndex(data);\n    if (directory.length === 0) {\n      throw new Error(\"Empty directory is invalid\");\n    }\n    return directory;\n  });\n}\nvar ResolvedValueCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const res = yield getHeaderAndRoot(source, this.decompress);\n      if (res[1]) {\n        this.cache.set(res[1][0], {\n          lastUsed: this.counter++,\n          data: res[1][2]\n        });\n      }\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: res[0]\n      });\n      this.prune();\n      return res[0];\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = cacheValue.data;\n        return data;\n      }\n      const directory = yield getDirectory(\n        source,\n        this.decompress,\n        offset,\n        length,\n        header\n      );\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: directory\n      });\n      this.prune();\n      return directory;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const resp = yield source.getBytes(offset, length, void 0, header.etag);\n      this.cache.set(cacheKey, {\n        lastUsed: this.counter++,\n        data: resp.data\n      });\n      this.prune();\n      return resp.data;\n    });\n  }\n  prune() {\n    if (this.cache.size > this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      this.cache.delete(source.getKey());\n    });\n  }\n};\nvar SharedPromiseCache = class {\n  constructor(maxCacheEntries = 100, prefetch = true, decompress = defaultDecompress) {\n    this.cache = /* @__PURE__ */ new Map();\n    this.invalidations = /* @__PURE__ */ new Map();\n    this.maxCacheEntries = maxCacheEntries;\n    this.counter = 1;\n    this.decompress = decompress;\n  }\n  getHeader(source) {\n    return __async(this, null, function* () {\n      const cacheKey = source.getKey();\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getHeaderAndRoot(source, this.decompress).then((res) => {\n          if (res[1]) {\n            this.cache.set(res[1][0], {\n              lastUsed: this.counter++,\n              data: Promise.resolve(res[1][2])\n            });\n          }\n          resolve(res[0]);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  getDirectory(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        getDirectory(source, this.decompress, offset, length, header).then((directory) => {\n          resolve(directory);\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  // for v2 backwards compatibility\n  getArrayBuffer(source, offset, length, header) {\n    return __async(this, null, function* () {\n      const cacheKey = `${source.getKey()}|${header.etag || \"\"}|${offset}|${length}`;\n      const cacheValue = this.cache.get(cacheKey);\n      if (cacheValue) {\n        cacheValue.lastUsed = this.counter++;\n        const data = yield cacheValue.data;\n        return data;\n      }\n      const p = new Promise((resolve, reject) => {\n        source.getBytes(offset, length, void 0, header.etag).then((resp) => {\n          resolve(resp.data);\n          if (this.cache.has(cacheKey)) {\n          }\n          this.prune();\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.cache.set(cacheKey, { lastUsed: this.counter++, data: p });\n      return p;\n    });\n  }\n  prune() {\n    if (this.cache.size >= this.maxCacheEntries) {\n      let minUsed = Infinity;\n      let minKey = void 0;\n      this.cache.forEach((cacheValue, key) => {\n        if (cacheValue.lastUsed < minUsed) {\n          minUsed = cacheValue.lastUsed;\n          minKey = key;\n        }\n      });\n      if (minKey) {\n        this.cache.delete(minKey);\n      }\n    }\n  }\n  invalidate(source) {\n    return __async(this, null, function* () {\n      const key = source.getKey();\n      if (this.invalidations.get(key)) {\n        return yield this.invalidations.get(key);\n      }\n      this.cache.delete(source.getKey());\n      const p = new Promise((resolve, reject) => {\n        this.getHeader(source).then((h) => {\n          resolve();\n          this.invalidations.delete(key);\n        }).catch((e) => {\n          reject(e);\n        });\n      });\n      this.invalidations.set(key, p);\n    });\n  }\n};\nvar PMTiles = class {\n  constructor(source, cache, decompress) {\n    if (typeof source === \"string\") {\n      this.source = new FetchSource(source);\n    } else {\n      this.source = source;\n    }\n    if (decompress) {\n      this.decompress = decompress;\n    } else {\n      this.decompress = defaultDecompress;\n    }\n    if (cache) {\n      this.cache = cache;\n    } else {\n      this.cache = new SharedPromiseCache();\n    }\n  }\n  /**\n   * Return the header of the archive,\n   * including information such as tile type, min/max zoom, bounds, and summary statistics.\n   */\n  getHeader() {\n    return __async(this, null, function* () {\n      return yield this.cache.getHeader(this.source);\n    });\n  }\n  /** @hidden */\n  getZxyAttempt(z, x, y, signal) {\n    return __async(this, null, function* () {\n      const tileId = zxyToTileId(z, x, y);\n      const header = yield this.cache.getHeader(this.source);\n      if (header.specVersion < 3) {\n        return v2_default.getZxy(header, this.source, this.cache, z, x, y, signal);\n      }\n      if (z < header.minZoom || z > header.maxZoom) {\n        return void 0;\n      }\n      let dO = header.rootDirectoryOffset;\n      let dL = header.rootDirectoryLength;\n      for (let depth = 0; depth <= 3; depth++) {\n        const directory = yield this.cache.getDirectory(\n          this.source,\n          dO,\n          dL,\n          header\n        );\n        const entry = findTile(directory, tileId);\n        if (entry) {\n          if (entry.runLength > 0) {\n            const resp = yield this.source.getBytes(\n              header.tileDataOffset + entry.offset,\n              entry.length,\n              signal,\n              header.etag\n            );\n            return {\n              data: yield this.decompress(resp.data, header.tileCompression),\n              cacheControl: resp.cacheControl,\n              expires: resp.expires\n            };\n          }\n          dO = header.leafDirectoryOffset + entry.offset;\n          dL = entry.length;\n        } else {\n          return void 0;\n        }\n      }\n      throw Error(\"Maximum directory depth exceeded\");\n    });\n  }\n  /**\n   * Primary method to get a single tile's bytes from an archive.\n   *\n   * Returns undefined if the tile does not exist in the archive.\n   */\n  getZxy(z, x, y, signal) {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getZxyAttempt(z, x, y, signal);\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getZxyAttempt(z, x, y, signal);\n        }\n        throw e;\n      }\n    });\n  }\n  /** @hidden */\n  getMetadataAttempt() {\n    return __async(this, null, function* () {\n      const header = yield this.cache.getHeader(this.source);\n      const resp = yield this.source.getBytes(\n        header.jsonMetadataOffset,\n        header.jsonMetadataLength,\n        void 0,\n        header.etag\n      );\n      const decompressed = yield this.decompress(\n        resp.data,\n        header.internalCompression\n      );\n      const dec = new TextDecoder(\"utf-8\");\n      return JSON.parse(dec.decode(decompressed));\n    });\n  }\n  /**\n   * Return the arbitrary JSON metadata of the archive.\n   */\n  getMetadata() {\n    return __async(this, null, function* () {\n      try {\n        return yield this.getMetadataAttempt();\n      } catch (e) {\n        if (e instanceof EtagMismatch) {\n          this.cache.invalidate(this.source);\n          return yield this.getMetadataAttempt();\n        }\n        throw e;\n      }\n    });\n  }\n  /**\n   * Construct a [TileJSON](https://github.com/mapbox/tilejson-spec) object.\n   *\n   * baseTilesUrl is the desired tiles URL, excluding the suffix `/{z}/{x}/{y}.{ext}`.\n   * For example, if the desired URL is `http://example.com/tileset/{z}/{x}/{y}.mvt`,\n   * the baseTilesUrl should be `https://example.com/tileset`.\n   */\n  getTileJson(baseTilesUrl) {\n    return __async(this, null, function* () {\n      const header = yield this.getHeader();\n      const metadata = yield this.getMetadata();\n      const ext = tileTypeExt(header.tileType);\n      return {\n        tilejson: \"3.0.0\",\n        scheme: \"xyz\",\n        tiles: [`${baseTilesUrl}/{z}/{x}/{y}${ext}`],\n        // biome-ignore lint: TileJSON spec\n        vector_layers: metadata.vector_layers,\n        attribution: metadata.attribution,\n        description: metadata.description,\n        name: metadata.name,\n        version: metadata.version,\n        bounds: [header.minLon, header.minLat, header.maxLon, header.maxLat],\n        center: [header.centerLon, header.centerLat, header.centerZoom],\n        minzoom: header.minZoom,\n        maxzoom: header.maxZoom\n      };\n    });\n  }\n};\nexport {\n  Compression,\n  EtagMismatch,\n  FetchSource,\n  FileSource,\n  PMTiles,\n  Protocol,\n  ResolvedValueCache,\n  SharedPromiseCache,\n  TileType,\n  bytesToHeader,\n  findTile,\n  getUint64,\n  leafletRasterLayer,\n  readVarint,\n  tileIdToZxy,\n  tileTypeExt,\n  zxyToTileId\n};\n","import { PMTiles } from 'pmtiles';\n\nconst contentType = [\n  'application/octet-stream',\n  'application/x-protobuf',\n  'image/png',\n  'image/jpeg',\n  'image/webp',\n  'image/avif',\n];\n\nconst tileUrlRegex = /\\/([0-9]+)\\/([0-9]+)\\/([0-9]+).(mvt|png|jpg|webp|avif)$/;\nconst protocolRegex = /^pmtiles:\\/\\//;\nconst fixUrlRegex = /^http(s?)\\/\\//; // workaround for broken URLs in Safari\n/** @type {Object<string, PMTiles>} */\nconst pmtilesByUrl = {};\n\nconst { fetch: originalFetch, XMLHttpRequest: OriginalXHR } = window;\n\nexport const fetch = new Proxy(originalFetch, {\n  apply: async (target, that, [input, init]) => {\n    /** @type {string} */\n    let url;\n    if (input instanceof Request) {\n      if (input.method !== 'GET') {\n        return target.call(that, input, init);\n      }\n      url = input.url;\n    } else {\n      url = input.toString();\n    }\n    if (!protocolRegex.test(url)) {\n      return target.call(that, input, init);\n    }\n    url = url.replace(protocolRegex, '').replace(fixUrlRegex, 'http$1://');\n    let baseUrl = url;\n    /** @type {[number, number, number]|null} */\n    let zxy = null;\n    if (tileUrlRegex.test(url)) {\n      baseUrl = url.replace(tileUrlRegex, '');\n      zxy = /** @type {[number, number, number]} */ (\n        url.match(tileUrlRegex)?.slice(1).map(Number)\n      );\n    }\n    if (!(baseUrl in pmtilesByUrl)) {\n      pmtilesByUrl[baseUrl] = new PMTiles(baseUrl);\n    }\n    if (zxy) {\n      const tileResult = await pmtilesByUrl[baseUrl].getZxy(...zxy);\n      if (!tileResult) {\n        return new Response(null, { status: 404 });\n      }\n      const header = await pmtilesByUrl[baseUrl].getHeader();\n      return new Response(tileResult.data, {\n        headers: { 'Content-Type': contentType[header.tileType] },\n      });\n    } else {\n      const data = await pmtilesByUrl[baseUrl].getTileJson(\n        'pmtiles://' + baseUrl,\n      );\n      return new Response(JSON.stringify(data), {\n        headers: { 'Content-Type': 'application/json' },\n      });\n    }\n  },\n});\n\nexport class XMLHttpRequest extends OriginalXHR {\n  constructor() {\n    super();\n    /** @type {string} */\n    let baseUrl;\n    /** @type {undefined|((event: ProgressEvent) => void)} */\n    let onload;\n    /** @type {undefined|((event: ProgressEvent) => void)} */\n    let onerror;\n    /** @type {ArrayBuffer|null} */\n    let response;\n    /** @type {string|null} */\n    let responseText,\n      /** @type {200 | 404} */\n      status;\n    /** @type {Array<number>|null} */\n    let zxy = null;\n    return new Proxy(this, {\n      get: (target, prop) => {\n        if (prop === 'open') {\n          /**\n           * @param {string} method\n           * @param {string} url\n           * @param {boolean} async\n           * @param {string} user\n           * @param {string} password\n           */\n          return (method, url, async = true, user, password) => {\n            if (method !== 'GET' || !protocolRegex.test(url)) {\n              return this.open(method, url, async, user, password);\n            }\n            url = url\n              .replace(protocolRegex, '')\n              .replace(fixUrlRegex, 'http$1://');\n            baseUrl = url;\n            /** @type {[number, number, number]} */\n            if (tileUrlRegex.test(url)) {\n              baseUrl = url.replace(tileUrlRegex, '');\n              zxy = url.match(tileUrlRegex)?.slice(1).map(Number) || null;\n            }\n            if (!(baseUrl in pmtilesByUrl)) {\n              pmtilesByUrl[baseUrl] = new PMTiles(baseUrl);\n            }\n          };\n        } else if (prop === 'send') {\n          /**\n           * @param {XMLHttpRequestBodyInit|Document|null} [body]\n           */\n          return async (body) => {\n            if (!baseUrl) {\n              return this.send(body);\n            }\n            try {\n              const loadEvent = new ProgressEvent('load');\n              if (zxy) {\n                const tileResult = await pmtilesByUrl[baseUrl].getZxy(\n                  zxy[0],\n                  zxy[1],\n                  zxy[2],\n                );\n                if (tileResult) {\n                  status = 200;\n                  response = tileResult.data;\n                } else {\n                  status = 404;\n                  response = null;\n                }\n                this.dispatchEvent(loadEvent);\n                if (onload) {\n                  onload(loadEvent);\n                }\n              } else {\n                const tileResult = await pmtilesByUrl[baseUrl].getTileJson(\n                  'pmtiles://' + baseUrl,\n                );\n                status = 200;\n                responseText = JSON.stringify(tileResult);\n                this.dispatchEvent(loadEvent);\n                if (onload) {\n                  onload(loadEvent);\n                }\n              }\n            } catch (e) {\n              console.error(e);\n              const errorEvent = new ProgressEvent('error');\n              this.dispatchEvent(errorEvent);\n              if (onerror) {\n                onerror(errorEvent);\n              }\n            }\n          };\n        } else if (prop === 'response' && response) {\n          return response;\n        } else if (prop === 'responseText' && responseText) {\n          return responseText;\n        } else if (prop === 'status' && status) {\n          return status;\n        }\n        // @ts-expect-error\n        return target[prop];\n      },\n      set: (target, prop, value) => {\n        if (prop === 'onload') {\n          onload = value;\n        } else if (prop === 'onerror') {\n          onerror = value;\n        }\n        // @ts-expect-error\n        target[prop] = value;\n        return true;\n      },\n    });\n  }\n}\n\n/**\n * Registers fetch and XMLHttpRequest global overrides.\n * @returns {() => void} Unregister function\n */\nexport const register = () => {\n  window.fetch = fetch;\n  window.XMLHttpRequest = XMLHttpRequest;\n  return () => {\n    window.fetch = originalFetch;\n    window.XMLHttpRequest = OriginalXHR;\n  };\n};\n","import 'ol/ol.css';\nimport {apply} from 'ol-mapbox-style';\nimport {register as registerPMTiles} from 'pmtiles-protocol';\n\nregisterPMTiles();\n\napply('map', 'data/protomaps-dark-style.json');\n"],"names":["__pow","Math","pow","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","throw","x","done","then","apply","u8","Uint8Array","u16","Uint16Array","i32","Int32Array","fleb","fdeb","clim","freb","eb","start","b","i","r","j","_a","fl","revfl","_b","fd","rev","hMap","cd","mb","s","length","l","co","le","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","max","a","bits","d","p","o","bits16","ec","err","ind","msg","nt","Error","code","captureStackTrace","inflt","dat","st","buf","dict","sl","dl","f","noBuf","noSt","cbuf","l2","bl","nbuf","set","final","pos","bt","lm","dm","lbt","dbt","n","tbts","type","t","subarray","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","lpos","sym","add","dsym","end","shift2","dend","min","slc","et","gzs","flg","zs","gzl","zls","decompressSync","data","opts","out","dictionary","gunzipSync","inflateSync","unzlibSync","td","TextDecoder","decode","stream","shift","unshift","floor","getUint24","view","getUint16","getUint8","getUint48","getUint32","compare","tz","tx","ty","y","queryTile","z","offsetLen","queryView","offset","isDir","byteLength","k","cmp","entrySort","parseEntry","dataview","zRaw","sortDir","entries","DataView","push","createDirectory","sort","buffer","ArrayBuffer","arr","entry","v2_default","getHeader","source","this","resp","getBytes","jsonSize","rootEntries","dec","jsonMetadata","JSON","parse","tileCompression","compression","minzoom","maxzoom","centerLon","centerLat","centerZoom","minLon","minLat","maxLon","maxLat","bounds","split","center","specVersion","rootDirectoryOffset","rootDirectoryLength","jsonMetadataOffset","jsonMetadataLength","leafDirectoryOffset","leafDirectoryLength","tileDataOffset","tileDataLength","numAddressedTiles","numTileEntries","numTileContents","clustered","internalCompression","tileType","minZoom","maxZoom","etag","getZxy","header","cache","signal","rootDir","getArrayBuffer","tileData","leafcoords","tile","numEntries","leafLevel","levelDiff","trunc","deriveLeaf","leafdirEntry","queryLeafdir","leafDir","tileEntry","toNum","low","high","readVarint","val","h","readVarintRemainder","rotate","xy","rx","ry","tzValues","defaultDecompress","globalThis","DecompressionStream","Response","body","result","pipeThrough","arrayBuffer","findTile","tileId","runLength","FetchSource","constructor","url","customHeaders","Headers","mustReload","userAgent","navigator","isWindows","indexOf","isChromiumBased","test","chromeWindowsNoCache","getKey","setHeaders","passedSignal","controller","AbortController","requestHeaders","fetch","headers","status","contentRange","get","startsWith","actualLength","substr","range","newEtag","EtagMismatch","contentLength","abort","cacheControl","expires","getUint64","wh","wl","deserializeIndex","lastId","SharedPromiseCache","maxCacheEntries","prefetch","decompress","Map","invalidations","counter","cacheKey","cacheValue","lastUsed","console","warn","detectVersion","bytes","getInt32","bytesToHeader","slice","rootDirData","dirKey","getHeaderAndRoot","res","prune","catch","getDirectory","directory","has","size","minKey","minUsed","Infinity","forEach","key","delete","invalidate","PMTiles","getZxyAttempt","acc","zxyToTileId","dO","dL","depth","getMetadataAttempt","decompressed","getMetadata","getTileJson","baseTilesUrl","metadata","ext","tilejson","scheme","tiles","vector_layers","attribution","description","name","version","contentType","tileUrlRegex","protocolRegex","fixUrlRegex","pmtilesByUrl","originalFetch","XMLHttpRequest","OriginalXHR","window","Proxy","async","target","that","input","init","Request","method","call","toString","replace","baseUrl","zxy","match","map","Number","tileResult","stringify","onload","onerror","response","responseText","super","prop","user","password","open","send","loadEvent","ProgressEvent","dispatchEvent","error","errorEvent"],"sourceRoot":""}