(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.applyStyle = applyStyle;
exports.applyBackground = applyBackground;
exports.apply = apply;

var _function = require('@mapbox/mapbox-gl-style-spec/function');

var _function2 = _interopRequireDefault(_function);

var _mapboxToCssFont = require('mapbox-to-css-font');

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

var _mapboxToOlStyle = require('mapbox-to-ol-style');

var _mapboxToOlStyle2 = _interopRequireDefault(_mapboxToOlStyle);

var _webfontloader = require('webfontloader');

var _webfontloader2 = _interopRequireDefault(_webfontloader);

var _proj = require('ol/proj');

var _proj2 = _interopRequireDefault(_proj);

var _tilegrid = require('ol/tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

var _map = require('ol/map');

var _map2 = _interopRequireDefault(_map);

var _geojson = require('ol/format/geojson');

var _geojson2 = _interopRequireDefault(_geojson);

var _mvt = require('ol/format/mvt');

var _mvt2 = _interopRequireDefault(_mvt);

var _observable = require('ol/observable');

var _observable2 = _interopRequireDefault(_observable);

var _tile = require('ol/layer/tile');

var _tile2 = _interopRequireDefault(_tile);

var _vector = require('ol/layer/vector');

var _vector2 = _interopRequireDefault(_vector);

var _vectortile = require('ol/layer/vectortile');

var _vectortile2 = _interopRequireDefault(_vectortile);

var _tilejson = require('ol/source/tilejson');

var _tilejson2 = _interopRequireDefault(_tilejson);

var _vector3 = require('ol/source/vector');

var _vector4 = _interopRequireDefault(_vector3);

var _vectortile3 = require('ol/source/vectortile');

var _vectortile4 = _interopRequireDefault(_vectortile3);

var _xyz = require('ol/source/xyz');

var _xyz2 = _interopRequireDefault(_xyz);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var availableFonts; /*
                    ol-mapbox-style - Use Mapbox Style objects with OpenLayers
                    Copyright 2016-present Boundless Spatial, Inc.
                    License: https://raw.githubusercontent.com/boundlessgeo/ol-mapbox-gl-style/master/LICENSE.md
                    */

function loadFont(fonts, onChange) {
  if (!Array.isArray(fonts)) {
    var stops = fonts.stops;
    if (stops) {
      for (var i = 0, ii = stops.length; i < ii; ++i) {
        loadFont(stops[i][1], onChange);
      }
    }
    return;
  }
  var families = fonts.map(function (font) {
    return (0, _mapboxToCssFont2.default)(font, 1).split(' 1px ')[1];
  });
  _webfontloader2.default.load({
    google: {
      families: families
    },
    fontactive: function (family) {
      var index = families.indexOf(family);
      if (index > -1) {
        var font = families[index];
        if (!availableFonts) {
          availableFonts = [];
        }
        if (availableFonts.indexOf(font) == -1) {
          availableFonts.push(families[index]);
          onChange();
        }
      }
    },
    inactive: function () {
      onChange();
    },
    timeout: 1500
  });
}

var defaultFont = ['Open Sans Regular', 'Arial Unicode MS Regular'];

function preprocess(layer, onChange) {
  if ('layout' in layer && 'text-field' in layer.layout) {
    loadFont(layer.layout['text-font'] || defaultFont, onChange);
  }
}

var spriteRegEx = /^(.*)(\?.*)$/;

function withPath(url, path) {
  if (path && url.indexOf('http') != 0) {
    url = path + url;
  }
  return url;
}

function toSpriteUrl(url, path, extension) {
  url = withPath(url, path);
  var parts = url.match(spriteRegEx);
  return parts ? parts[1] + extension + (parts.length > 2 ? parts[2] : '') : url + extension;
}

/**
 * Applies a style function to an `ol.layer.VectorTile` or `ol.layer.Vector`
 * with an `ol.source.VectorTile` or an `ol.source.Vector`. The style function
 * will render all layers from the `glStyle` object that use the specified
 * `source`, or a subset of layers from the same source. The source needs to be
 * a `"type": "vector"`, `"type": "geojson"` or `"type": "raster"` source.
 *
 * @param {ol.layer.VectorTile} layer OpenLayers layer.
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string} source `source` key or an array of layer `id`s from the
 * Mapbox Style object. When a `source` key is provided, all layers for the
 * specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {string} [path=undefined] Path of the style file. Only required when
 * a relative path is used with the `"sprite"` property of the style.
 * @return {Promise} Promise which will be resolved when the style can be used
 * for rendering.
 */
function applyStyle(layer, glStyle, source, path) {
  return new Promise(function (resolve, reject) {

    if (typeof glStyle != 'object') {
      glStyle = JSON.parse(glStyle);
    }
    if (glStyle.version != 8) {
      reject(new Error('glStyle version 8 required.'));
    }
    var spriteData;
    var spriteImageUrl;
    var spriteScale;
    if (glStyle.sprite) {
      spriteScale = window.devicePixelRatio >= 1.5 ? 0.5 : 1;
      var xhr = new window.XMLHttpRequest();
      var sizeFactor = spriteScale == 0.5 ? '@2x' : '';
      var spriteUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.json');
      xhr.open('GET', spriteUrl);
      xhr.onload = xhr.onerror = function () {
        if (!xhr.responseText) {
          reject(new Error('Sprites cannot be loaded from ' + spriteUrl));
        }
        spriteData = JSON.parse(xhr.responseText);
        onChange();
      };
      xhr.send();
      spriteImageUrl = toSpriteUrl(glStyle.sprite, path, sizeFactor + '.png');
      var spriteImage = document.createElement('IMG');
      spriteImage.onload = function () {
        onChange();
      };
      spriteImage.src = spriteImageUrl;
    }

    var resolutions;
    if (layer instanceof _vectortile2.default) {
      resolutions = layer.getSource().getTileGrid().getResolutions();
    }
    var style;
    function onChange() {
      if (!style && (!glStyle.sprite || spriteData) && (!availableFonts || availableFonts.length > 0)) {
        style = (0, _mapboxToOlStyle2.default)(glStyle, source, resolutions, spriteData, spriteImageUrl, availableFonts);
        layer.setStyle(style);
        resolve();
      } else if (style) {
        layer.setStyle(style);
      }
    }
    if (layer instanceof _vectortile2.default || layer instanceof _vector2.default) {
      try {
        var layers = glStyle.layers;
        for (var i = 0, ii = layers.length; i < ii; ++i) {
          if (typeof source == 'string' && layers[i].source == source || source.indexOf(layers[i].id) >= 0) {
            preprocess(layers[i], onChange);
          }
        }
        onChange();
      } catch (e) {
        window.setTimeout(function () {
          reject(e);
        }, 0);
      }
    }
  });
}

function setBackground(map, layer) {
  function updateStyle() {
    var layout = layer.layout || {};
    var paint = layer.paint || {};
    var element = map.getTargetElement();
    var zoom = map.getView().getZoom();
    if ('background-color' in paint) {
      element.style.backgroundColor = _function2.default['piecewise-constant'](paint['background-color'])(zoom);
    }
    if ('background-opacity' in paint) {
      element.style.backgroundOpacity = _function2.default.interpolated(paint['background-opacity'])(zoom);
    }
    if (layout.visibility == 'none') {
      element.style.backgroundColor = '';
      element.style.backgroundOpacity = '';
    }
  }
  if (map.getTargetElement()) {
    updateStyle();
  }
  map.on(['change:resolution', 'change:target'], updateStyle);
}

/**
 * Applies properties of the Mapbox Style's first `background` layer to the map.
 * @param {ol.Map} map OpenLayers Map.
 * @param {Object} glStyle Mapbox Style object.
 */
function applyBackground(map, glStyle) {
  glStyle.layers.some(function (l) {
    if (l.type == 'background') {
      setBackground(map, l);
      return true;
    }
  });
}

function getSourceIdByRef(layers, ref) {
  var sourceId;
  layers.some(function (layer) {
    if (layer.id == ref) {
      sourceId = layer.source;
      return true;
    }
  });
  return sourceId;
}

function processStyle(glStyle, map, baseUrl, path, accessToken) {
  var view = map.getView();
  if ('center' in glStyle && !view.getCenter()) {
    view.setCenter(_proj2.default.fromLonLat(glStyle.center));
  }
  if ('zoom' in glStyle && view.getZoom() == undefined) {
    view.setZoom(glStyle.zoom);
  }
  if (!('zoom' in glStyle || 'center' in glStyle)) {
    view.fit(view.getProjection().getExtent(), {
      nearest: true,
      size: map.getSize()
    });
  }
  if (glStyle.sprite && glStyle.sprite.indexOf('mapbox://') == 0) {
    glStyle.sprite = baseUrl + '/sprite' + accessToken;
  }

  var glLayers = glStyle.layers;
  var geoJsonFormat = new _geojson2.default();
  var layerIds = [];

  function finalizeLayer(layer) {
    if (layerIds.length > 0) {
      map.addLayer(layer);
      var setStyle = function () {
        applyStyle(layer, glStyle, layerIds, path).then(function () {
          layer.setVisible(true);
        }, function (e) {
          /*eslint no-console: ["error", { allow: ["error"] }] */
          console.error(e);
        });
      };
      if (layer.getSource()) {
        setStyle();
      } else {
        layer.once('change:source', setStyle);
      }
    }
  }

  var glLayer, glSource, glSourceId, id, layer, mapid, url;
  for (var i = 0, ii = glLayers.length; i < ii; ++i) {
    glLayer = glLayers[i];
    if (glLayer.type == 'background') {
      setBackground(map, glLayer);
    } else {
      id = glLayer.source || getSourceIdByRef(glLayers, glLayer.ref);
      if (id != glSourceId) {
        finalizeLayer(layer);
        layerIds = [];
        glSource = glStyle.sources[id];
        url = glSource.url;
        var tiles = glSource.tiles;
        if (url) {
          if (url.indexOf('mapbox://') == 0) {
            mapid = url.replace('mapbox://', '');
            tiles = ['a', 'b', 'c', 'd'].map(function (host) {
              return 'https://' + host + '.tiles.mapbox.com/v4/' + mapid + '/{z}/{x}/{y}.' + (glSource.type == 'vector' ? 'vector.pbf' : 'png') + accessToken;
            });
          }
        }

        if (glSource.type == 'vector') {
          layer = tiles ? new _vectortile2.default({
            source: new _vectortile4.default({
              attributions: glSource.attribution,
              format: new _mvt2.default(),
              tileGrid: _tilegrid2.default.createXYZ({
                tileSize: 512,
                maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
                minZoom: glSource.minzoom
              }),
              tilePixelRatio: 8,
              urls: tiles
            }),
            visible: false,
            zIndex: i
          }) : function () {
            var layer = new _vectortile2.default({
              visible: false,
              zIndex: i
            });
            var tilejson = new _tilejson2.default({
              url: url
            });
            var key = tilejson.on('change', function () {
              if (tilejson.getState() == 'ready') {
                layer.setSource(new _vectortile4.default({
                  attributions: tilejson.getAttributions(),
                  format: new _mvt2.default(),
                  tileGrid: tilejson.getTileGrid(),
                  tilePixelRatio: 16,
                  tileUrlFunction: tilejson.getTileUrlFunction()
                }));
                _observable2.default.unByKey(key);
              }
            });
            return layer;
          }();
        } else if (glSource.type == 'raster') {
          var source;
          if (!glSource.tiles) {
            source = function () {
              return new _tilejson2.default({
                url: url,
                crossOrigin: 'anonymous'
              });
            }();
          } else {
            source = new _xyz2.default({
              attributions: glSource.attribution,
              minZoom: glSource.minzoom,
              maxZoom: 'maxzoom' in glSource ? glSource.maxzoom : 22,
              tileSize: glSource.tileSize || 512,
              url: url,
              urls: glSource.tiles,
              crossOrigin: 'anonymous'
            });
          }
          source.setTileLoadFunction(function (tile, src) {
            if (src.indexOf('{bbox-epsg-3857}') != -1) {
              var bbox = source.getTileGrid().getTileCoordExtent(tile.getTileCoord());
              src = src.replace('{bbox-epsg-3857}', bbox.toString());
            }
            tile.getImage().src = src;
          });
          layer = new _tile2.default({
            source: source
          });
        } else if (glSource.type == 'geojson') {
          var data = glSource.data;
          var features, geoJsonUrl;
          if (typeof data == 'string') {
            geoJsonUrl = withPath(data, path);
          } else {
            features = geoJsonFormat.readFeatures(data, { featureProjection: 'EPSG:3857' });
          }
          layer = new _vector2.default({
            source: new _vector4.default({
              attributions: glSource.attribution,
              features: features,
              format: geoJsonFormat,
              url: geoJsonUrl
            }),
            visible: false,
            zIndex: i
          });
        }
        glSourceId = id;
      }
      layerIds.push(glLayer.id);
    }
  }
  finalizeLayer(layer);
}

/**
 * Loads and applies a Mapbox Style object to an OpenLayers Map.
 * @param {ol.Map|HTMLElement|stribng} map Either an existing OpenLayers Map
 * instance, or a HTML element, or the id of a HTML element that will be the
 * target of a new OpenLayers Map.
 * @param {string} style Url pointing to a Mapbox Style object. When using
 * Mapbox APIs, the url must contain an access token and look like
 * `https://api.mapbox.com/styles/v1/mapbox/bright-v9?access_token=[your_access_token_here]`.
 * @return {ol.Map} The OpenLayers Map instance that will be populated with the
 * contents described in the Mapbox Style object.
 */
function apply(map, style) {

  var accessToken, baseUrl, path;

  if (!(map instanceof _map2.default)) {
    map = new _map2.default({
      target: map
    });
  }

  var parts = style.match(spriteRegEx);
  if (parts) {
    baseUrl = parts[1];
    accessToken = parts.length > 2 ? parts[2] : '';
  }
  var xhr = new XMLHttpRequest();
  xhr.open('GET', style);
  var a = document.createElement('A');
  a.href = style;
  path = a.pathname.split('/').slice(0, -1).join('/') + '/';
  xhr.addEventListener('load', function () {
    var glStyle = JSON.parse(xhr.responseText);
    processStyle(glStyle, map, baseUrl, path, accessToken);
  });
  xhr.addEventListener('error', function () {
    throw new Error('Could not load ' + style);
  });
  xhr.send();

  return map;
}


},{"@mapbox/mapbox-gl-style-spec/function":4,"mapbox-to-css-font":9,"mapbox-to-ol-style":10,"ol/format/geojson":75,"ol/format/mvt":77,"ol/layer/tile":130,"ol/layer/vector":132,"ol/layer/vectortile":133,"ol/map":136,"ol/observable":149,"ol/proj":158,"ol/source/tilejson":223,"ol/source/vector":225,"ol/source/vectortile":227,"ol/source/xyz":228,"ol/tilegrid":248,"webfontloader":289}],2:[function(require,module,exports){
'use strict';

module.exports = createFilter;

var types = ['Unknown', 'Point', 'LineString', 'Polygon'];

/**
 * Given a filter expressed as nested arrays, return a new function
 * that evaluates whether a given feature (with a .properties or .tags property)
 * passes its test.
 *
 * @private
 * @param {Array} filter mapbox gl filter
 * @returns {Function} filter-evaluating function
 */
function createFilter(filter) {
    return new Function('f', ("var p = (f && f.properties || {}); return " + (compile(filter))));
}

function compile(filter) {
    if (!filter) { return 'true'; }
    var op = filter[0];
    if (filter.length <= 1) { return op === 'any' ? 'false' : 'true'; }
    var str = op === '==' ? compileComparisonOp(filter[1], filter[2], '===', false) : op === '!=' ? compileComparisonOp(filter[1], filter[2], '!==', false) : op === '<' || op === '>' || op === '<=' || op === '>=' ? compileComparisonOp(filter[1], filter[2], op, true) : op === 'any' ? compileLogicalOp(filter.slice(1), '||') : op === 'all' ? compileLogicalOp(filter.slice(1), '&&') : op === 'none' ? compileNegation(compileLogicalOp(filter.slice(1), '||')) : op === 'in' ? compileInOp(filter[1], filter.slice(2)) : op === '!in' ? compileNegation(compileInOp(filter[1], filter.slice(2))) : op === 'has' ? compileHasOp(filter[1]) : op === '!has' ? compileNegation(compileHasOp([filter[1]])) : 'true';
    return ("(" + str + ")");
}

function compilePropertyReference(property) {
    return property === '$type' ? 'f.type' : property === '$id' ? 'f.id' : ("p[" + (JSON.stringify(property)) + "]");
}

function compileComparisonOp(property, value, op, checkType) {
    var left = compilePropertyReference(property);
    var right = property === '$type' ? types.indexOf(value) : JSON.stringify(value);
    return (checkType ? ("typeof " + left + "=== typeof " + right + "&&") : '') + left + op + right;
}

function compileLogicalOp(expressions, op) {
    return expressions.map(compile).join(op);
}

function compileInOp(property, values) {
    if (property === '$type') { values = values.map(function (value) {
        return types.indexOf(value);
    }); }
    var left = JSON.stringify(values.sort(compare));
    var right = compilePropertyReference(property);

    if (values.length <= 200) { return (left + ".indexOf(" + right + ") !== -1"); }

    return ("" + ('function(v, a, i, j) {' + 'while (i <= j) { var m = (i + j) >> 1;' + '    if (a[m] === v) return true; if (a[m] > v) j = m - 1; else i = m + 1;' + '}' + 'return false; }(') + right + ", " + left + ",0," + (values.length - 1) + ")");
}

function compileHasOp(property) {
    return ((JSON.stringify(property)) + " in p");
}

function compileNegation(expression) {
    return ("!(" + expression + ")");
}

// Comparison function to sort numbers and strings
function compare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


},{}],3:[function(require,module,exports){
'use strict';

// Constants

var Xn = 0.950470,
      // D65 standard referent
Yn = 1,
      Zn = 1.088830,
      t0 = 4 / 29,
      t1 = 6 / 29,
      t2 = 3 * t1 * t1,
      t3 = t1 * t1 * t1,
      deg2rad = Math.PI / 180,
      rad2deg = 180 / Math.PI;

// Utilities
function xyz2lab(t) {
    return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
    return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
    return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
    x /= 255;
    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

// LAB
function rgbToLab(rgbColor) {
    var b = rgb2xyz(rgbColor[0]),
          a = rgb2xyz(rgbColor[1]),
          l = rgb2xyz(rgbColor[2]),
          x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
          y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
          z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);

    return [116 * y - 16, 500 * (x - y), 200 * (y - z), rgbColor[3]];
}

function labToRgb(labColor) {
    var y = (labColor[0] + 16) / 116,
        x = isNaN(labColor[1]) ? y : y + labColor[1] / 500,
        z = isNaN(labColor[2]) ? y : y - labColor[2] / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return [xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), labColor[3]];
}

// HCL
function rgbToHcl(rgbColor) {
    var labColor = rgbToLab(rgbColor);
    var l = labColor[0],
          a = labColor[1],
          b = labColor[2];
    var h = Math.atan2(b, a) * rad2deg;
    return [h < 0 ? h + 360 : h, Math.sqrt(a * a + b * b), l, rgbColor[3]];
}

function hclToRgb(hclColor) {
    var h = hclColor[0] * deg2rad,
          c = hclColor[1],
          l = hclColor[2];
    return labToRgb([l, Math.cos(h) * c, Math.sin(h) * c, hclColor[3]]);
}

module.exports = {
    lab: {
        forward: rgbToLab,
        reverse: labToRgb
    },
    hcl: {
        forward: rgbToHcl,
        reverse: hclToRgb
    }
};


},{}],4:[function(require,module,exports){
'use strict';

var colorSpaces = require('./color_spaces');

function identityFunction(x) {
    return x;
}

function createFunction(parameters, defaultType) {
    var fun;

    if (!isFunctionDefinition(parameters)) {
        fun = function () {
            return parameters;
        };
        fun.isFeatureConstant = true;
        fun.isZoomConstant = true;
    } else {
        var zoomAndFeatureDependent = parameters.stops && typeof parameters.stops[0][0] === 'object';
        var featureDependent = zoomAndFeatureDependent || parameters.property !== undefined;
        var zoomDependent = zoomAndFeatureDependent || !featureDependent;
        var type = parameters.type || defaultType || 'exponential';

        var innerFun;
        if (type === 'exponential') {
            innerFun = evaluateExponentialFunction;
        } else if (type === 'interval') {
            innerFun = evaluateIntervalFunction;
        } else if (type === 'categorical') {
            innerFun = evaluateCategoricalFunction;
        } else if (type === 'identity') {
            innerFun = evaluateIdentityFunction;
        } else {
            throw new Error(("Unknown function type \"" + type + "\""));
        }

        var outputFunction;

        // If we're interpolating colors in a color system other than RGBA,
        // first translate all stop values to that color system, then interpolate
        // arrays as usual. The `outputFunction` option lets us then translate
        // the result of that interpolation back into RGBA.
        if (parameters.colorSpace && parameters.colorSpace !== 'rgb') {
            if (colorSpaces[parameters.colorSpace]) {
                var colorspace = colorSpaces[parameters.colorSpace];
                // Avoid mutating the parameters value
                parameters = JSON.parse(JSON.stringify(parameters));
                for (var s = 0; s < parameters.stops.length; s++) {
                    parameters.stops[s] = [parameters.stops[s][0], colorspace.forward(parameters.stops[s][1])];
                }
                outputFunction = colorspace.reverse;
            } else {
                throw new Error(("Unknown color space: " + (parameters.colorSpace)));
            }
        } else {
            outputFunction = identityFunction;
        }

        // For categorical functions, generate an Object as a hashmap of the stops for fast searching
        var hashedStops = Object.create(null);
        if (innerFun === evaluateCategoricalFunction) {
            for (var i = 0; i < parameters.stops.length; i++) {
                hashedStops[parameters.stops[i][0]] = parameters.stops[i][1];
            }
        }

        if (zoomAndFeatureDependent) {
            var featureFunctions = {};
            var featureFunctionStops = [];
            for (var s$1 = 0; s$1 < parameters.stops.length; s$1++) {
                var stop = parameters.stops[s$1];
                if (featureFunctions[stop[0].zoom] === undefined) {
                    featureFunctions[stop[0].zoom] = {
                        zoom: stop[0].zoom,
                        type: parameters.type,
                        property: parameters.property,
                        stops: []
                    };
                }
                featureFunctions[stop[0].zoom].stops.push([stop[0].value, stop[1]]);
            }

            for (var z in featureFunctions) {
                featureFunctionStops.push([featureFunctions[z].zoom, createFunction(featureFunctions[z])]);
            }
            fun = function (zoom, feature) {
                return outputFunction(evaluateExponentialFunction({
                    stops: featureFunctionStops,
                    base: parameters.base
                }, zoom)(zoom, feature));
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = false;
        } else if (zoomDependent) {
            fun = function (zoom) {
                if (innerFun === evaluateCategoricalFunction) {
                    return outputFunction(innerFun(parameters, zoom, hashedStops));
                } else {
                    return outputFunction(innerFun(parameters, zoom));
                }
            };
            fun.isFeatureConstant = true;
            fun.isZoomConstant = false;
        } else {
            fun = function (zoom, feature) {
                if (innerFun === evaluateCategoricalFunction) {
                    return outputFunction(innerFun(parameters, feature[parameters.property], hashedStops));
                } else {
                    return outputFunction(innerFun(parameters, feature[parameters.property]));
                }
            };
            fun.isFeatureConstant = false;
            fun.isZoomConstant = true;
        }
    }

    return fun;
}

function evaluateCategoricalFunction(parameters, input, hashedStops) {
    var value = hashedStops[input];
    if (value === undefined) {
        // If the input is not found, return the first value from the original array by default
        return parameters.stops[0][1];
    }

    return value;
}

function evaluateIntervalFunction(parameters, input) {
    // Edge cases
    var n = parameters.stops.length;
    if (n === 1) { return parameters.stops[0][1]; }
    if (input === undefined || input === null) { return parameters.stops[n - 1][1]; }
    if (input <= parameters.stops[0][0]) { return parameters.stops[0][1]; }
    if (input >= parameters.stops[n - 1][0]) { return parameters.stops[n - 1][1]; }

    var index = binarySearchForIndex(parameters.stops, input);

    return parameters.stops[index][1];
}

function evaluateExponentialFunction(parameters, input) {
    var base = parameters.base !== undefined ? parameters.base : 1;

    // Edge cases
    var n = parameters.stops.length;
    if (n === 1) { return parameters.stops[0][1]; }
    if (input === undefined || input === null) { return parameters.stops[n - 1][1]; }
    if (input <= parameters.stops[0][0]) { return parameters.stops[0][1]; }
    if (input >= parameters.stops[n - 1][0]) { return parameters.stops[n - 1][1]; }

    var index = binarySearchForIndex(parameters.stops, input);

    return interpolate(input, base, parameters.stops[index][0], parameters.stops[index + 1][0], parameters.stops[index][1], parameters.stops[index + 1][1]);
}

function evaluateIdentityFunction(parameters, input) {
    return input;
}

function binarySearchForIndex(stops, input) {
    var n = stops.length;
    var lowerIndex = 0;
    var upperIndex = n - 1;
    var currentIndex = 0;
    var currentValue, upperValue;

    while (lowerIndex <= upperIndex) {
        currentIndex = Math.floor((lowerIndex + upperIndex) / 2);
        currentValue = stops[currentIndex][0];
        upperValue = stops[currentIndex + 1][0];
        if (input >= currentValue && input < upperValue) {
            // Search complete
            return currentIndex;
        } else if (currentValue < input) {
            lowerIndex = currentIndex + 1;
        } else if (currentValue > input) {
            upperIndex = currentIndex - 1;
        }
    }

    return Math.max(currentIndex - 1, 0);
}

function interpolate(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    if (typeof outputLower === 'function') {
        return function () {
            var evaluatedLower = outputLower.apply(undefined, arguments);
            var evaluatedUpper = outputUpper.apply(undefined, arguments);
            return interpolate(input, base, inputLower, inputUpper, evaluatedLower, evaluatedUpper);
        };
    } else if (outputLower.length) {
        return interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper);
    } else {
        return interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper);
    }
}

function interpolateNumber(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var difference = inputUpper - inputLower;
    var progress = input - inputLower;

    var ratio;
    if (base === 1) {
        ratio = progress / difference;
    } else {
        ratio = (Math.pow(base, progress) - 1) / (Math.pow(base, difference) - 1);
    }

    return outputLower * (1 - ratio) + outputUpper * ratio;
}

function interpolateArray(input, base, inputLower, inputUpper, outputLower, outputUpper) {
    var output = [];
    for (var i = 0; i < outputLower.length; i++) {
        output[i] = interpolateNumber(input, base, inputLower, inputUpper, outputLower[i], outputUpper[i]);
    }
    return output;
}

function isFunctionDefinition(value) {
    return typeof value === 'object' && (value.stops || value.type === 'identity');
}

module.exports.isFunctionDefinition = isFunctionDefinition;

module.exports.interpolated = function (parameters) {
    return createFunction(parameters, 'exponential');
};

module.exports['piecewise-constant'] = function (parameters) {
    return createFunction(parameters, 'interval');
};


},{"./color_spaces":3}],5:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function placeHoldersCount(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
}

function byteLength(b64) {
  // base64 is 4/3 + up to two characters of the original data
  return b64.length * 3 / 4 - placeHoldersCount(b64);
}

function toByteArray(b64) {
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  placeHolders = placeHoldersCount(b64);

  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 0xFF;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 0x3F];
    output += lookup[tmp << 2 & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('');
}


},{}],6:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

var base64 = require('base64-js');
var ieee754 = require('ieee754');

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;

var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () {
        return 42;
      } };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (value instanceof ArrayBuffer) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  return fromObject(value);
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);

  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype;
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj) {
    if (ArrayBuffer.isView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true;
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) { return 0; }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) { return -1; }
  if (y < x) { return 1; }
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || string instanceof ArrayBuffer) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) { return 0; }

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) { return utf8ToBytes(string).length; } // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var this$1 = this;

  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) { encoding = 'utf8'; }

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this$1, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this$1, start, end);

      case 'ascii':
        return asciiSlice(this$1, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this$1, start, end);

      case 'base64':
        return base64Slice(this$1, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this$1, start, end);

      default:
        if (loweredCase) { throw new TypeError('Unknown encoding: ' + encoding); }
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var this$1 = this;

  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this$1, i, i + 1);
  }
  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var this$1 = this;

  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this$1, i, i + 3);
    swap(this$1, i + 1, i + 2);
  }
  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var this$1 = this;

  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this$1, i, i + 7);
    swap(this$1, i + 1, i + 6);
    swap(this$1, i + 2, i + 5);
    swap(this$1, i + 3, i + 4);
  }
  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) { return ''; }
  if (arguments.length === 0) { return utf8Slice(this, 0, length); }
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) { throw new TypeError('Argument must be a Buffer'); }
  if (this === b) { return true; }
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) { str += ' ... '; }
  }
  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) { return 0; }

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) { return -1; }
  if (y < x) { return 1; }
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) { return -1; }

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) { byteOffset = buffer.length + byteOffset; }
  if (byteOffset >= buffer.length) {
    if (dir) { return -1; }else { byteOffset = buffer.length - 1; }
  } else if (byteOffset < 0) {
    if (dir) { byteOffset = 0; }else { return -1; }
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) { foundIndex = i; }
        if (i - foundIndex + 1 === valLength) { return foundIndex * indexSize; }
      } else {
        if (foundIndex !== -1) { i -= i - foundIndex; }
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) { byteOffset = arrLength - valLength; }
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) { return i; }
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) { throw new TypeError('Invalid hex string'); }

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) { return i; }
    buf[offset + i] = parsed;
  }
  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  var this$1 = this;

  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) { encoding = 'utf8'; }
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) { length = remaining; }

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) { encoding = 'utf8'; }

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this$1, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this$1, string, offset, length);

      case 'ascii':
        return asciiWrite(this$1, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this$1, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this$1, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this$1, string, offset, length);

      default:
        if (loweredCase) { throw new TypeError('Unknown encoding: ' + encoding); }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) { start = 0; }
  if (!end || end < 0 || end > len) { end = len; }

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) { start = 0; }
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) { end = 0; }
  } else if (end > len) {
    end = len;
  }

  if (end < start) { end = start; }

  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) { throw new RangeError('offset is not uint'); }
  if (offset + ext > length) { throw new RangeError('Trying to access beyond buffer length'); }
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  var this$1 = this;

  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) { checkOffset(offset, byteLength, this.length); }

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this$1[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  var this$1 = this;

  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this$1[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 1, this.length); }
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 2, this.length); }
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 2, this.length); }
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }

  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }

  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  var this$1 = this;

  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) { checkOffset(offset, byteLength, this.length); }

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this$1[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) { val -= Math.pow(2, 8 * byteLength); }

  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  var this$1 = this;

  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) { checkOffset(offset, byteLength, this.length); }

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this$1[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) { val -= Math.pow(2, 8 * byteLength); }

  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 1, this.length); }
  if (!(this[offset] & 0x80)) { return this[offset]; }
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 2, this.length); }
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 2, this.length); }
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }

  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }

  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 4, this.length); }
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 8, this.length); }
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) { checkOffset(offset, 8, this.length); }
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) { throw new TypeError('"buffer" argument must be a Buffer instance'); }
  if (value > max || value < min) { throw new RangeError('"value" argument is out of bounds'); }
  if (offset + ext > buf.length) { throw new RangeError('Index out of range'); }
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  var this$1 = this;

  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this$1[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  var this$1 = this;

  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this$1[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 1, 0xff, 0); }
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 2, 0xffff, 0); }
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 2, 0xffff, 0); }
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 4, 0xffffffff, 0); }
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 4, 0xffffffff, 0); }
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  var this$1 = this;

  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this$1[offset + i - 1] !== 0) {
      sub = 1;
    }
    this$1[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  var this$1 = this;

  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this$1[offset + i + 1] !== 0) {
      sub = 1;
    }
    this$1[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 1, 0x7f, -0x80); }
  if (value < 0) { value = 0xff + value + 1; }
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 2, 0x7fff, -0x8000); }
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 2, 0x7fff, -0x8000); }
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000); }
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) { checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000); }
  if (value < 0) { value = 0xffffffff + value + 1; }
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) { throw new RangeError('Index out of range'); }
  if (offset < 0) { throw new RangeError('Index out of range'); }
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  var this$1 = this;

  if (!start) { start = 0; }
  if (!end && end !== 0) { end = this.length; }
  if (targetStart >= target.length) { targetStart = target.length; }
  if (!targetStart) { targetStart = 0; }
  if (end > 0 && end < start) { end = start; }

  // Copy 0 bytes; we're done
  if (end === start) { return 0; }
  if (target.length === 0 || this.length === 0) { return 0; }

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) { throw new RangeError('sourceStart out of bounds'); }
  if (end < 0) { throw new RangeError('sourceEnd out of bounds'); }

  // Are we oob?
  if (end > this.length) { end = this.length; }
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this$1[i + start];
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this$1[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  var this$1 = this;

  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) { val = 0; }

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this$1[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : new Buffer(val, encoding);
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this$1[i + start] = bytes[i % len];
    }
  }

  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) { return ''; }
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}

function stringtrim(str) {
  if (str.trim) { return str.trim(); }
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) { return '0' + n.toString(16); }
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;

        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) { bytes.push(0xEF, 0xBF, 0xBD); }
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) { break; }
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) { break; }
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) { break; }
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) { break; }
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) { break; }

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) { break; }
    dst[i + offset] = src[i];
  }
  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}


},{"base64-js":5,"ieee754":7}],7:[function(require,module,exports){
"use strict";

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};


},{}],8:[function(require,module,exports){
module.exports={
    "version": 8,
    "name": "Bright",
    "metadata": {
        "mapbox:autocomposite": true,
        "mapbox:type": "template",
        "mapbox:groups": {
            "1444849364238.8171": {
                "name": "Buildings",
                "collapsed": true
            },
            "1444849354174.1904": {
                "name": "Tunnels",
                "collapsed": true
            },
            "1444849320558.5054": {
                "name": "Water labels",
                "collapsed": true
            },
            "1444849371739.5945": {
                "name": "Aeroways",
                "collapsed": true
            },
            "1444849258897.3083": {
                "name": "Marine labels",
                "collapsed": true
            },
            "1444849388993.3071": {
                "name": "Landuse",
                "collapsed": true
            },
            "1444849242106.713": {
                "name": "Country labels",
                "collapsed": true
            },
            "1444849382550.77": {
                "name": "Water",
                "collapsed": true
            },
            "1444849345966.4436": {
                "name": "Roads",
                "collapsed": true
            },
            "1444849307123.581": {
                "name": "Admin  lines",
                "collapsed": true
            },
            "1456163609504.0715": {
                "name": "Road labels",
                "collapsed": true
            },
            "1444849272561.29": {
                "name": "Place labels",
                "collapsed": true
            },
            "1444849290021.1838": {
                "name": "Road labels",
                "collapsed": true
            },
            "1444849334699.1902": {
                "name": "Bridges",
                "collapsed": true
            },
            "1444849297111.495": {
                "name": "POI labels",
                "collapsed": true
            }
        }
    },
    "sources": {
        "mapbox": {
            "url": "mapbox://mapbox.mapbox-streets-v7",
            "type": "vector"
        }
    },
    "sprite": "mapbox://sprites/mapbox/bright-v9",
    "glyphs": "mapbox://fonts/mapbox/{fontstack}/{range}.pbf",
    "layers": [
        {
            "id": "background",
            "type": "background",
            "paint": {
                "background-color": "#f8f4f0"
            },
            "interactive": true
        },
        {
            "id": "landuse_overlay_national_park",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse_overlay",
            "filter": [
                "==",
                "class",
                "national_park"
            ],
            "paint": {
                "fill-color": "#d8e8c8",
                "fill-opacity": 0.75
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "id": "landuse_park",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse",
            "filter": [
                "==",
                "class",
                "park"
            ],
            "paint": {
                "fill-color": "#d8e8c8"
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "id": "landuse_cemetery",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse",
            "filter": [
                "==",
                "class",
                "cemetery"
            ],
            "paint": {
                "fill-color": "#e0e4dd"
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "id": "landuse_hospital",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse",
            "filter": [
                "==",
                "class",
                "hospital"
            ],
            "paint": {
                "fill-color": "#fde"
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "id": "landuse_school",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse",
            "filter": [
                "==",
                "class",
                "school"
            ],
            "paint": {
                "fill-color": "#f0e8f8"
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "id": "landuse_wood",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "landuse",
            "filter": [
                "==",
                "class",
                "wood"
            ],
            "paint": {
                "fill-color": "#6a4",
                "fill-opacity": 0.1
            },
            "metadata": {
                "mapbox:group": "1444849388993.3071"
            },
            "interactive": true
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "filter": [
                "all",
                [
                    "!=",
                    "class",
                    "river"
                ],
                [
                    "!=",
                    "class",
                    "stream"
                ],
                [
                    "!=",
                    "class",
                    "canal"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "waterway",
            "paint": {
                "line-color": "#a0c8f0",
                "line-width": {
                    "base": 1.3,
                    "stops": [
                        [
                            13,
                            0.5
                        ],
                        [
                            20,
                            2
                        ]
                    ]
                }
            },
            "source-layer": "waterway"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "filter": [
                "==",
                "class",
                "river"
            ],
            "type": "line",
            "source": "mapbox",
            "id": "waterway_river",
            "paint": {
                "line-color": "#a0c8f0",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            11,
                            0.5
                        ],
                        [
                            20,
                            6
                        ]
                    ]
                }
            },
            "source-layer": "waterway"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "filter": [
                "in",
                "class",
                "stream",
                "canal"
            ],
            "type": "line",
            "source": "mapbox",
            "id": "waterway_stream_canal",
            "paint": {
                "line-color": "#a0c8f0",
                "line-width": {
                    "base": 1.3,
                    "stops": [
                        [
                            13,
                            0.5
                        ],
                        [
                            20,
                            6
                        ]
                    ]
                }
            },
            "source-layer": "waterway"
        },
        {
            "id": "water",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "water",
            "paint": {
                "fill-color": "#a0c8f0"
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "interactive": true
        },
        {
            "id": "water_offset",
            "paint": {
                "fill-color": "white",
                "fill-opacity": 0.3,
                "fill-translate": [
                    0,
                    2.5
                ]
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "interactive": true,
            "ref": "water"
        },
        {
            "id": "water_pattern",
            "paint": {
                "fill-translate": [
                    0,
                    2.5
                ],
                "fill-pattern": "wave"
            },
            "metadata": {
                "mapbox:group": "1444849382550.77"
            },
            "interactive": true,
            "ref": "water"
        },
        {
            "interactive": true,
            "minzoom": 11,
            "metadata": {
                "mapbox:group": "1444849371739.5945"
            },
            "filter": [
                "==",
                "$type",
                "Polygon"
            ],
            "type": "fill",
            "source": "mapbox",
            "id": "aeroway_fill",
            "paint": {
                "fill-color": "#f0ede9",
                "fill-opacity": 0.7
            },
            "source-layer": "aeroway"
        },
        {
            "interactive": true,
            "minzoom": 11,
            "metadata": {
                "mapbox:group": "1444849371739.5945"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "==",
                    "type",
                    "runway"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "aeroway_runway",
            "paint": {
                "line-color": "#f0ede9",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            11,
                            3
                        ],
                        [
                            20,
                            16
                        ]
                    ]
                }
            },
            "source-layer": "aeroway"
        },
        {
            "interactive": true,
            "minzoom": 11,
            "metadata": {
                "mapbox:group": "1444849371739.5945"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "==",
                    "type",
                    "taxiway"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "aeroway_taxiway",
            "paint": {
                "line-color": "#f0ede9",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            11,
                            0.5
                        ],
                        [
                            20,
                            6
                        ]
                    ]
                }
            },
            "source-layer": "aeroway"
        },
        {
            "id": "building",
            "type": "fill",
            "source": "mapbox",
            "source-layer": "building",
            "paint": {
                "fill-color": {
                    "base": 1,
                    "stops": [
                        [
                            15.5,
                            "#f2eae2"
                        ],
                        [
                            16,
                            "#dfdbd7"
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849364238.8171"
            },
            "interactive": true
        },
        {
            "id": "building_top",
            "paint": {
                "fill-color": "#f2eae2",
                "fill-opacity": {
                    "base": 1,
                    "stops": [
                        [
                            15,
                            0
                        ],
                        [
                            16,
                            1
                        ]
                    ]
                },
                "fill-translate": {
                    "stops": [
                        [
                            15,
                            [
                                0,
                                0
                            ]
                        ],
                        [
                            16,
                            [
                                -2,
                                -2
                            ]
                        ]
                    ],
                    "base": 1
                },
                "fill-outline-color": "#dfdbd7"
            },
            "metadata": {
                "mapbox:group": "1444849364238.8171"
            },
            "interactive": true,
            "ref": "building"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "==",
                    "class",
                    "motorway_link"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_motorway_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-dasharray": [
                    0.5,
                    0.25
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "in",
                    "class",
                    "service",
                    "track"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_service_track_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-dasharray": [
                    0.5,
                    0.25
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1
                        ],
                        [
                            16,
                            4
                        ],
                        [
                            20,
                            11
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "==",
                    "class",
                    "link"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "in",
                    "class",
                    "street",
                    "street_limited"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_street_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            0.5
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": {
                    "stops": [
                        [
                            12,
                            0
                        ],
                        [
                            12.5,
                            1
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "in",
                    "class",
                    "secondary",
                    "tertiary"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_secondary_tertiary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            8,
                            1.5
                        ],
                        [
                            20,
                            17
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "in",
                    "class",
                    "trunk",
                    "primary"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_trunk_primary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "==",
                    "class",
                    "motorway"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "tunnel_motorway_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-dasharray": [
                    0.5,
                    0.25
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "id": "tunnel_path_pedestrian",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "all",
                    [
                        "==",
                        "structure",
                        "tunnel"
                    ],
                    [
                        "in",
                        "class",
                        "path",
                        "pedestrian"
                    ]
                ]
            ],
            "paint": {
                "line-color": "#cba",
                "line-dasharray": [
                    1.5,
                    0.75
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1.2
                        ],
                        [
                            20,
                            4
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "interactive": true
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_motorway_link",
            "paint": {
                "line-color": "#fc8",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "tunnel_motorway_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_service_track",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15.5,
                            0
                        ],
                        [
                            16,
                            2
                        ],
                        [
                            20,
                            7.5
                        ]
                    ]
                }
            },
            "ref": "tunnel_service_track_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_link",
            "paint": {
                "line-color": "#fff4c6",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "tunnel_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_street",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            13.5,
                            0
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "ref": "tunnel_street_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_secondary_tertiary",
            "paint": {
                "line-color": "#fff4c6",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            10
                        ]
                    ]
                }
            },
            "ref": "tunnel_secondary_tertiary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_trunk_primary",
            "paint": {
                "line-color": "#fff4c6",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "tunnel_trunk_primary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "id": "tunnel_motorway",
            "paint": {
                "line-color": "#ffdaa6",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "tunnel_motorway_casing"
        },
        {
            "id": "tunnel_major_rail",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "tunnel"
                ],
                [
                    "in",
                    "class",
                    "major_rail",
                    "minor_rail"
                ]
            ],
            "paint": {
                "line-color": "#bbb",
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14,
                            0.4
                        ],
                        [
                            15,
                            0.75
                        ],
                        [
                            20,
                            2
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "interactive": true
        },
        {
            "id": "tunnel_major_rail_hatching",
            "paint": {
                "line-color": "#bbb",
                "line-dasharray": [
                    0.2,
                    8
                ],
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14.5,
                            0
                        ],
                        [
                            15,
                            3
                        ],
                        [
                            20,
                            8
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849354174.1904"
            },
            "interactive": true,
            "ref": "tunnel_major_rail"
        },
        {
            "interactive": true,
            "minzoom": 12,
            "layout": {
                "line-cap": "round",
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "==",
                    "class",
                    "motorway_link"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_motorway_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round",
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "in",
                    "class",
                    "service",
                    "track"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_service_track_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1
                        ],
                        [
                            16,
                            4
                        ],
                        [
                            20,
                            11
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "minzoom": 13,
            "layout": {
                "line-cap": "round",
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "==",
                    "class",
                    "link"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round",
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "all",
                    [
                        "in",
                        "class",
                        "street",
                        "street_limited"
                    ],
                    [
                        "!in",
                        "structure",
                        "bridge",
                        "tunnel"
                    ]
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_street_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            0.5
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": {
                    "stops": [
                        [
                            12,
                            0
                        ],
                        [
                            12.5,
                            1
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round",
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "in",
                    "class",
                    "secondary",
                    "tertiary"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_secondary_tertiary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            8,
                            1.5
                        ],
                        [
                            20,
                            17
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round",
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "in",
                    "class",
                    "trunk",
                    "primary"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_trunk_primary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "minzoom": 5,
            "layout": {
                "line-cap": "round",
                "line-join": "round",
                "visibility": "visible"
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "filter": [
                "all",
                [
                    "==",
                    "class",
                    "motorway"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "road_motorway_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "id": "road_path_pedestrian",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "all",
                    [
                        "in",
                        "class",
                        "path",
                        "pedestrian"
                    ],
                    [
                        "!in",
                        "structure",
                        "bridge",
                        "tunnel"
                    ]
                ]
            ],
            "paint": {
                "line-color": "#cba",
                "line-dasharray": [
                    1.5,
                    0.75
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1.2
                        ],
                        [
                            20,
                            4
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "interactive": true
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_motorway_link",
            "paint": {
                "line-color": "#fc8",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "road_motorway_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_service_track",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15.5,
                            0
                        ],
                        [
                            16,
                            2
                        ],
                        [
                            20,
                            7.5
                        ]
                    ]
                }
            },
            "ref": "road_service_track_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_link",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "road_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_street",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            13.5,
                            0
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "ref": "road_street_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_secondary_tertiary",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            8,
                            0.5
                        ],
                        [
                            20,
                            13
                        ]
                    ]
                }
            },
            "ref": "road_secondary_tertiary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_trunk_primary",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "road_trunk_primary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "id": "road_motorway",
            "paint": {
                "line-color": "#fc8",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "road_motorway_casing"
        },
        {
            "id": "road_major_rail",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "class",
                    "major_rail"
                ],
                [
                    "!in",
                    "structure",
                    "bridge",
                    "tunnel"
                ]
            ],
            "paint": {
                "line-color": "#bbb",
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14,
                            0.4
                        ],
                        [
                            15,
                            0.75
                        ],
                        [
                            20,
                            2
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "interactive": true
        },
        {
            "id": "road_major_rail_hatching",
            "paint": {
                "line-color": "#bbb",
                "line-dasharray": [
                    0.2,
                    8
                ],
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14.5,
                            0
                        ],
                        [
                            15,
                            3
                        ],
                        [
                            20,
                            8
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849345966.4436"
            },
            "interactive": true,
            "ref": "road_major_rail"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "==",
                    "class",
                    "motorway_link"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_motorway_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "in",
                    "class",
                    "service",
                    "track"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_service_track_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1
                        ],
                        [
                            16,
                            4
                        ],
                        [
                            20,
                            11
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "==",
                    "class",
                    "link"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_link_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            1
                        ],
                        [
                            13,
                            3
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "in",
                    "class",
                    "street",
                    "street_limited"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_street_casing",
            "paint": {
                "line-color": "#cfcdca",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            0.5
                        ],
                        [
                            13,
                            1
                        ],
                        [
                            14,
                            4
                        ],
                        [
                            20,
                            15
                        ]
                    ]
                },
                "line-opacity": {
                    "stops": [
                        [
                            12,
                            0
                        ],
                        [
                            12.5,
                            1
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "in",
                    "class",
                    "secondary",
                    "tertiary"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_secondary_tertiary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            8,
                            1.5
                        ],
                        [
                            20,
                            17
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "in",
                    "class",
                    "trunk",
                    "primary"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_trunk_primary_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "==",
                    "class",
                    "motorway"
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "bridge_motorway_casing",
            "paint": {
                "line-color": "#e9ac77",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            5,
                            0.4
                        ],
                        [
                            6,
                            0.6
                        ],
                        [
                            7,
                            1.5
                        ],
                        [
                            20,
                            22
                        ]
                    ]
                }
            },
            "source-layer": "road"
        },
        {
            "id": "bridge_path_pedestrian",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "all",
                    [
                        "==",
                        "structure",
                        "bridge"
                    ],
                    [
                        "in",
                        "class",
                        "path",
                        "pedestrian"
                    ]
                ]
            ],
            "paint": {
                "line-color": "#cba",
                "line-dasharray": [
                    1.5,
                    0.75
                ],
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15,
                            1.2
                        ],
                        [
                            20,
                            4
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "interactive": true
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_motorway_link",
            "paint": {
                "line-color": "#fc8",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "bridge_motorway_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_service_track",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            15.5,
                            0
                        ],
                        [
                            16,
                            2
                        ],
                        [
                            20,
                            7.5
                        ]
                    ]
                }
            },
            "ref": "bridge_service_track_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_link",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            12.5,
                            0
                        ],
                        [
                            13,
                            1.5
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                }
            },
            "ref": "bridge_link_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_street",
            "paint": {
                "line-color": "#fff",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            13.5,
                            0
                        ],
                        [
                            14,
                            2.5
                        ],
                        [
                            20,
                            11.5
                        ]
                    ]
                },
                "line-opacity": 1
            },
            "ref": "bridge_street_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_secondary_tertiary",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            10
                        ]
                    ]
                }
            },
            "ref": "bridge_secondary_tertiary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_trunk_primary",
            "paint": {
                "line-color": "#fea",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "bridge_trunk_primary_casing"
        },
        {
            "interactive": true,
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "id": "bridge_motorway",
            "paint": {
                "line-color": "#fc8",
                "line-width": {
                    "base": 1.2,
                    "stops": [
                        [
                            6.5,
                            0
                        ],
                        [
                            7,
                            0.5
                        ],
                        [
                            20,
                            18
                        ]
                    ]
                }
            },
            "ref": "bridge_motorway_casing"
        },
        {
            "id": "bridge_major_rail",
            "type": "line",
            "source": "mapbox",
            "source-layer": "road",
            "filter": [
                "all",
                [
                    "==",
                    "structure",
                    "bridge"
                ],
                [
                    "==",
                    "class",
                    "major_rail"
                ]
            ],
            "paint": {
                "line-color": "#bbb",
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14,
                            0.4
                        ],
                        [
                            15,
                            0.75
                        ],
                        [
                            20,
                            2
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "interactive": true
        },
        {
            "id": "bridge_major_rail_hatching",
            "paint": {
                "line-color": "#bbb",
                "line-dasharray": [
                    0.2,
                    8
                ],
                "line-width": {
                    "base": 1.4,
                    "stops": [
                        [
                            14.5,
                            0
                        ],
                        [
                            15,
                            3
                        ],
                        [
                            20,
                            8
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849334699.1902"
            },
            "interactive": true,
            "ref": "bridge_major_rail"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849307123.581"
            },
            "filter": [
                "all",
                [
                    ">=",
                    "admin_level",
                    3
                ],
                [
                    "==",
                    "maritime",
                    0
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "admin_level_3",
            "paint": {
                "line-color": "#9e9cab",
                "line-dasharray": [
                    3,
                    1,
                    1,
                    1
                ],
                "line-width": {
                    "base": 1,
                    "stops": [
                        [
                            4,
                            0.4
                        ],
                        [
                            5,
                            1
                        ],
                        [
                            12,
                            3
                        ]
                    ]
                }
            },
            "source-layer": "admin"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round",
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849307123.581"
            },
            "filter": [
                "all",
                [
                    "==",
                    "admin_level",
                    2
                ],
                [
                    "==",
                    "disputed",
                    0
                ],
                [
                    "==",
                    "maritime",
                    0
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "admin_level_2",
            "paint": {
                "line-color": "#9e9cab",
                "line-width": {
                    "base": 1,
                    "stops": [
                        [
                            4,
                            1.4
                        ],
                        [
                            5,
                            2
                        ],
                        [
                            12,
                            8
                        ]
                    ]
                }
            },
            "source-layer": "admin"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849307123.581"
            },
            "filter": [
                "all",
                [
                    "==",
                    "admin_level",
                    2
                ],
                [
                    "==",
                    "disputed",
                    1
                ],
                [
                    "==",
                    "maritime",
                    0
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "admin_level_2_disputed",
            "paint": {
                "line-color": "#9e9cab",
                "line-dasharray": [
                    2,
                    2
                ],
                "line-width": {
                    "base": 1,
                    "stops": [
                        [
                            4,
                            1.4
                        ],
                        [
                            5,
                            2
                        ],
                        [
                            12,
                            8
                        ]
                    ]
                }
            },
            "source-layer": "admin"
        },
        {
            "interactive": true,
            "layout": {
                "line-join": "round"
            },
            "metadata": {
                "mapbox:group": "1444849307123.581"
            },
            "filter": [
                "all",
                [
                    ">=",
                    "admin_level",
                    3
                ],
                [
                    "==",
                    "maritime",
                    1
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "admin_level_3_maritime",
            "paint": {
                "line-color": "#a0c8f0",
                "line-opacity": 0.5,
                "line-dasharray": [
                    3,
                    1,
                    1,
                    1
                ],
                "line-width": {
                    "base": 1,
                    "stops": [
                        [
                            4,
                            0.4
                        ],
                        [
                            5,
                            1
                        ],
                        [
                            12,
                            3
                        ]
                    ]
                }
            },
            "source-layer": "admin"
        },
        {
            "interactive": true,
            "layout": {
                "line-cap": "round"
            },
            "metadata": {
                "mapbox:group": "1444849307123.581"
            },
            "filter": [
                "all",
                [
                    "==",
                    "admin_level",
                    2
                ],
                [
                    "==",
                    "maritime",
                    1
                ]
            ],
            "type": "line",
            "source": "mapbox",
            "id": "admin_level_2_maritime",
            "paint": {
                "line-color": "#a0c8f0",
                "line-opacity": 0.5,
                "line-width": {
                    "base": 1,
                    "stops": [
                        [
                            4,
                            1.4
                        ],
                        [
                            5,
                            2
                        ],
                        [
                            12,
                            8
                        ]
                    ]
                }
            },
            "source-layer": "admin"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 5,
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849320558.5054"
            },
            "filter": [
                "==",
                "$type",
                "Point"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "water_label",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-width": 1.5,
                "text-halo-color": "rgba(255,255,255,0.7)"
            },
            "source-layer": "water_label"
        },
        {
            "interactive": true,
            "minzoom": 16,
            "layout": {
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-padding": 2,
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "scalerank",
                    4
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "poi_label_4",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "poi_label"
        },
        {
            "interactive": true,
            "minzoom": 15,
            "layout": {
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-padding": 2,
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "scalerank",
                    3
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "poi_label_3",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "poi_label"
        },
        {
            "interactive": true,
            "minzoom": 14,
            "layout": {
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-padding": 2,
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "scalerank",
                    2
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "poi_label_2",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "poi_label"
        },
        {
            "layout": {
                "text-size": 12,
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-padding": 2,
                "visibility": "visible",
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-field": "{name_en}",
                "text-max-width": 9
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "type": "symbol",
            "source": "mapbox",
            "id": "rail_station_label",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "rail_station_label",
            "interactive": true
        },
        {
            "interactive": true,
            "minzoom": 13,
            "layout": {
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-padding": 2,
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "scalerank",
                    1
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "poi_label_1",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "poi_label"
        },
        {
            "interactive": true,
            "minzoom": 11,
            "layout": {
                "icon-image": "{maki}-11",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-padding": 2,
                "text-offset": [
                    0,
                    0.6
                ],
                "text-anchor": "top",
                "text-size": 12
            },
            "metadata": {
                "mapbox:group": "1444849297111.495"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "in",
                    "scalerank",
                    1,
                    2,
                    3
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "airport_label",
            "paint": {
                "text-color": "#666",
                "text-halo-color": "#ffffff",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "airport_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-field": "{name_en}",
                "text-font": [
                    "Open Sans Regular",
                    "Arial Unicode MS Regular"
                ],
                "text-size": {
                    "base": 1,
                    "stops": [
                        [
                            13,
                            12
                        ],
                        [
                            14,
                            13
                        ]
                    ]
                },
                "symbol-placement": "line"
            },
            "metadata": {
                "mapbox:group": "1456163609504.0715"
            },
            "filter": [
                "!=",
                "class",
                "ferry"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "road_label",
            "paint": {
                "text-color": "#765",
                "text-halo-width": 1,
                "text-halo-blur": 0.5
            },
            "source-layer": "road_label"
        },
        {
            "interactive": true,
            "minzoom": 8,
            "layout": {
                "text-field": "{ref}",
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-size": 11,
                "icon-image": "motorway_{reflen}",
                "symbol-placement": {
                    "base": 1,
                    "stops": [
                        [
                            10,
                            "point"
                        ],
                        [
                            11,
                            "line"
                        ]
                    ]
                },
                "symbol-spacing": 500,
                "text-rotation-alignment": "viewport",
                "icon-rotation-alignment": "viewport"
            },
            "metadata": {
                "mapbox:group": "1456163609504.0715"
            },
            "filter": [
                "<=",
                "reflen",
                6
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "road_label_highway_shield",
            "paint": {},
            "source-layer": "road_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Bold",
                    "Arial Unicode MS Bold"
                ],
                "text-transform": "uppercase",
                "text-letter-spacing": 0.1,
                "text-field": "{name_en}",
                "text-max-width": 9,
                "text-size": {
                    "base": 1.2,
                    "stops": [
                        [
                            12,
                            10
                        ],
                        [
                            15,
                            14
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849272561.29"
            },
            "filter": [
                "in",
                "type",
                "hamlet",
                "suburb",
                "neighbourhood",
                "island",
                "islet"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "place_label_other",
            "paint": {
                "text-color": "#633",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 1.2
            },
            "source-layer": "place_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Regular",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 8,
                "text-size": {
                    "base": 1.2,
                    "stops": [
                        [
                            10,
                            12
                        ],
                        [
                            15,
                            22
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849272561.29"
            },
            "filter": [
                "==",
                "type",
                "village"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "place_label_village",
            "paint": {
                "text-color": "#333",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 1.2
            },
            "source-layer": "place_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Regular",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 8,
                "text-size": {
                    "base": 1.2,
                    "stops": [
                        [
                            10,
                            14
                        ],
                        [
                            15,
                            24
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849272561.29"
            },
            "filter": [
                "==",
                "type",
                "town"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "place_label_town",
            "paint": {
                "text-color": "#333",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 1.2
            },
            "source-layer": "place_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Semibold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 8,
                "text-size": {
                    "base": 1.2,
                    "stops": [
                        [
                            7,
                            14
                        ],
                        [
                            11,
                            24
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849272561.29"
            },
            "filter": [
                "==",
                "type",
                "city"
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "place_label_city",
            "paint": {
                "text-color": "#333",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 1.2
            },
            "source-layer": "place_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-letter-spacing": 0.2,
                "symbol-placement": "line",
                "text-size": {
                    "stops": [
                        [
                            3,
                            11
                        ],
                        [
                            4,
                            12
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    ">=",
                    "labelrank",
                    4
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_line_4",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 6,
                "text-letter-spacing": 0.2,
                "symbol-placement": "point",
                "text-size": {
                    "stops": [
                        [
                            3,
                            11
                        ],
                        [
                            4,
                            12
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    ">=",
                    "labelrank",
                    4
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_4",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-letter-spacing": 0.2,
                "symbol-placement": "line",
                "text-size": {
                    "stops": [
                        [
                            3,
                            11
                        ],
                        [
                            4,
                            14
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "==",
                    "labelrank",
                    3
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_line_3",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 5,
                "text-letter-spacing": 0.2,
                "symbol-placement": "point",
                "text-size": {
                    "stops": [
                        [
                            3,
                            11
                        ],
                        [
                            4,
                            14
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "labelrank",
                    3
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_point_3",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-letter-spacing": 0.2,
                "symbol-placement": "line",
                "text-size": {
                    "stops": [
                        [
                            3,
                            14
                        ],
                        [
                            4,
                            16
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "==",
                    "labelrank",
                    2
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_line_2",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 5,
                "text-letter-spacing": 0.2,
                "symbol-placement": "point",
                "text-size": {
                    "stops": [
                        [
                            3,
                            14
                        ],
                        [
                            4,
                            16
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "labelrank",
                    2
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_point_2",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-letter-spacing": 0.2,
                "symbol-placement": "line",
                "text-size": {
                    "stops": [
                        [
                            3,
                            18
                        ],
                        [
                            4,
                            22
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "LineString"
                ],
                [
                    "==",
                    "labelrank",
                    1
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_line_1",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Italic",
                    "Arial Unicode MS Regular"
                ],
                "text-field": "{name_en}",
                "text-max-width": 5,
                "text-letter-spacing": 0.2,
                "text-line-height": 1.6,
                "symbol-placement": "point",
                "text-offset": [
                    0,
                    2.4
                ],
                "text-size": {
                    "stops": [
                        [
                            3,
                            18
                        ],
                        [
                            4,
                            22
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849258897.3083"
            },
            "filter": [
                "all",
                [
                    "==",
                    "$type",
                    "Point"
                ],
                [
                    "==",
                    "labelrank",
                    1
                ]
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "marine_label_point_1",
            "paint": {
                "text-color": "#74aee9",
                "text-halo-color": "rgba(255,255,255,0.7)",
                "text-halo-width": 0.75,
                "text-halo-blur": 0.75
            },
            "source-layer": "marine_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Bold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 6.25,
                "text-transform": "uppercase",
                "text-size": {
                    "stops": [
                        [
                            4,
                            11
                        ],
                        [
                            6,
                            15
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849242106.713"
            },
            "filter": [
                ">=",
                "scalerank",
                4
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "country_label_4",
            "paint": {
                "text-color": "#334",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 2,
                "text-halo-blur": 1
            },
            "source-layer": "country_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Bold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 6.25,
                "text-transform": "uppercase",
                "text-size": {
                    "stops": [
                        [
                            3,
                            11
                        ],
                        [
                            7,
                            17
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849242106.713"
            },
            "filter": [
                "==",
                "scalerank",
                3
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "country_label_3",
            "paint": {
                "text-color": "#334",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 2,
                "text-halo-blur": 1
            },
            "source-layer": "country_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Bold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 6.25,
                "text-transform": "uppercase",
                "text-size": {
                    "stops": [
                        [
                            2,
                            11
                        ],
                        [
                            5,
                            17
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849242106.713"
            },
            "filter": [
                "==",
                "scalerank",
                2
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "country_label_2",
            "paint": {
                "text-color": "#334",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 2,
                "text-halo-blur": 1
            },
            "source-layer": "country_label"
        },
        {
            "interactive": true,
            "layout": {
                "text-font": [
                    "Open Sans Bold",
                    "Arial Unicode MS Bold"
                ],
                "text-field": "{name_en}",
                "text-max-width": 6.25,
                "text-transform": "uppercase",
                "text-size": {
                    "stops": [
                        [
                            1,
                            11
                        ],
                        [
                            4,
                            17
                        ]
                    ]
                }
            },
            "metadata": {
                "mapbox:group": "1444849242106.713"
            },
            "filter": [
                "==",
                "scalerank",
                1
            ],
            "type": "symbol",
            "source": "mapbox",
            "id": "country_label_1",
            "paint": {
                "text-color": "#334",
                "text-halo-color": "rgba(255,255,255,0.8)",
                "text-halo-width": 2,
                "text-halo-blur": 1
            },
            "source-layer": "country_label"
        }
    ]
}
},{}],9:[function(require,module,exports){
'use strict';

var fontWeights = {
  thin: 100,
  hairline: 100,
  'ultra-light': 100,
  'extra-light': 100,
  light: 200,
  book: 300,
  regular: 400,
  normal: 400,
  plain: 400,
  roman: 400,
  standard: 400,
  medium: 500,
  'semi-bold': 600,
  'demi-bold': 600,
  bold: 700,
  heavy: 800,
  black: 800,
  'extra-bold': 800,
  'ultra-black': 900,
  'extra-black': 900,
  'ultra-bold': 900,
  'heavy-black': 900,
  fat: 900,
  poster: 900
};
var sp = ' ';

var fontCache = {};

module.exports = function (font, size) {
  var cssData = fontCache[font];
  if (!cssData) {
    var parts = font.split(' ');
    var maybeWeight = parts[parts.length - 1].toLowerCase();
    var weight = 'normal';
    var style = 'normal';
    if (maybeWeight == 'normal' || maybeWeight == 'italic' || maybeWeight == 'oblique') {
      style = maybeWeight;
      parts.pop();
      maybeWeight = parts[parts.length - 1].toLowerCase();
    }
    for (var w in fontWeights) {
      if (maybeWeight == w || maybeWeight == w.replace('-', '') || maybeWeight == w.replace('-', ' ')) {
        weight = fontWeights[w];
        parts.pop();
        break;
      }
    }
    if (typeof maybeWeight == 'number') {
      weight = maybeWeight;
    }
    var fontFamily = parts.join(' ');
    // CSS font property: font-style font-weight font-size font-family
    cssData = fontCache[font] = [style, weight, fontFamily];
  }
  return cssData[0] + sp + cssData[1] + sp + size + 'px' + sp + cssData[2];
};


},{}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (glStyle, source, resolutions, spriteData, spriteImageUrl, fonts) {
  if (!resolutions) {
    resolutions = [];
    for (var res = 156543.03392804097; resolutions.length < 22; res /= 2) {
      resolutions.push(res);
    }
  }
  if (typeof glStyle == 'object') {
    // We do not want to modify the original, so we deep-clone it
    glStyle = JSON.stringify(glStyle);
  }
  glStyle = JSON.parse(glStyle);
  if (glStyle.version != 8) {
    throw new Error('glStyle version 8 required.');
  }

  var ctx = document.createElement('CANVAS').getContext('2d');
  var measureCache = {};
  function wrapText(text, font, em) {
    var key = em + font + text;
    var wrappedText = measureCache[key];
    if (!wrappedText) {
      ctx.font = font;
      var oneEm = ctx.measureText('M').width;
      var width = oneEm * em;
      var words = text.split(' ');
      var line = '';
      var lines = [];
      for (var i = 0, ii = words.length; i < ii; ++i) {
        var word = words[i];
        if (ctx.measureText(line + word).width <= width) {
          line += (line ? ' ' : '') + word;
        } else {
          lines.push(line);
          line = word;
        }
      }
      if (line) {
        lines.push(line);
      }
      wrappedText = measureCache[key] = lines.join('\n');
    }
    return wrappedText;
  }

  var allLayers = glStyle.layers;
  var layersBySourceLayer = {};
  for (var i = 0, ii = allLayers.length; i < ii; ++i) {
    var layer = allLayers[i];
    if (!layer.layout) {
      layer.layout = {};
    }
    resolveRef(layer, glStyle);
    if (typeof source == 'string' && layer.source == source || source.indexOf(layer.id) !== -1) {
      var sourceLayer = layer['source-layer'];
      var layers = layersBySourceLayer[sourceLayer];
      if (!layers) {
        layers = layersBySourceLayer[sourceLayer] = [];
      }
      layers.push({
        layer: layer,
        index: i
      });
      preprocess(layer, fonts);
    }
  }

  var textHalo = new _stroke2.default();
  var textColor = new _fill2.default();

  var iconImageCache = {};

  var styles = [];

  return function (feature, resolution) {
    var properties = feature.getProperties();
    var layers = layersBySourceLayer[properties.layer];
    if (!layers) {
      return;
    }
    var zoom = resolutions.indexOf(resolution);
    if (zoom == -1) {
      zoom = getZoomForResolution(resolution, resolutions);
    }
    var type = types[feature.getGeometry().getType()];
    var f = {
      properties: properties,
      type: type
    };
    var stylesLength = -1;
    for (var i = 0, ii = layers.length; i < ii; ++i) {
      var layerData = layers[i];
      var layer = layerData.layer;
      if ('minzoom' in layer && zoom < layer.minzoom || 'maxzoom' in layer && zoom >= layer.maxzoom) {
        continue;
      }
      if (!layer.filter || layer.filter(f)) {
        var color, opacity, fill, stroke, strokeColor, style, text;
        var paint = layer.paint;
        var index = layerData.index;
        if (type == 3) {
          if (!('fill-pattern' in paint) && 'fill-color' in paint) {
            opacity = paint['fill-opacity'](zoom, properties);
            color = colorWithOpacity(paint['fill-color'](zoom, properties), opacity);
            if (color) {
              ++stylesLength;
              style = styles[stylesLength];
              if (!style || !style.getFill() || style.getStroke() || style.getText()) {
                style = styles[stylesLength] = new _style2.default({
                  fill: new _fill2.default()
                });
              }
              fill = style.getFill();
              fill.setColor(color);
              style.setZIndex(index);
            }
            if ('fill-outline-color' in paint) {
              strokeColor = colorWithOpacity(paint['fill-outline-color'](zoom, properties), opacity);
            }
            if (strokeColor) {
              ++stylesLength;
              style = styles[stylesLength];
              if (!style || !style.getStroke() || style.getFill() || style.getText()) {
                style = styles[stylesLength] = new _style2.default({
                  stroke: new _stroke2.default()
                });
              }
              stroke = style.getStroke();
              stroke.setLineCap(defaults['line-cap']);
              stroke.setLineJoin(defaults['line-join']);
              stroke.setMiterLimit(defaults['line-miter-limit']);
              stroke.setColor(strokeColor);
              stroke.setWidth(1);
              stroke.setLineDash(null);
              style.setZIndex(index);
            }
          }
        }
        if (type != 1) {
          color = !('line-pattern' in paint) && 'line-color' in paint ? colorWithOpacity(paint['line-color'](zoom, properties), paint['line-opacity'](zoom, properties)) : undefined;
          var width = paint['line-width'](zoom, properties);
          if (color && width > 0) {
            ++stylesLength;
            style = styles[stylesLength];
            if (!style || !style.getStroke() || style.getFill() || style.getText()) {
              style = styles[stylesLength] = new _style2.default({
                stroke: new _stroke2.default()
              });
            }
            stroke = style.getStroke();
            stroke.setLineCap(paint['line-cap'](zoom, properties));
            stroke.setLineJoin(paint['line-join'](zoom, properties));
            stroke.setMiterLimit(paint['line-miter-limit'](zoom, properties));
            stroke.setColor(color);
            stroke.setWidth(width);
            stroke.setLineDash(paint['line-dasharray'] ? paint['line-dasharray'](zoom, properties).map(function (x) {
              return x * width;
            }) : null);
            style.setZIndex(index);
          }
        }

        var icon;
        if (type == 1 && 'icon-image' in paint) {
          var iconImage = paint['icon-image'](zoom, properties);
          icon = fromTemplate(iconImage, properties);
          style = iconImageCache[icon];
          if (!style && spriteData && spriteImageUrl) {
            var spriteImageData = spriteData[icon];
            if (spriteImageData) {
              style = iconImageCache[icon] = new _style2.default({
                image: new _icon2.default({
                  src: spriteImageUrl,
                  size: [spriteImageData.width, spriteImageData.height],
                  offset: [spriteImageData.x, spriteImageData.y],
                  scale: paint['icon-size'](zoom, properties) / spriteImageData.pixelRatio
                })
              });
            }
          }
          if (style) {
            ++stylesLength;
            var iconImg = style.getImage();
            iconImg.setRotation(deg2rad(paint['icon-rotate'](zoom, properties)));
            iconImg.setOpacity(paint['icon-opacity'](zoom, properties));
            style.setZIndex(index);
            styles[stylesLength] = style;
          }
        }

        if (type == 1 && 'circle-radius' in paint) {
          ++stylesLength;
          var cache_key = paint['circle-radius'](zoom, properties) + '.' + paint['circle-stroke-color'](zoom, properties) + '.' + paint['circle-color'](zoom, properties);
          style = iconImageCache[cache_key];
          if (!style) {
            style = new _style2.default({
              image: new _circle2.default({
                radius: paint['circle-radius'](zoom, properties),
                stroke: new _stroke2.default({
                  color: colorWithOpacity(paint['circle-stroke-color'](zoom, properties), opacity)
                }),
                fill: new _fill2.default({
                  color: colorWithOpacity(paint['circle-color'](zoom, properties), opacity)
                })
              })
            });
          }
          style.setZIndex(index);
          styles[stylesLength] = style;
        }

        var label;
        if ('text-field' in paint) {
          var textField = paint['text-field'](zoom, properties);
          label = fromTemplate(textField, properties);
        }
        // TODO Add LineString handling as soon as it's supporte in OpenLayers
        if (label && type !== 2) {
          ++stylesLength;
          style = styles[stylesLength];
          if (!style || !style.getText() || style.getFill() || style.getStroke()) {
            style = styles[stylesLength] = new _style2.default({
              text: new _text2.default({
                text: '',
                fill: textColor
              })
            });
          }
          text = style.getText();
          var textSize = paint['text-size'](zoom, properties);
          var font = (0, _mapboxToCssFont2.default)(fontMap[paint['text-font'](zoom, properties)], textSize);
          var textTransform = paint['text-transform'];
          if (textTransform == 'uppercase') {
            label = label.toUpperCase();
          } else if (textTransform == 'lowercase') {
            label = label.toLowerCase();
          }
          var wrappedLabel = wrapText(label, font, paint['text-max-width'](zoom, properties));
          text.setText(wrappedLabel);
          text.setFont(font);
          var offset = paint['text-offset'](zoom, properties);
          var yOffset = offset[1] * textSize + (wrappedLabel.split('\n').length - 1) * textSize;
          var anchor = paint['text-anchor'](zoom, properties);
          if (anchor.indexOf('top') == 0) {
            yOffset += 0.5 * textSize;
          } else if (anchor.indexOf('bottom') == 0) {
            yOffset -= 0.5 * textSize;
          }
          text.setOffsetX(offset[0] * textSize);
          text.setOffsetY(yOffset);
          text.getFill().setColor(paint['text-color'](zoom, properties));
          if (paint['text-halo-width']) {
            textHalo.setWidth(paint['text-halo-width'](zoom, properties));
            textHalo.setColor(paint['text-halo-color'](zoom, properties));
            text.setStroke(textHalo);
          } else {
            text.setStroke(undefined);
          }
          style.setZIndex(index);
        }
      }
    }

    if (stylesLength > -1) {
      styles.length = stylesLength + 1;
      return styles;
    }
  };
};

var _style = require('ol/style/style');

var _style2 = _interopRequireDefault(_style);

var _fill = require('ol/style/fill');

var _fill2 = _interopRequireDefault(_fill);

var _stroke = require('ol/style/stroke');

var _stroke2 = _interopRequireDefault(_stroke);

var _icon = require('ol/style/icon');

var _icon2 = _interopRequireDefault(_icon);

var _circle = require('ol/style/circle');

var _circle2 = _interopRequireDefault(_circle);

var _text = require('ol/style/text');

var _text2 = _interopRequireDefault(_text);

var _function = require('@mapbox/mapbox-gl-style-spec/function');

var _function2 = _interopRequireDefault(_function);

var _feature_filter = require('@mapbox/mapbox-gl-style-spec/feature_filter');

var _feature_filter2 = _interopRequireDefault(_feature_filter);

var _mapboxToCssFont = require('mapbox-to-css-font');

var _mapboxToCssFont2 = _interopRequireDefault(_mapboxToCssFont);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var functions = {
  interpolated: ['line-miter-limit', 'fill-opacity', 'line-opacity', 'line-width', 'text-halo-width', 'text-max-width', 'text-offset', 'text-size', 'icon-opacity', 'icon-rotate', 'icon-size', 'circle-radius'],
  'piecewise-constant': ['fill-color', 'fill-outline-color', 'icon-image', 'line-cap', 'line-color', 'line-join', 'line-dasharray', 'text-anchor', 'text-color', 'text-field', 'text-font', 'text-halo-color', 'circle-color', 'circle-stroke-color']
}; /*
   mapbox-to-ol-style - Create OpenLayers style functions from Mapbox Style objects
   Copyright 2016-present Boundless Spatial, Inc.
   License: https://raw.githubusercontent.com/boundlessgeo/mapbox-to-ol-style/master/LICENSE.md
   */

var defaults = {
  'fill-opacity': 1,
  'line-cap': 'butt',
  'line-join': 'miter',
  'line-miter-limit': 2,
  'line-opacity': 1,
  'line-width': 1,
  'text-anchor': 'center',
  'text-color': '#000000',
  'text-font': ['Open Sans Regular', 'Arial Unicode MS Regular'],
  'text-halo-color': 'rgba(0, 0, 0, 0)',
  'text-halo-width': 0,
  'text-max-width': 10,
  'text-offset': [0, 0],
  'text-size': 16,
  'icon-opacity': 1,
  'icon-rotate': 0,
  'icon-size': 1,
  'circle-color': '#000000',
  'circle-stroke-color': '#000000'
};

var types = {
  'Point': 1,
  'MultiPoint': 1,
  'LineString': 2,
  'MultiLineString': 2,
  'Polygon': 3,
  'MultiPolygon': 3
};

function applyDefaults(properties) {
  for (var property in defaults) {
    if (!(property in properties)) {
      properties[property] = defaults[property];
    }
  }
}

function applyLayoutToPaint(layer) {
  for (var property in layer.layout) {
    if (!layer.paint[property]) {
      layer.paint[property] = layer.layout[property];
    }
  }
}

function convertToFunctions(properties, type) {
  for (var i = 0, ii = functions[type].length; i < ii; ++i) {
    var property = functions[type][i];
    if (property in properties) {
      properties[property] = _function2.default[type](properties[property]);
    }
  }
}

var fontMap = {};

function chooseFont(fonts, availableFonts) {
  if (availableFonts) {
    var font, i, ii;
    if (!Array.isArray(fonts)) {
      var stops = fonts.stops;
      if (stops) {
        for (i = 0, ii = stops.length; i < ii; ++i) {
          chooseFont(stops[i][1], availableFonts);
        }
      }
      return;
    }
    if (!fontMap[fonts]) {
      for (i = 0, ii = fonts.length; i < ii; ++i) {
        font = fonts[i];
        if (availableFonts.indexOf(font) >= -1) {
          fontMap[fonts] = font;
          break;
        }
      }
    }
  } else {
    fontMap[fonts] = fonts[0];
  }
}

function preprocess(layer, fonts) {
  if (!layer.paint) {
    layer.paint = {};
  }
  if (!layer.ref) {
    applyLayoutToPaint(layer);
  }
  applyDefaults(layer.paint);
  if (layer.paint['text-field']) {
    chooseFont(layer.paint['text-font'], fonts);
  }
  if (Array.isArray(layer.filter)) {
    layer.filter = (0, _feature_filter2.default)(layer.filter);
  }
  convertToFunctions(layer.paint, 'interpolated');
  convertToFunctions(layer.paint, 'piecewise-constant');
}

function resolveRef(layer, glStyleObj) {
  if (layer.ref) {
    var layers = glStyleObj.layers;
    for (var i = 0, ii = layers.length; i < ii; ++i) {
      var refLayer = layers[i];
      if (refLayer.id == layer.ref) {
        layer.type = refLayer.type;
        layer.source = refLayer.source;
        layer['source-layer'] = refLayer['source-layer'];
        layer.minzoom = refLayer.minzoom;
        layer.maxzoom = refLayer.maxzoom;
        layer.filter = refLayer.filter;
        layer.layout = refLayer.layout;
        return;
      }
    }
  }
}

function getZoomForResolution(resolution, resolutions) {
  var candidate;
  var i = 0,
      ii = resolutions.length;
  for (; i < ii; ++i) {
    candidate = resolutions[i];
    if (candidate < resolution && i + 1 < ii) {
      var zoomFactor = resolutions[i] / resolutions[i + 1];
      return i + Math.log(resolutions[i] / resolution) / Math.log(zoomFactor);
    }
  }
  return ii - 1;
}

var colorElement = document.createElement('div');
var colorRegEx = /^rgba?\((.*)\)$/;
var colorCache = {};

function colorWithOpacity(color, opacity) {
  if (color && opacity !== undefined) {
    var colorData = colorCache[color];
    if (!colorData) {
      colorElement.style.color = color;
      document.body.appendChild(colorElement);
      var colorString = getComputedStyle(colorElement).getPropertyValue('color');
      document.body.removeChild(colorElement);
      var colorArray = colorString.match(colorRegEx)[1].split(',').map(Number);
      if (colorArray.length == 3) {
        colorArray.push(1);
      }
      colorCache[color] = colorData = {
        color: colorArray,
        opacity: colorArray[3]
      };
    }
    color = colorData.color;
    color[3] = colorData.opacity * opacity;
    if (color[3] === 0) {
      color = undefined;
    }
  }
  return color;
}

function deg2rad(degrees) {
  return degrees * Math.PI / 180;
}

var templateRegEx = /^(.*)\{(.*)\}(.*)$/;

function fromTemplate(text, properties) {
  var parts = text.match(templateRegEx);
  if (parts) {
    var value = properties[parts[2]] || '';
    return parts[1] + value + parts[3];
  } else {
    return text;
  }
}

/**
 * Creates a style function from the `glStyle` object for all layers that use
 * the specified `source`, which needs to be a `"type": "vector"` or
 * `"type": "geojson"` source.
 *
 * @param {string|Object} glStyle Mapbox Style object.
 * @param {string|Array<string>} source `source` key or an array of layer `id`s
 * from the Mapbox Style object. When a `source` key is provided, all layers for
 * the specified source will be included in the style function. When layer `id`s
 * are provided, they must be from layers that use the same source.
 * @param {Array<number>} [resolutions=[156543.03392804097,
 * 78271.51696402048, 39135.75848201024, 19567.87924100512, 9783.93962050256,
 * 4891.96981025128, 2445.98490512564, 1222.99245256282, 611.49622628141,
 * 305.748113140705, 152.8740565703525, 76.43702828517625, 38.21851414258813,
 * 19.109257071294063, 9.554628535647032, 4.777314267823516, 2.388657133911758,
 * 1.194328566955879, 0.5971642834779395, 0.29858214173896974,
 * 0.14929107086948487, 0.07464553543474244]]
 * Resolutions for mapping resolution to zoom level. For tile layers, this can
 * be `layer.getSource().getTileGrid().getResolutions()`.
 * @param {Object} [spriteData=undefined] Sprite data from the url specified in
 * the Mapbox Style object's `sprite` property. Only required if a `sprite`
 * property is specified in the Mapbox Style object.
 * @param {Object} [spriteImageUrl=undefined] Sprite image url for the sprite
 * specified in the Mapbox Style object's `sprite` property. Only required if a
 * `sprite` property is specified in the Mapbox Style object.
 * @param {Array<string>} [fonts=undefined] Array of available fonts, using the
 * same font names as the Mapbox Style object. If not provided, the style
 * function will always use the first font from the font array.
 * @return {ol.style.StyleFunction} Style function for use in
 * `ol.layer.Vector` or `ol.layer.VectorTile`.
 */


},{"@mapbox/mapbox-gl-style-spec/feature_filter":2,"@mapbox/mapbox-gl-style-spec/function":4,"mapbox-to-css-font":9,"ol/style/circle":29,"ol/style/fill":30,"ol/style/icon":31,"ol/style/stroke":38,"ol/style/style":39,"ol/style/text":40}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */
var _ol_AssertionError_ = function (code) {

  var path = _index2.default.VERSION ? _index2.default.VERSION.split('-')[0] : 'latest';

  /**
   * @type {string}
   */
  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';

  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */
  this.code = code;

  this.name = 'AssertionError';
};

_index2.default.inherits(_ol_AssertionError_, Error);
exports.default = _ol_AssertionError_;


},{"./index":24}],12:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assertionerror = require('./assertionerror');

var _assertionerror2 = _interopRequireDefault(_assertionerror);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_asserts_ = {};

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
_ol_asserts_.assert = function (assertion, errorCode) {
  if (!assertion) {
    throw new _assertionerror2.default(errorCode);
  }
};
exports.default = _ol_asserts_;


},{"./assertionerror":11}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_color_ = {};

/**
 * This RegExp matches # followed by 3 or 6 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3}){1,2}$/i;

/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */
_ol_color_.asArray = function (color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return _ol_color_.fromString( /** @type {string} */color);
  }
};

/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
_ol_color_.asString = function (color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return _ol_color_.toString(color);
  }
};

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
_ol_color_.fromNamed = function (color) {
  var el = document.createElement('div');
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};

/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */
_ol_color_.fromString = function () {

  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;

  /**
   * @type {Object.<string, ol.Color>}
   */
  var cache = {};

  /**
   * @type {number}
   */
  var cacheSize = 0;

  return (
    /**
     * @param {string} s String.
     * @return {ol.Color} Color.
     */
    function (s) {
      var color;
      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          var key;
          for (key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }
        color = _ol_color_.fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }
      return color;
    }
  );
}();

/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */
_ol_color_.fromStringInternal_ = function (s) {
  var r, g, b, a, color, parts;

  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {
    s = _ol_color_.fromNamed(s);
  }

  if (_ol_color_.HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits
    _asserts2.default.assert(n == 3 || n == 6, 54); // Hex color should have 3 or 6 digits
    var d = n == 3 ? 1 : 2; // number of digits per channel
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
    }
    a = 1;
    color = [r, g, b, a];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    parts = s.slice(5, -1).split(',').map(Number);
    color = _ol_color_.normalize(parts);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    parts = s.slice(4, -1).split(',').map(Number);
    parts.push(1);
    color = _ol_color_.normalize(parts);
  } else {
    _asserts2.default.assert(false, 14); // Invalid color
  }
  return (/** @type {ol.Color} */color
  );
};

/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */
_ol_color_.normalize = function (color, opt_color) {
  var result = opt_color || [];
  result[0] = _math2.default.clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = _math2.default.clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = _math2.default.clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = _math2.default.clamp(color[3], 0, 1);
  return result;
};

/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */
_ol_color_.toString = function (color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
};
exports.default = _ol_color_;


},{"./asserts":12,"./math":25}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require('./color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_colorlike_ = {};

/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */
_ol_colorlike_.asColorLike = function (color) {
  if (_ol_colorlike_.isColorLike(color)) {
    return (/** @type {string|CanvasPattern|CanvasGradient} */color
    );
  } else {
    return _color2.default.asString( /** @type {ol.Color} */color);
  }
};

/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */
_ol_colorlike_.isColorLike = function (color) {
  return typeof color === 'string' || color instanceof CanvasPattern || color instanceof CanvasGradient;
};
exports.default = _ol_colorlike_;


},{"./color":13}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var _ol_Disposable_ = function () {};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
_ol_Disposable_.prototype.disposed_ = false;

/**
 * Clean up.
 */
_ol_Disposable_.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
_ol_Disposable_.prototype.disposeInternal = _index2.default.nullFunction;
exports.default = _ol_Disposable_;


},{"./index":24}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_dom_ = {};

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
_ol_dom_.createCanvasContext2D = function (opt_width, opt_height) {
  var canvas = document.createElement('CANVAS');
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return canvas.getContext('2d');
};

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */
_ol_dom_.outerWidth = function (element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
};

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */
_ol_dom_.outerHeight = function (element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
};

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
_ol_dom_.replaceNode = function (newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
_ol_dom_.removeNode = function (node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};

/**
 * @param {Node} node The node to remove the children from.
 */
_ol_dom_.removeChildren = function (node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};
exports.default = _ol_dom_;


},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_events_ = {};

/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */
_ol_events_.bindListener_ = function (listenerObj) {
  var boundListener = function (evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      _ol_events_.unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
};

/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */
_ol_events_.findListener_ = function (listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
};

/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */
_ol_events_.getListeners = function (target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};

/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */
_ol_events_.getListenerMap_ = function (target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
};

/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */
_ol_events_.removeListeners_ = function (target, type) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      _obj2.default.clear(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};

/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */
_ol_events_.listen = function (target, type, listener, opt_this, opt_once) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {ol.EventsKey} */{
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
};

/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */
_ol_events_.listenOnce = function (target, type, listener, opt_this) {
  return _ol_events_.listen(target, type, listener, opt_this, true);
};

/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
_ol_events_.unlisten = function (target, type, listener, opt_this) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, true);
    if (listenerObj) {
      _ol_events_.unlistenByKey(listenerObj);
    }
  }
};

/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */
_ol_events_.unlistenByKey = function (key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = _ol_events_.getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        _ol_events_.removeListeners_(key.target, key.type);
      }
    }
    _obj2.default.clear(key);
  }
};

/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */
_ol_events_.unlistenAll = function (target) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  for (var type in listenerMap) {
    _ol_events_.removeListeners_(target, type);
  }
};
exports.default = _ol_events_;


},{"./obj":26}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */
var _ol_events_Event_ = function (type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.preventDefault =

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.stopPropagation = function (evt) {
  evt.stopPropagation();
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.preventDefault = function (evt) {
  evt.preventDefault();
};
exports.default = _ol_events_Event_;


},{}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _disposable = require('../disposable');

var _disposable2 = _interopRequireDefault(_disposable);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */
var _ol_events_EventTarget_ = function () {

  _disposable2.default.call(this);

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.pendingRemovals_ = {};

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.dispatching_ = {};

  /**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */
  this.listeners_ = {};
};

_index2.default.inherits(_ol_events_EventTarget_, _disposable2.default);

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};

/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */
_ol_events_EventTarget_.prototype.dispatchEvent = function (event) {
  var this$1 = this;

  var evt = typeof event === 'string' ? new _event2.default(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this$1, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this$1.removeEventListener(type, _index2.default.nullFunction);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};

/**
 * @inheritDoc
 */
_ol_events_EventTarget_.prototype.disposeInternal = function () {
  _events2.default.unlistenAll(this);
};

/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */
_ol_events_EventTarget_.prototype.getListeners = function (type) {
  return this.listeners_[type];
};

/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */
_ol_events_EventTarget_.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _index2.default.nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
exports.default = _ol_events_EventTarget_;


},{"../disposable":15,"../events":17,"../events/event":18,"../index":24}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 * @const
 */
var _ol_events_EventType_ = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */
  CHANGE: 'change',

  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};

exports.default = _ol_events_EventType_;


},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _ol_geom_GeometryType_ = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

exports.default = _ol_geom_GeometryType_;


},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _webgl = require('./webgl');

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_has_ = {};

var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
_ol_has_.MAC = ua.indexOf('macintosh') !== -1;

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
_ol_has_.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;

/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
_ol_has_.CANVAS_LINE_DASH = false;

/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.CANVAS = _index2.default.ENABLE_CANVAS &&
/**
 * @return {boolean} Canvas supported.
 */
function () {
  if (!('HTMLCanvasElement' in window)) {
    return false;
  }
  try {
    var context = document.createElement('CANVAS').getContext('2d');
    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        _ol_has_.CANVAS_LINE_DASH = true;
      }
      return true;
    }
  } catch (e) {
    return false;
  }
}();

/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;

/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.GEOLOCATION = 'geolocation' in navigator;

/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.TOUCH = _index2.default.ASSUME_TOUCH || 'ontouchstart' in window;

/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
_ol_has_.POINTER = 'PointerEvent' in window;

/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
_ol_has_.MSPOINTER = !!navigator.msPointerEnabled;

/**
 * True if both OpenLayers and browser support WebGL.  Always `false`
 * if `ol.ENABLE_WEBGL` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.WEBGL;

(function () {
  if (false) {
    var hasWebGL = false;
    var textureSize;
    var /** @type {Array.<string>} */extensions = [];

    if ('WebGLRenderingContext' in window) {
      try {
        var canvas = /** @type {HTMLCanvasElement} */
        document.createElement('CANVAS');
        var gl = _webgl2.default.getContext(canvas, {
          failIfMajorPerformanceCaveat: true
        });
        if (gl) {
          hasWebGL = true;
          textureSize = /** @type {number} */
          gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {
        // pass
      }
    }
    _ol_has_.WEBGL = hasWebGL;
    _index2.default.WEBGL_EXTENSIONS = extensions;
    _index2.default.WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();
exports.default = _ol_has_;


},{"./index":24,"./webgl":41}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 */
var _ol_ImageState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};

exports.default = _ol_ImageState_;


},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_ = {};

/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 */

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */
_ol_.ASSUME_TOUCH = false;

/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */
_ol_.DEFAULT_MAX_ZOOM = 42;

/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */
_ol_.DEFAULT_MIN_ZOOM = 0;

/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */
_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;

/**
 * @define {number} Default tile size.
 */
_ol_.DEFAULT_TILE_SIZE = 256;

/**
 * @define {string} Default WMS version.
 */
_ol_.DEFAULT_WMS_VERSION = '1.3.0';

/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */
_ol_.ENABLE_CANVAS = true;

/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */
_ol_.ENABLE_PROJ4JS = true;

/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */
_ol_.ENABLE_RASTER_REPROJECTION = true;

/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */
_ol_.ENABLE_WEBGL = true;

/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */
_ol_.DEBUG_WEBGL = true;

/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */
_ol_.INITIAL_ATLAS_SIZE = 256;

/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */
_ol_.MAX_ATLAS_SIZE = -1;

/**
 * @define {number} Maximum mouse wheel delta.
 */
_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;

/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */
_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;

/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */
_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;

/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */
_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;

/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */
_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;

/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */
_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */
_ol_.SIMPLIFY_TOLERANCE = 0.5;

/**
 * @define {number} Texture cache high water mark.
 */
_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;

/**
 * @define {string} OpenLayers version.
 */
_ol_.VERSION = '4.1.1';

/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @const
 * @type {number|undefined}
 */
_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`


/**
 * List of supported WebGL extensions.
 * @const
 * @type {Array.<string>}
 */
_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */
_ol_.inherits = function (childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
_ol_.nullFunction = function () {};

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
_ol_.getUid = function (obj) {
  return obj.ol_uid || (obj.ol_uid = ++_ol_.uidCounter_);
};

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
_ol_.uidCounter_ = 0;
exports.default = _ol_;


},{}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_math_ = {};

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
_ol_math_.clamp = function (value, min, max) {
  return Math.min(Math.max(value, min), max);
};

/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
_ol_math_.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it
    cosh = Math.cosh;
  } else {
    //  else, use the reference implementation of MDN:
    cosh = function (x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();

/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
_ol_math_.roundUpToPowerOfTwo = function (x) {
  _asserts2.default.assert(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return _ol_math_.squaredDistance(x, y, x1, y1);
};

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredDistance = function (x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
_ol_math_.solveLinearSystem = function (mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
};

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
_ol_math_.toDegrees = function (angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
_ol_math_.toRadians = function (angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
_ol_math_.modulo = function (a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
_ol_math_.lerp = function (a, b, x) {
  return a + x * (b - a);
};
exports.default = _ol_math_;


},{"./asserts":12}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_obj_ = {};

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
_ol_obj_.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
_ol_obj_.clear = function (object) {
  for (var property in object) {
    delete object[property];
  }
};

/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
_ol_obj_.getValues = function (object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
};

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
_ol_obj_.isEmpty = function (object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
};
exports.default = _ol_obj_;


},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_render_canvas_ = {};

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultFont = '10px sans-serif';

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineCap = 'round';

/**
 * @const
 * @type {Array.<number>}
 */
_ol_render_canvas_.defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineDashOffset = 0;

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultMiterLimit = 10;

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextAlign = 'center';

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextBaseline = 'middle';

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineWidth = 1;

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
_ol_render_canvas_.rotateAtOffset = function (context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};
exports.default = _ol_render_canvas_;


},{}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _iconimagecache = require('./style/iconimagecache');

var _iconimagecache2 = _interopRequireDefault(_iconimagecache);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_style_ = {};

_ol_style_.iconImageCache = new _iconimagecache2.default();
exports.default = _ol_style_;


},{"./style/iconimagecache":34}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _regularshape = require('../style/regularshape');

var _regularshape2 = _interopRequireDefault(_regularshape);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */
var _ol_style_Circle_ = function (opt_options) {

  var options = opt_options || {};

  _regularshape2.default.call(this, {
    points: Infinity,
    fill: options.fill,
    radius: options.radius,
    snapToPixel: options.snapToPixel,
    stroke: options.stroke,
    atlasManager: options.atlasManager
  });
};

_index2.default.inherits(_ol_style_Circle_, _regularshape2.default);

/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */
_ol_style_Circle_.prototype.clone = function () {
  var style = new _ol_style_Circle_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    radius: this.getRadius(),
    snapToPixel: this.getSnapToPixel(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */
_ol_style_Circle_.prototype.setRadius = function (radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};
exports.default = _ol_style_Circle_;


},{"../index":24,"../style/regularshape":37}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _color = require('../color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */
var _ol_style_Fill_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */
_ol_style_Fill_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Fill_({
    color: color && color.slice ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Fill_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Fill_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Fill_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = _index2.default.getUid(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? _color2.default.asString(this.color_) : '-');
    }
  }

  return this.checksum_;
};
exports.default = _ol_style_Fill_;


},{"../color":13,"../index":24}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _color = require('../color');

var _color2 = _interopRequireDefault(_color);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _iconanchorunits = require('../style/iconanchorunits');

var _iconanchorunits2 = _interopRequireDefault(_iconanchorunits);

var _iconimage = require('../style/iconimage');

var _iconimage2 = _interopRequireDefault(_iconimage);

var _iconorigin = require('../style/iconorigin');

var _iconorigin2 = _interopRequireDefault(_iconorigin);

var _image = require('../style/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set icon style for vector features.
 *
 * @constructor
 * @param {olx.style.IconOptions=} opt_options Options.
 * @extends {ol.style.Image}
 * @api
 */
var _ol_style_Icon_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {Array.<number>}
   */
  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.normalizedAnchor_ = null;

  /**
   * @private
   * @type {ol.style.IconOrigin}
   */
  this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : _iconorigin2.default.TOP_LEFT;

  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */
  this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : _iconanchorunits2.default.FRACTION;

  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */
  this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : _iconanchorunits2.default.FRACTION;

  /**
   * @private
   * @type {?string}
   */
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @type {Image|HTMLCanvasElement}
   */
  var image = options.img !== undefined ? options.img : null;

  /**
   * @type {ol.Size}
   */
  var imgSize = options.imgSize !== undefined ? options.imgSize : null;

  /**
   * @type {string|undefined}
   */
  var src = options.src;

  _asserts2.default.assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
  _asserts2.default.assert(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided

  if ((src === undefined || src.length === 0) && image) {
    src = image.src || _index2.default.getUid(image).toString();
  }
  _asserts2.default.assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

  /**
   * @type {ol.ImageState}
   */
  var imageState = options.src !== undefined ? _imagestate2.default.IDLE : _imagestate2.default.LOADED;

  /**
   * @private
   * @type {ol.Color}
   */
  this.color_ = options.color !== undefined ? _color2.default.asArray(options.color) : null;

  /**
   * @private
   * @type {ol.style.IconImage}
   */
  this.iconImage_ = _iconimage2.default.get(image, /** @type {string} */src, imgSize, this.crossOrigin_, imageState, this.color_);

  /**
   * @private
   * @type {Array.<number>}
   */
  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];

  /**
   * @private
   * @type {ol.style.IconOrigin}
   */
  this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : _iconorigin2.default.TOP_LEFT;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.origin_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = options.size !== undefined ? options.size : null;

  /**
   * @type {number}
   */
  var opacity = options.opacity !== undefined ? options.opacity : 1;

  /**
   * @type {boolean}
   */
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  /**
   * @type {number}
   */
  var rotation = options.rotation !== undefined ? options.rotation : 0;

  /**
   * @type {number}
   */
  var scale = options.scale !== undefined ? options.scale : 1;

  /**
   * @type {boolean}
   */
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  _image2.default.call(this, {
    opacity: opacity,
    rotation: rotation,
    scale: scale,
    snapToPixel: snapToPixel,
    rotateWithView: rotateWithView
  });
};

_index2.default.inherits(_ol_style_Icon_, _image2.default);

/**
 * Clones the style.
 * @return {ol.style.Icon} The cloned style.
 * @api
 */
_ol_style_Icon_.prototype.clone = function () {
  var oldImage = this.getImage(1);
  var newImage;
  if (this.iconImage_.getImageState() === _imagestate2.default.LOADED) {
    if (oldImage.tagName.toUpperCase() === 'IMG') {
      newImage = /** @type {Image} */oldImage.cloneNode(true);
    } else {
      newImage = /** @type {HTMLCanvasElement} */document.createElement('canvas');
      var context = newImage.getContext('2d');
      newImage.width = oldImage.width;
      newImage.height = oldImage.height;
      context.drawImage(oldImage, 0, 0);
    }
  }
  return new _ol_style_Icon_({
    anchor: this.anchor_.slice(),
    anchorOrigin: this.anchorOrigin_,
    anchorXUnits: this.anchorXUnits_,
    anchorYUnits: this.anchorYUnits_,
    crossOrigin: this.crossOrigin_,
    color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
    img: newImage ? newImage : undefined,
    imgSize: newImage ? this.iconImage_.getSize().slice() : undefined,
    src: newImage ? undefined : this.getSrc(),
    offset: this.offset_.slice(),
    offsetOrigin: this.offsetOrigin_,
    size: this.size_ !== null ? this.size_.slice() : undefined,
    opacity: this.getOpacity(),
    scale: this.getScale(),
    snapToPixel: this.getSnapToPixel(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_Icon_.prototype.getAnchor = function () {
  if (this.normalizedAnchor_) {
    return this.normalizedAnchor_;
  }
  var anchor = this.anchor_;
  var size = this.getSize();
  if (this.anchorXUnits_ == _iconanchorunits2.default.FRACTION || this.anchorYUnits_ == _iconanchorunits2.default.FRACTION) {
    if (!size) {
      return null;
    }
    anchor = this.anchor_.slice();
    if (this.anchorXUnits_ == _iconanchorunits2.default.FRACTION) {
      anchor[0] *= size[0];
    }
    if (this.anchorYUnits_ == _iconanchorunits2.default.FRACTION) {
      anchor[1] *= size[1];
    }
  }

  if (this.anchorOrigin_ != _iconorigin2.default.TOP_LEFT) {
    if (!size) {
      return null;
    }
    if (anchor === this.anchor_) {
      anchor = this.anchor_.slice();
    }
    if (this.anchorOrigin_ == _iconorigin2.default.TOP_RIGHT || this.anchorOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      anchor[0] = -anchor[0] + size[0];
    }
    if (this.anchorOrigin_ == _iconorigin2.default.BOTTOM_LEFT || this.anchorOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      anchor[1] = -anchor[1] + size[1];
    }
  }
  this.normalizedAnchor_ = anchor;
  return this.normalizedAnchor_;
};

/**
 * Get the icon color.
 * @return {ol.Color} Color.
 * @api
 */
_ol_style_Icon_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Get the image icon.
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 * @override
 * @api
 */
_ol_style_Icon_.prototype.getImage = function (pixelRatio) {
  return this.iconImage_.getImage(pixelRatio);
};

/**
 * @override
 */
_ol_style_Icon_.prototype.getImageSize = function () {
  return this.iconImage_.getSize();
};

/**
 * @override
 */
_ol_style_Icon_.prototype.getHitDetectionImageSize = function () {
  return this.getImageSize();
};

/**
 * @override
 */
_ol_style_Icon_.prototype.getImageState = function () {
  return this.iconImage_.getImageState();
};

/**
 * @override
 */
_ol_style_Icon_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.iconImage_.getHitDetectionImage(pixelRatio);
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_Icon_.prototype.getOrigin = function () {
  if (this.origin_) {
    return this.origin_;
  }
  var offset = this.offset_;

  if (this.offsetOrigin_ != _iconorigin2.default.TOP_LEFT) {
    var size = this.getSize();
    var iconImageSize = this.iconImage_.getSize();
    if (!size || !iconImageSize) {
      return null;
    }
    offset = offset.slice();
    if (this.offsetOrigin_ == _iconorigin2.default.TOP_RIGHT || this.offsetOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      offset[0] = iconImageSize[0] - size[0] - offset[0];
    }
    if (this.offsetOrigin_ == _iconorigin2.default.BOTTOM_LEFT || this.offsetOrigin_ == _iconorigin2.default.BOTTOM_RIGHT) {
      offset[1] = iconImageSize[1] - size[1] - offset[1];
    }
  }
  this.origin_ = offset;
  return this.origin_;
};

/**
 * Get the image URL.
 * @return {string|undefined} Image src.
 * @api
 */
_ol_style_Icon_.prototype.getSrc = function () {
  return this.iconImage_.getSrc();
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_Icon_.prototype.getSize = function () {
  return !this.size_ ? this.iconImage_.getSize() : this.size_;
};

/**
 * @override
 */
_ol_style_Icon_.prototype.listenImageChange = function (listener, thisArg) {
  return _events2.default.listen(this.iconImage_, _eventtype2.default.CHANGE, listener, thisArg);
};

/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * @override
 * @api
 */
_ol_style_Icon_.prototype.load = function () {
  this.iconImage_.load();
};

/**
 * @override
 */
_ol_style_Icon_.prototype.unlistenImageChange = function (listener, thisArg) {
  _events2.default.unlisten(this.iconImage_, _eventtype2.default.CHANGE, listener, thisArg);
};
exports.default = _ol_style_Icon_;


},{"../asserts":12,"../color":13,"../events":17,"../events/eventtype":20,"../imagestate":23,"../index":24,"../style/iconanchorunits":32,"../style/iconimage":33,"../style/iconorigin":35,"../style/image":36}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _ol_style_IconAnchorUnits_ = {
  FRACTION: 'fraction',
  PIXELS: 'pixels'
};

exports.default = _ol_style_IconAnchorUnits_;


},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require('../events/eventtarget');

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _style = require('../style');

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string|undefined} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @extends {ol.events.EventTarget}
 */
var _ol_style_IconImage_ = function (image, src, size, crossOrigin, imageState, color) {

  _eventtarget2.default.call(this);

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.hitDetectionImage_ = null;

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.image_ = !image ? new Image() : image;

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = color ?
  /** @type {HTMLCanvasElement} */document.createElement('CANVAS') : null;

  /**
   * @private
   * @type {ol.Color}
   */
  this.color_ = color;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {ol.ImageState}
   */
  this.imageState_ = imageState;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = size;

  /**
   * @private
   * @type {string|undefined}
   */
  this.src_ = src;

  /**
   * @private
   * @type {boolean}
   */
  this.tainting_ = false;
  if (this.imageState_ == _imagestate2.default.LOADED) {
    this.determineTainting_();
  }
};

_index2.default.inherits(_ol_style_IconImage_, _eventtarget2.default);

/**
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */
_ol_style_IconImage_.get = function (image, src, size, crossOrigin, imageState, color) {
  var iconImageCache = _style2.default.iconImageCache;
  var iconImage = iconImageCache.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new _ol_style_IconImage_(image, src, size, crossOrigin, imageState, color);
    iconImageCache.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
};

/**
 * @private
 */
_ol_style_IconImage_.prototype.determineTainting_ = function () {
  var context = _dom2.default.createCanvasContext2D(1, 1);
  try {
    context.drawImage(this.image_, 0, 0);
    context.getImageData(0, 0, 1, 1);
  } catch (e) {
    this.tainting_ = true;
  }
};

/**
 * @private
 */
_ol_style_IconImage_.prototype.dispatchChangeEvent_ = function () {
  this.dispatchEvent(_eventtype2.default.CHANGE);
};

/**
 * @private
 */
_ol_style_IconImage_.prototype.handleImageError_ = function () {
  this.imageState_ = _imagestate2.default.ERROR;
  this.unlistenImage_();
  this.dispatchChangeEvent_();
};

/**
 * @private
 */
_ol_style_IconImage_.prototype.handleImageLoad_ = function () {
  this.imageState_ = _imagestate2.default.LOADED;
  if (this.size_) {
    this.image_.width = this.size_[0];
    this.image_.height = this.size_[1];
  }
  this.size_ = [this.image_.width, this.image_.height];
  this.unlistenImage_();
  this.determineTainting_();
  this.replaceColor_();
  this.dispatchChangeEvent_();
};

/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 */
_ol_style_IconImage_.prototype.getImage = function (pixelRatio) {
  return this.canvas_ ? this.canvas_ : this.image_;
};

/**
 * @return {ol.ImageState} Image state.
 */
_ol_style_IconImage_.prototype.getImageState = function () {
  return this.imageState_;
};

/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image element.
 */
_ol_style_IconImage_.prototype.getHitDetectionImage = function (pixelRatio) {
  if (!this.hitDetectionImage_) {
    if (this.tainting_) {
      var width = this.size_[0];
      var height = this.size_[1];
      var context = _dom2.default.createCanvasContext2D(width, height);
      context.fillRect(0, 0, width, height);
      this.hitDetectionImage_ = context.canvas;
    } else {
      this.hitDetectionImage_ = this.image_;
    }
  }
  return this.hitDetectionImage_;
};

/**
 * @return {ol.Size} Image size.
 */
_ol_style_IconImage_.prototype.getSize = function () {
  return this.size_;
};

/**
 * @return {string|undefined} Image src.
 */
_ol_style_IconImage_.prototype.getSrc = function () {
  return this.src_;
};

/**
 * Load not yet loaded URI.
 */
_ol_style_IconImage_.prototype.load = function () {
  if (this.imageState_ == _imagestate2.default.IDLE) {
    this.imageState_ = _imagestate2.default.LOADING;
    this.imageListenerKeys_ = [_events2.default.listenOnce(this.image_, _eventtype2.default.ERROR, this.handleImageError_, this), _events2.default.listenOnce(this.image_, _eventtype2.default.LOAD, this.handleImageLoad_, this)];
    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
  }
};

/**
 * @private
 */
_ol_style_IconImage_.prototype.replaceColor_ = function () {
  if (this.tainting_ || this.color_ === null) {
    return;
  }

  this.canvas_.width = this.image_.width;
  this.canvas_.height = this.image_.height;

  var ctx = this.canvas_.getContext('2d');
  ctx.drawImage(this.image_, 0, 0);

  var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
  var data = imgData.data;
  var r = this.color_[0] / 255.0;
  var g = this.color_[1] / 255.0;
  var b = this.color_[2] / 255.0;

  for (var i = 0, ii = data.length; i < ii; i += 4) {
    data[i] *= r;
    data[i + 1] *= g;
    data[i + 2] *= b;
  }
  ctx.putImageData(imgData, 0, 0);
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
_ol_style_IconImage_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.imageListenerKeys_ = null;
};
exports.default = _ol_style_IconImage_;


},{"../dom":16,"../events":17,"../events/eventtarget":19,"../events/eventtype":20,"../imagestate":23,"../index":24,"../style":28}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require('../color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 */
var _ol_style_IconImageCache_ = function () {

  /**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */
  this.cache_ = {};

  /**
   * @type {number}
   * @private
   */
  this.cacheSize_ = 0;

  /**
   * @const
   * @type {number}
   * @private
   */
  this.maxCacheSize_ = 32;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */
_ol_style_IconImageCache_.getKey = function (src, crossOrigin, color) {
  var colorString = color ? _color2.default.asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.clear = function () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.expire = function () {
  var this$1 = this;

  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;
    for (key in this$1.cache_) {
      iconImage = this$1.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this$1.cache_[key];
        --this$1.cacheSize_;
      }
    }
  }
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */
_ol_style_IconImageCache_.prototype.get = function (src, crossOrigin, color) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */
_ol_style_IconImageCache_.prototype.set = function (src, crossOrigin, color, iconImage) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};
exports.default = _ol_style_IconImageCache_;


},{"../color":13}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _ol_style_IconOrigin_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

exports.default = _ol_style_IconOrigin_;


},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */
var _ol_style_Image_ = function (options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

  /**
   * @private
   * @type {boolean}
   */
  this.snapToPixel_ = options.snapToPixel;
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
_ol_style_Image_.prototype.getOpacity = function () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
_ol_style_Image_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
_ol_style_Image_.prototype.getRotation = function () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
_ol_style_Image_.prototype.getScale = function () {
  return this.scale_;
};

/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */
_ol_style_Image_.prototype.getSnapToPixel = function () {
  return this.snapToPixel_;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */
_ol_style_Image_.prototype.getAnchor = function () {};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getImage = function (pixelRatio) {};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getHitDetectionImage = function (pixelRatio) {};

/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */
_ol_style_Image_.prototype.getImageState = function () {};

/**
 * @abstract
 * @return {ol.Size} Image size.
 */
_ol_style_Image_.prototype.getImageSize = function () {};

/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */
_ol_style_Image_.prototype.getHitDetectionImageSize = function () {};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */
_ol_style_Image_.prototype.getOrigin = function () {};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */
_ol_style_Image_.prototype.getSize = function () {};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
_ol_style_Image_.prototype.setOpacity = function (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */
_ol_style_Image_.prototype.setRotateWithView = function (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
_ol_style_Image_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};

/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
_ol_style_Image_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};

/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */
_ol_style_Image_.prototype.setSnapToPixel = function (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */
_ol_style_Image_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * Load not yet loaded URI.
 * @abstract
 */
_ol_style_Image_.prototype.load = function () {};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
_ol_style_Image_.prototype.unlistenImageChange = function (listener, thisArg) {};
exports.default = _ol_style_Image_;


},{}],37:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _colorlike = require('../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _has = require('../has');

var _has2 = _interopRequireDefault(_has);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _canvas = require('../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _image = require('../style/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */
var _ol_style_RegularShape_ = function (options) {
  /**
   * @private
   * @type {Array.<string>}
   */
  this.checksums_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.hitDetectionCanvas_ = null;

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.origin_ = [0, 0];

  /**
   * @private
   * @type {number}
   */
  this.points_ = options.points;

  /**
   * @protected
   * @type {number}
   */
  this.radius_ = /** @type {number} */options.radius !== undefined ? options.radius : options.radius1;

  /**
   * @private
   * @type {number}
   */
  this.radius2_ = options.radius2 !== undefined ? options.radius2 : this.radius_;

  /**
   * @private
   * @type {number}
   */
  this.angle_ = options.angle !== undefined ? options.angle : 0;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.imageSize_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.hitDetectionImageSize_ = null;

  /**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */
  this.atlasManager_ = options.atlasManager;

  this.render_(this.atlasManager_);

  /**
   * @type {boolean}
   */
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  /**
   * @type {boolean}
   */
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  _image2.default.call(this, {
    opacity: 1,
    rotateWithView: rotateWithView,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: 1,
    snapToPixel: snapToPixel
  });
};

_index2.default.inherits(_ol_style_RegularShape_, _image2.default);

/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */
_ol_style_RegularShape_.prototype.clone = function () {
  var style = new _ol_style_RegularShape_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    points: this.getRadius2() !== this.getRadius() ? this.getPoints() / 2 : this.getPoints(),
    radius: this.getRadius(),
    radius2: this.getRadius2(),
    angle: this.getAngle(),
    snapToPixel: this.getSnapToPixel(),
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getAnchor = function () {
  return this.anchor_;
};

/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */
_ol_style_RegularShape_.prototype.getAngle = function () {
  return this.angle_;
};

/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_RegularShape_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.hitDetectionCanvas_;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getImageSize = function () {
  return this.imageSize_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getHitDetectionImageSize = function () {
  return this.hitDetectionImageSize_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getImageState = function () {
  return _imagestate2.default.LOADED;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getOrigin = function () {
  return this.origin_;
};

/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */
_ol_style_RegularShape_.prototype.getPoints = function () {
  return this.points_;
};

/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */
_ol_style_RegularShape_.prototype.getRadius = function () {
  return this.radius_;
};

/**
 * Get the secondary radius for the shape.
 * @return {number} Radius2.
 * @api
 */
_ol_style_RegularShape_.prototype.getRadius2 = function () {
  return this.radius2_;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getSize = function () {
  return this.size_;
};

/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_RegularShape_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.load = function () {};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.unlistenImageChange = function (listener, thisArg) {};

/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */
_ol_style_RegularShape_.prototype.render_ = function (atlasManager) {
  var imageSize;
  var lineCap = '';
  var lineJoin = '';
  var miterLimit = 0;
  var lineDash = null;
  var strokeStyle;
  var strokeWidth = 0;

  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();
    if (strokeStyle === null) {
      strokeStyle = _canvas2.default.defaultStrokeStyle;
    }
    strokeStyle = _colorlike2.default.asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();
    if (strokeWidth === undefined) {
      strokeWidth = _canvas2.default.defaultLineWidth;
    }
    lineDash = this.stroke_.getLineDash();
    if (!_has2.default.CANVAS_LINE_DASH) {
      lineDash = null;
    }
    lineJoin = this.stroke_.getLineJoin();
    if (lineJoin === undefined) {
      lineJoin = _canvas2.default.defaultLineJoin;
    }
    lineCap = this.stroke_.getLineCap();
    if (lineCap === undefined) {
      lineCap = _canvas2.default.defaultLineCap;
    }
    miterLimit = this.stroke_.getMiterLimit();
    if (miterLimit === undefined) {
      miterLimit = _canvas2.default.defaultMiterLimit;
    }
  }

  var size = 2 * (this.radius_ + strokeWidth) + 1;

  /** @type {ol.RegularShapeRenderOptions} */
  var renderOptions = {
    strokeStyle: strokeStyle,
    strokeWidth: strokeWidth,
    size: size,
    lineCap: lineCap,
    lineDash: lineDash,
    lineJoin: lineJoin,
    miterLimit: miterLimit
  };

  if (atlasManager === undefined) {
    // no atlas manager is used, create a new canvas
    var context = _dom2.default.createCanvasContext2D(size, size);
    this.canvas_ = context.canvas;

    // canvas.width and height are rounded to the closest integer
    size = this.canvas_.width;
    imageSize = size;

    this.draw_(renderOptions, context, 0, 0);

    this.createHitDetectionCanvas_(renderOptions);
  } else {
    // an atlas manager is used, add the symbol to an atlas
    size = Math.round(size);

    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;
    if (hasCustomHitDetectionImage) {
      // render the hit-detection image into a separate atlas image
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }

    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);

    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;

    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }

  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
_ol_style_RegularShape_.prototype.draw_ = function (renderOptions, context, x, y) {
  var this$1 = this;

  var i, angle0, radiusC;
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  if (this.points_ === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    if (this.radius2_ !== this.radius_) {
      this.points_ = 2 * this.points_;
    }
    for (i = 0; i <= this.points_; i++) {
      angle0 = i * 2 * Math.PI / this$1.points_ - Math.PI / 2 + this$1.angle_;
      radiusC = i % 2 === 0 ? this$1.radius_ : this$1.radius2_;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  if (this.fill_) {
    var color = this.fill_.getColor();
    if (color === null) {
      color = _canvas2.default.defaultFillStyle;
    }
    context.fillStyle = _colorlike2.default.asColorLike(color);
    context.fill();
  }
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
    }
    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }
  context.closePath();
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */
_ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function (renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  }

  // if no fill style is set, create an extra hit-detection image with a
  // default fill style
  var context = _dom2.default.createCanvasContext2D(renderOptions.size, renderOptions.size);
  this.hitDetectionCanvas_ = context.canvas;

  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
  var this$1 = this;

  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  if (this.points_ === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    if (this.radius2_ !== this.radius_) {
      this.points_ = 2 * this.points_;
    }
    var i, radiusC, angle0;
    for (i = 0; i <= this.points_; i++) {
      angle0 = i * 2 * Math.PI / this$1.points_ - Math.PI / 2 + this$1.angle_;
      radiusC = i % 2 === 0 ? this$1.radius_ : this$1.radius2_;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  context.fillStyle = _canvas2.default.defaultFillStyle;
  context.fill();
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
    }
    context.stroke();
  }
  context.closePath();
};

/**
 * @return {string} The checksum.
 */
_ol_style_RegularShape_.prototype.getChecksum = function () {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';

  var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];

  if (recalculate) {
    var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }

  return this.checksums_[0];
};
exports.default = _ol_style_RegularShape_;


},{"../colorlike":14,"../dom":16,"../has":22,"../imagestate":23,"../index":24,"../render/canvas":27,"../style/image":36}],38:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */
var _ol_style_Stroke_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */
_ol_style_Stroke_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Stroke_({
    color: color && color.slice ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Stroke_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.getLineCap = function () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDash = function () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDashOffset = function () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
_ol_style_Stroke_.prototype.getLineJoin = function () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.getMiterLimit = function () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
_ol_style_Stroke_.prototype.getWidth = function () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Stroke_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.setLineCap = function (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDash = function (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDashOffset = function (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
_ol_style_Stroke_.prototype.setLineJoin = function (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.setMiterLimit = function (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
_ol_style_Stroke_.prototype.setWidth = function (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Stroke_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += _index2.default.getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');
  }

  return this.checksum_;
};
exports.default = _ol_style_Stroke_;


},{"../index":24}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _circle = require('../style/circle');

var _circle2 = _interopRequireDefault(_circle);

var _fill = require('../style/fill');

var _fill2 = _interopRequireDefault(_fill);

var _stroke = require('../style/stroke');

var _stroke2 = _interopRequireDefault(_stroke);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */
var _ol_style_Style_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */
  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {ol.style.Image}
   */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {ol.style.Text}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;
};

/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */
_ol_style_Style_.prototype.clone = function () {
  var geometry = this.getGeometry();
  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }
  return new _ol_style_Style_({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
_ol_style_Style_.prototype.getGeometry = function () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
_ol_style_Style_.prototype.getGeometryFunction = function () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_Style_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */
_ol_style_Style_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */
_ol_style_Style_.prototype.getImage = function () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */
_ol_style_Style_.prototype.setImage = function (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_Style_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */
_ol_style_Style_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */
_ol_style_Style_.prototype.getText = function () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */
_ol_style_Style_.prototype.setText = function (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
_ol_style_Style_.prototype.getZIndex = function () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */
_ol_style_Style_.prototype.setGeometry = function (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function (feature) {
      return (/** @type {ol.geom.Geometry} */feature.get(geometry)
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function () {
      return (/** @type {ol.geom.Geometry} */geometry
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
_ol_style_Style_.prototype.setZIndex = function (zIndex) {
  this.zIndex_ = zIndex;
};

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */
_ol_style_Style_.createFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts2.default.assert(obj instanceof _ol_style_Style_, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`
      styles = [obj];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
};

/**
 * @type {Array.<ol.style.Style>}
 * @private
 */
_ol_style_Style_.default_ = null;

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */
_ol_style_Style_.defaultFunction = function (feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (ol.style.Circle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!_ol_style_Style_.default_) {
    var fill = new _fill2.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _stroke2.default({
      color: '#3399CC',
      width: 1.25
    });
    _ol_style_Style_.default_ = [new _ol_style_Style_({
      image: new _circle2.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }
  return _ol_style_Style_.default_;
};

/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */
_ol_style_Style_.createDefaultEditing = function () {
  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geometrytype2.default.POLYGON] = [new _ol_style_Style_({
    fill: new _fill2.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_geometrytype2.default.MULTI_POLYGON] = styles[_geometrytype2.default.POLYGON];

  styles[_geometrytype2.default.LINE_STRING] = [new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: white,
      width: width + 2
    })
  }), new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: blue,
      width: width
    })
  })];
  styles[_geometrytype2.default.MULTI_LINE_STRING] = styles[_geometrytype2.default.LINE_STRING];

  styles[_geometrytype2.default.CIRCLE] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING]);

  styles[_geometrytype2.default.POINT] = [new _ol_style_Style_({
    image: new _circle2.default({
      radius: width * 2,
      fill: new _fill2.default({
        color: blue
      }),
      stroke: new _stroke2.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_geometrytype2.default.MULTI_POINT] = styles[_geometrytype2.default.POINT];

  styles[_geometrytype2.default.GEOMETRY_COLLECTION] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING], styles[_geometrytype2.default.POINT]);

  return styles;
};

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */
_ol_style_Style_.defaultGeometryFunction = function (feature) {
  return feature.getGeometry();
};
exports.default = _ol_style_Style_;


},{"../asserts":12,"../geom/geometrytype":21,"../style/circle":29,"../style/fill":30,"../style/stroke":38}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _fill = require('../style/fill');

var _fill2 = _interopRequireDefault(_fill);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set text style for vector features.
 *
 * @constructor
 * @param {olx.style.TextOptions=} opt_options Options.
 * @api
 */
var _ol_style_Text_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|undefined}
   */
  this.font_ = options.font;

  /**
   * @private
   * @type {number|undefined}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number|undefined}
   */
  this.scale_ = options.scale;

  /**
   * @private
   * @type {string|undefined}
   */
  this.text_ = options.text;

  /**
   * @private
   * @type {string|undefined}
   */
  this.textAlign_ = options.textAlign;

  /**
   * @private
   * @type {string|undefined}
   */
  this.textBaseline_ = options.textBaseline;

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : new _fill2.default({ color: _ol_style_Text_.DEFAULT_FILL_COLOR_ });

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {number}
   */
  this.offsetX_ = options.offsetX !== undefined ? options.offsetX : 0;

  /**
   * @private
   * @type {number}
   */
  this.offsetY_ = options.offsetY !== undefined ? options.offsetY : 0;
};

/**
 * The default fill color to use if no fill was set at construction time; a
 * blackish `#333`.
 *
 * @const {string}
 * @private
 */
_ol_style_Text_.DEFAULT_FILL_COLOR_ = '#333';

/**
 * Clones the style.
 * @return {ol.style.Text} The cloned style.
 * @api
 */
_ol_style_Text_.prototype.clone = function () {
  return new _ol_style_Text_({
    font: this.getFont(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    scale: this.getScale(),
    text: this.getText(),
    textAlign: this.getTextAlign(),
    textBaseline: this.getTextBaseline(),
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    offsetX: this.getOffsetX(),
    offsetY: this.getOffsetY()
  });
};

/**
 * Get the font name.
 * @return {string|undefined} Font.
 * @api
 */
_ol_style_Text_.prototype.getFont = function () {
  return this.font_;
};

/**
 * Get the x-offset for the text.
 * @return {number} Horizontal text offset.
 * @api
 */
_ol_style_Text_.prototype.getOffsetX = function () {
  return this.offsetX_;
};

/**
 * Get the y-offset for the text.
 * @return {number} Vertical text offset.
 * @api
 */
_ol_style_Text_.prototype.getOffsetY = function () {
  return this.offsetY_;
};

/**
 * Get the fill style for the text.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_Text_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * Determine whether the text rotates with the map.
 * @return {boolean|undefined} Rotate with map.
 * @api
 */
_ol_style_Text_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};

/**
 * Get the text rotation.
 * @return {number|undefined} Rotation.
 * @api
 */
_ol_style_Text_.prototype.getRotation = function () {
  return this.rotation_;
};

/**
 * Get the text scale.
 * @return {number|undefined} Scale.
 * @api
 */
_ol_style_Text_.prototype.getScale = function () {
  return this.scale_;
};

/**
 * Get the stroke style for the text.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_Text_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * Get the text to be rendered.
 * @return {string|undefined} Text.
 * @api
 */
_ol_style_Text_.prototype.getText = function () {
  return this.text_;
};

/**
 * Get the text alignment.
 * @return {string|undefined} Text align.
 * @api
 */
_ol_style_Text_.prototype.getTextAlign = function () {
  return this.textAlign_;
};

/**
 * Get the text baseline.
 * @return {string|undefined} Text baseline.
 * @api
 */
_ol_style_Text_.prototype.getTextBaseline = function () {
  return this.textBaseline_;
};

/**
 * Set the font.
 *
 * @param {string|undefined} font Font.
 * @api
 */
_ol_style_Text_.prototype.setFont = function (font) {
  this.font_ = font;
};

/**
 * Set the x offset.
 *
 * @param {number} offsetX Horizontal text offset.
 * @api
 */
_ol_style_Text_.prototype.setOffsetX = function (offsetX) {
  this.offsetX_ = offsetX;
};

/**
 * Set the y offset.
 *
 * @param {number} offsetY Vertical text offset.
 * @api
 */
_ol_style_Text_.prototype.setOffsetY = function (offsetY) {
  this.offsetY_ = offsetY;
};

/**
 * Set the fill.
 *
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */
_ol_style_Text_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};

/**
 * Set the rotation.
 *
 * @param {number|undefined} rotation Rotation.
 * @api
 */
_ol_style_Text_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};

/**
 * Set the scale.
 *
 * @param {number|undefined} scale Scale.
 * @api
 */
_ol_style_Text_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};

/**
 * Set the stroke.
 *
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */
_ol_style_Text_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};

/**
 * Set the text.
 *
 * @param {string|undefined} text Text.
 * @api
 */
_ol_style_Text_.prototype.setText = function (text) {
  this.text_ = text;
};

/**
 * Set the text alignment.
 *
 * @param {string|undefined} textAlign Text align.
 * @api
 */
_ol_style_Text_.prototype.setTextAlign = function (textAlign) {
  this.textAlign_ = textAlign;
};

/**
 * Set the text baseline.
 *
 * @param {string|undefined} textBaseline Text baseline.
 * @api
 */
_ol_style_Text_.prototype.setTextBaseline = function (textBaseline) {
  this.textBaseline_ = textBaseline;
};
exports.default = _ol_style_Text_;


},{"../style/fill":30}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_webgl_ = {};

if (false) {

  /** Constants taken from goog.webgl
   */

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ONE = 1;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.SRC_ALPHA = 0x0302;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TRIANGLES = 0x0004;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TRIANGLE_STRIP = 0x0005;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ARRAY_BUFFER = 0x8892;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STREAM_DRAW = 0x88E0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STATIC_DRAW = 0x88E4;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.DYNAMIC_DRAW = 0x88E8;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.CULL_FACE = 0x0B44;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.BLEND = 0x0BE2;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STENCIL_TEST = 0x0B90;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.DEPTH_TEST = 0x0B71;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.SCISSOR_TEST = 0x0C11;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_BYTE = 0x1401;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_SHORT = 0x1403;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_INT = 0x1405;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FLOAT = 0x1406;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.RGBA = 0x1908;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FRAGMENT_SHADER = 0x8B30;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.VERTEX_SHADER = 0x8B31;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.LINK_STATUS = 0x8B82;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.LINEAR = 0x2601;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_WRAP_S = 0x2802;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_WRAP_T = 0x2803;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_2D = 0x0DE1;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE0 = 0x84C0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.CLAMP_TO_EDGE = 0x812F;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COMPILE_STATUS = 0x8B81;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FRAMEBUFFER = 0x8D40;

  /** end of goog.webgl constants
   */

  /**
   * @const
   * @private
   * @type {Array.<string>}
   */
  _ol_webgl_.CONTEXT_IDS_ = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

  /**
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Object=} opt_attributes Attributes.
   * @return {WebGLRenderingContext} WebGL rendering context.
   */
  _ol_webgl_.getContext = function (canvas, opt_attributes) {
    var context,
        i,
        ii = _ol_webgl_.CONTEXT_IDS_.length;
    for (i = 0; i < ii; ++i) {
      try {
        context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);
        if (context) {
          return (/** @type {!WebGLRenderingContext} */context
          );
        }
      } catch (e) {
        // pass
      }
    }
    return null;
  };
}
exports.default = _ol_webgl_;


},{"./index":24}],42:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_array_ = {};

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
_ol_array_.binarySearch = function (haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || _ol_array_.numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
};

/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
_ol_array_.numberSafeCompareFunction = function (a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};

/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
_ol_array_.includes = function (arr, obj) {
  return arr.indexOf(obj) >= 0;
};

/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
_ol_array_.linearFindNearest = function (arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
};

/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
_ol_array_.reverseSubArray = function (arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
};

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements
 *     to add to arr.
 * @template VALUE
 */
_ol_array_.extend = function (arr, data) {
  var i;
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
};

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
_ol_array_.remove = function (arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
};

/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE} The element found.
 */
_ol_array_.find = function (arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
};

/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
_ol_array_.equals = function (arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */
_ol_array_.stableSort = function (arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
};

/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
_ol_array_.findIndex = function (arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
};

/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
_ol_array_.isSorted = function (arr, opt_func, opt_strict) {
  var compare = opt_func || _ol_array_.numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
};
exports.default = _ol_array_;


},{}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */
var _ol_AssertionError_ = function (code) {

  var path = _index2.default.VERSION ? _index2.default.VERSION.split('-')[0] : 'latest';

  /**
   * @type {string}
   */
  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';

  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */
  this.code = code;

  this.name = 'AssertionError';
};

_index2.default.inherits(_ol_AssertionError_, Error);
exports.default = _ol_AssertionError_;


},{"./index":110}],44:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _assertionerror = require('./assertionerror');

var _assertionerror2 = _interopRequireDefault(_assertionerror);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_asserts_ = {};

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
_ol_asserts_.assert = function (assertion, errorCode) {
  if (!assertion) {
    throw new _assertionerror2.default(errorCode);
  }
};
exports.default = _ol_asserts_;


},{"./assertionerror":43}],45:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tilerange = require('./tilerange');

var _tilerange2 = _interopRequireDefault(_tilerange);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

var _tilegrid = require('./tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * An attribution for a layer source.
 *
 * Example:
 *
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="https://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 *
 * @constructor
 * @param {olx.AttributionOptions} options Attribution options.
 * @struct
 * @api
 */
var _ol_Attribution_ = function (options) {

  /**
   * @private
   * @type {string}
   */
  this.html_ = options.html;

  /**
   * @private
   * @type {Object.<string, Array.<ol.TileRange>>}
   */
  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;
};

/**
 * Get the attribution markup.
 * @return {string} The attribution HTML.
 * @api
 */
_ol_Attribution_.prototype.getHTML = function () {
  return this.html_;
};

/**
 * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {boolean} Intersects any tile range.
 */
_ol_Attribution_.prototype.intersectsAnyTileRange = function (tileRanges, tileGrid, projection) {
  var this$1 = this;

  if (!this.tileRanges_) {
    return true;
  }
  var i, ii, tileRange, zKey;
  for (zKey in tileRanges) {
    if (!(zKey in this$1.tileRanges_)) {
      continue;
    }
    tileRange = tileRanges[zKey];
    var testTileRange;
    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {
      testTileRange = this$1.tileRanges_[zKey][i];
      if (testTileRange.intersects(tileRange)) {
        return true;
      }
      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(_tilegrid2.default.extentFromProjection(projection), parseInt(zKey, 10));
      var width = extentTileRange.getWidth();
      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {
        if (testTileRange.intersects(new _tilerange2.default(_math2.default.modulo(tileRange.minX, width), _math2.default.modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {
          return true;
        }
        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {
          return true;
        }
      }
    }
  }
  return false;
};
exports.default = _ol_Attribution_;


},{"./math":144,"./tilegrid":248,"./tilerange":251}],46:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_CenterConstraint_ = {};

/**
 * @param {ol.Extent} extent Extent.
 * @return {ol.CenterConstraintType} The constraint.
 */
_ol_CenterConstraint_.createExtent = function (extent) {
  return (
    /**
     * @param {ol.Coordinate|undefined} center Center.
     * @return {ol.Coordinate|undefined} Center.
     */
    function (center) {
      if (center) {
        return [_math2.default.clamp(center[0], extent[0], extent[2]), _math2.default.clamp(center[1], extent[1], extent[3])];
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Center.
 */
_ol_CenterConstraint_.none = function (center) {
  return center;
};
exports.default = _ol_CenterConstraint_;


},{"./math":144}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _assertionerror = require('./assertionerror');

var _assertionerror2 = _interopRequireDefault(_assertionerror);

var _collectioneventtype = require('./collectioneventtype');

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _object = require('./object');

var _object2 = _interopRequireDefault(_object);

var _event = require('./events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @constructor
 * @extends {ol.Object}
 * @fires ol.Collection.Event
 * @param {!Array.<T>=} opt_array Array.
 * @param {olx.CollectionOptions=} opt_options Collection options.
 * @template T
 * @api
 */
var _ol_Collection_ = function (opt_array, opt_options) {
  var this$1 = this;


  _object2.default.call(this);

  var options = opt_options || {};

  /**
   * @private
   * @type {boolean}
   */
  this.unique_ = !!options.unique;

  /**
   * @private
   * @type {!Array.<T>}
   */
  this.array_ = opt_array ? opt_array : [];

  if (this.unique_) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      this$1.assertUnique_(this$1.array_[i], i);
    }
  }

  this.updateLength_();
}; /**
    * An implementation of Google Maps' MVCArray.
    * @see https://developers.google.com/maps/documentation/javascript/reference
    */

_index2.default.inherits(_ol_Collection_, _object2.default);

/**
 * Remove all elements from the collection.
 * @api
 */
_ol_Collection_.prototype.clear = function () {
  var this$1 = this;

  while (this.getLength() > 0) {
    this$1.pop();
  }
};

/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * @param {!Array.<T>} arr Array.
 * @return {ol.Collection.<T>} This collection.
 * @api
 */
_ol_Collection_.prototype.extend = function (arr) {
  var this$1 = this;

  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    this$1.push(arr[i]);
  }
  return this;
};

/**
 * Iterate over each element, calling the provided callback.
 * @param {function(this: S, T, number, Array.<T>): *} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 * @api
 */
_ol_Collection_.prototype.forEach = function (f, opt_this) {
  this.array_.forEach(f, opt_this);
};

/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * @return {!Array.<T>} Array.
 * @api
 */
_ol_Collection_.prototype.getArray = function () {
  return this.array_;
};

/**
 * Get the element at the provided index.
 * @param {number} index Index.
 * @return {T} Element.
 * @api
 */
_ol_Collection_.prototype.item = function (index) {
  return this.array_[index];
};

/**
 * Get the length of this collection.
 * @return {number} The length of the array.
 * @observable
 * @api
 */
_ol_Collection_.prototype.getLength = function () {
  return (/** @type {number} */this.get(_ol_Collection_.Property_.LENGTH)
  );
};

/**
 * Insert an element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */
_ol_Collection_.prototype.insertAt = function (index, elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  this.array_.splice(index, 0, elem);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.ADD, elem));
};

/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * @return {T|undefined} Element.
 * @api
 */
_ol_Collection_.prototype.pop = function () {
  return this.removeAt(this.getLength() - 1);
};

/**
 * Insert the provided element at the end of the collection.
 * @param {T} elem Element.
 * @return {number} New length of the collection.
 * @api
 */
_ol_Collection_.prototype.push = function (elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  var n = this.getLength();
  this.insertAt(n, elem);
  return this.getLength();
};

/**
 * Remove the first occurrence of an element from the collection.
 * @param {T} elem Element.
 * @return {T|undefined} The removed element or undefined if none found.
 * @api
 */
_ol_Collection_.prototype.remove = function (elem) {
  var this$1 = this;

  var arr = this.array_;
  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    if (arr[i] === elem) {
      return this$1.removeAt(i);
    }
  }
  return undefined;
};

/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * @param {number} index Index.
 * @return {T|undefined} Value.
 * @api
 */
_ol_Collection_.prototype.removeAt = function (index) {
  var prev = this.array_[index];
  this.array_.splice(index, 1);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.REMOVE, prev));
  return prev;
};

/**
 * Set the element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */
_ol_Collection_.prototype.setAt = function (index, elem) {
  var this$1 = this;

  var n = this.getLength();
  if (index < n) {
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    var prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.REMOVE, prev));
    this.dispatchEvent(new _ol_Collection_.Event(_collectioneventtype2.default.ADD, elem));
  } else {
    var j;
    for (j = n; j < index; ++j) {
      this$1.insertAt(j, undefined);
    }
    this.insertAt(index, elem);
  }
};

/**
 * @private
 */
_ol_Collection_.prototype.updateLength_ = function () {
  this.set(_ol_Collection_.Property_.LENGTH, this.array_.length);
};

/**
 * @private
 * @param {T} elem Element.
 * @param {number=} opt_except Optional index to ignore.
 */
_ol_Collection_.prototype.assertUnique_ = function (elem, opt_except) {
  var this$1 = this;

  for (var i = 0, ii = this.array_.length; i < ii; ++i) {
    if (this$1.array_[i] === elem && i !== opt_except) {
      throw new _assertionerror2.default(58);
    }
  }
};

/**
 * @enum {string}
 * @private
 */
_ol_Collection_.Property_ = {
  LENGTH: 'length'
};

/**
 * @classdesc
 * Events emitted by {@link ol.Collection} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.Collection.Event}
 * @param {ol.CollectionEventType} type Type.
 * @param {*=} opt_element Element.
 */
_ol_Collection_.Event = function (type, opt_element) {

  _event2.default.call(this, type);

  /**
   * The element that is added to or removed from the collection.
   * @type {*}
   * @api
   */
  this.element = opt_element;
};
_index2.default.inherits(_ol_Collection_.Event, _event2.default);
exports.default = _ol_Collection_;


},{"./assertionerror":43,"./collectioneventtype":48,"./events/event":64,"./index":110,"./object":147}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_CollectionEventType_ = {
  /**
   * Triggered when an item is added to the collection.
   * @event ol.Collection.Event#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event ol.Collection.Event#remove
   * @api
   */
  REMOVE: 'remove'
};

exports.default = _ol_CollectionEventType_;


},{}],49:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_color_ = {};

/**
 * This RegExp matches # followed by 3 or 6 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3}){1,2}$/i;

/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */
_ol_color_.asArray = function (color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return _ol_color_.fromString( /** @type {string} */color);
  }
};

/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
_ol_color_.asString = function (color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return _ol_color_.toString(color);
  }
};

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
_ol_color_.fromNamed = function (color) {
  var el = document.createElement('div');
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};

/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */
_ol_color_.fromString = function () {

  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;

  /**
   * @type {Object.<string, ol.Color>}
   */
  var cache = {};

  /**
   * @type {number}
   */
  var cacheSize = 0;

  return (
    /**
     * @param {string} s String.
     * @return {ol.Color} Color.
     */
    function (s) {
      var color;
      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          var key;
          for (key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }
        color = _ol_color_.fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }
      return color;
    }
  );
}();

/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */
_ol_color_.fromStringInternal_ = function (s) {
  var r, g, b, a, color, parts;

  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {
    s = _ol_color_.fromNamed(s);
  }

  if (_ol_color_.HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits
    _asserts2.default.assert(n == 3 || n == 6, 54); // Hex color should have 3 or 6 digits
    var d = n == 3 ? 1 : 2; // number of digits per channel
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
    }
    a = 1;
    color = [r, g, b, a];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    parts = s.slice(5, -1).split(',').map(Number);
    color = _ol_color_.normalize(parts);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    parts = s.slice(4, -1).split(',').map(Number);
    parts.push(1);
    color = _ol_color_.normalize(parts);
  } else {
    _asserts2.default.assert(false, 14); // Invalid color
  }
  return (/** @type {ol.Color} */color
  );
};

/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */
_ol_color_.normalize = function (color, opt_color) {
  var result = opt_color || [];
  result[0] = _math2.default.clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = _math2.default.clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = _math2.default.clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = _math2.default.clamp(color[3], 0, 1);
  return result;
};

/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */
_ol_color_.toString = function (color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
};
exports.default = _ol_color_;


},{"./asserts":44,"./math":144}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require('./color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_colorlike_ = {};

/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */
_ol_colorlike_.asColorLike = function (color) {
  if (_ol_colorlike_.isColorLike(color)) {
    return (/** @type {string|CanvasPattern|CanvasGradient} */color
    );
  } else {
    return _color2.default.asString( /** @type {ol.Color} */color);
  }
};

/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */
_ol_colorlike_.isColorLike = function (color) {
  return typeof color === 'string' || color instanceof CanvasPattern || color instanceof CanvasGradient;
};
exports.default = _ol_colorlike_;


},{"./color":49}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @constructor
 * @param {ol.CenterConstraintType} centerConstraint Center constraint.
 * @param {ol.ResolutionConstraintType} resolutionConstraint
 *     Resolution constraint.
 * @param {ol.RotationConstraintType} rotationConstraint
 *     Rotation constraint.
 */
var _ol_Constraints_ = function (centerConstraint, resolutionConstraint, rotationConstraint) {

  /**
   * @type {ol.CenterConstraintType}
   */
  this.center = centerConstraint;

  /**
   * @type {ol.ResolutionConstraintType}
   */
  this.resolution = resolutionConstraint;

  /**
   * @type {ol.RotationConstraintType}
   */
  this.rotation = rotationConstraint;
};

exports.default = _ol_Constraints_;


},{}],52:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _attribution = require('./control/attribution');

var _attribution2 = _interopRequireDefault(_attribution);

var _rotate = require('./control/rotate');

var _rotate2 = _interopRequireDefault(_rotate);

var _zoom = require('./control/zoom');

var _zoom2 = _interopRequireDefault(_zoom);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_control_ = {};

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link ol.control.Zoom}
 * * {@link ol.control.Rotate}
 * * {@link ol.control.Attribution}
 *
 * @param {olx.control.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */
_ol_control_.defaults = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var controls = new _collection2.default();

  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new _zoom2.default(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new _rotate2.default(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new _attribution2.default(options.attributionOptions));
  }

  return controls;
};
exports.default = _ol_control_;


},{"./collection":47,"./control/attribution":53,"./control/rotate":55,"./control/zoom":56}],53:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _control = require('../control/control');

var _control2 = _interopRequireDefault(_control);

var _css = require('../css');

var _css2 = _interopRequireDefault(_css);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.AttributionOptions=} opt_options Attribution options.
 * @api
 */
var _ol_control_Attribution_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {Element}
   */
  this.ulElement_ = document.createElement('UL');

  /**
   * @private
   * @type {Element}
   */
  this.logoLi_ = document.createElement('LI');

  this.ulElement_.appendChild(this.logoLi_);
  this.logoLi_.style.display = 'none';

  /**
   * @private
   * @type {boolean}
   */
  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

  /**
   * @private
   * @type {boolean}
   */
  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

  if (!this.collapsible_) {
    this.collapsed_ = false;
  }

  var className = options.className !== undefined ? options.className : 'ol-attribution';

  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';

  if (typeof collapseLabel === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.collapseLabel_ = document.createElement('span');
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }

  var label = options.label !== undefined ? options.label : 'i';

  if (typeof label === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.label_ = document.createElement('span');
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }

  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement('button');
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(activeLabel);

  _events2.default.listen(button, _eventtype2.default.CLICK, this.handleClick_, this);

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(this.ulElement_);
  element.appendChild(button);

  var render = options.render ? options.render : _ol_control_Attribution_.render;

  _control2.default.call(this, {
    element: element,
    render: render,
    target: options.target
  });

  /**
   * @private
   * @type {boolean}
   */
  this.renderedVisible_ = true;

  /**
   * @private
   * @type {Object.<string, Element>}
   */
  this.attributionElements_ = {};

  /**
   * @private
   * @type {Object.<string, boolean>}
   */
  this.attributionElementRenderedVisible_ = {};

  /**
   * @private
   * @type {Object.<string, Element>}
   */
  this.logoElements_ = {};
}; // FIXME handle date line wrap

_index2.default.inherits(_ol_control_Attribution_, _control2.default);

/**
 * @param {?olx.FrameState} frameState Frame state.
 * @return {Array.<Object.<string, ol.Attribution>>} Attributions.
 */
_ol_control_Attribution_.prototype.getSourceAttributions = function (frameState) {
  var i, ii, j, jj, tileRanges, source, sourceAttribution, sourceAttributionKey, sourceAttributions, sourceKey;
  var intersectsTileRange;
  var layerStatesArray = frameState.layerStatesArray;
  /** @type {Object.<string, ol.Attribution>} */
  var attributions = _obj2.default.assign({}, frameState.attributions);
  /** @type {Object.<string, ol.Attribution>} */
  var hiddenAttributions = {};
  var uniqueAttributions = {};
  var projection = /** @type {!ol.proj.Projection} */frameState.viewState.projection;
  for (i = 0, ii = layerStatesArray.length; i < ii; i++) {
    source = layerStatesArray[i].layer.getSource();
    if (!source) {
      continue;
    }
    sourceKey = _index2.default.getUid(source).toString();
    sourceAttributions = source.getAttributions();
    if (!sourceAttributions) {
      continue;
    }
    for (j = 0, jj = sourceAttributions.length; j < jj; j++) {
      sourceAttribution = sourceAttributions[j];
      sourceAttributionKey = _index2.default.getUid(sourceAttribution).toString();
      if (sourceAttributionKey in attributions) {
        continue;
      }
      tileRanges = frameState.usedTiles[sourceKey];
      if (tileRanges) {
        var tileGrid = /** @type {ol.source.Tile} */source.getTileGridForProjection(projection);
        intersectsTileRange = sourceAttribution.intersectsAnyTileRange(tileRanges, tileGrid, projection);
      } else {
        intersectsTileRange = false;
      }
      if (intersectsTileRange) {
        if (sourceAttributionKey in hiddenAttributions) {
          delete hiddenAttributions[sourceAttributionKey];
        }
        var html = sourceAttribution.getHTML();
        if (!(html in uniqueAttributions)) {
          uniqueAttributions[html] = true;
          attributions[sourceAttributionKey] = sourceAttribution;
        }
      } else {
        hiddenAttributions[sourceAttributionKey] = sourceAttribution;
      }
    }
  }
  return [attributions, hiddenAttributions];
};

/**
 * Update the attribution element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Attribution}
 * @api
 */
_ol_control_Attribution_.render = function (mapEvent) {
  this.updateElement_(mapEvent.frameState);
};

/**
 * @private
 * @param {?olx.FrameState} frameState Frame state.
 */
_ol_control_Attribution_.prototype.updateElement_ = function (frameState) {
  var this$1 = this;


  if (!frameState) {
    if (this.renderedVisible_) {
      this.element.style.display = 'none';
      this.renderedVisible_ = false;
    }
    return;
  }

  var attributions = this.getSourceAttributions(frameState);
  /** @type {Object.<string, ol.Attribution>} */
  var visibleAttributions = attributions[0];
  /** @type {Object.<string, ol.Attribution>} */
  var hiddenAttributions = attributions[1];

  var attributionElement, attributionKey;
  for (attributionKey in this$1.attributionElements_) {
    if (attributionKey in visibleAttributions) {
      if (!this$1.attributionElementRenderedVisible_[attributionKey]) {
        this$1.attributionElements_[attributionKey].style.display = '';
        this$1.attributionElementRenderedVisible_[attributionKey] = true;
      }
      delete visibleAttributions[attributionKey];
    } else if (attributionKey in hiddenAttributions) {
      if (this$1.attributionElementRenderedVisible_[attributionKey]) {
        this$1.attributionElements_[attributionKey].style.display = 'none';
        delete this$1.attributionElementRenderedVisible_[attributionKey];
      }
      delete hiddenAttributions[attributionKey];
    } else {
      _dom2.default.removeNode(this$1.attributionElements_[attributionKey]);
      delete this$1.attributionElements_[attributionKey];
      delete this$1.attributionElementRenderedVisible_[attributionKey];
    }
  }
  for (attributionKey in visibleAttributions) {
    attributionElement = document.createElement('LI');
    attributionElement.innerHTML = visibleAttributions[attributionKey].getHTML();
    this$1.ulElement_.appendChild(attributionElement);
    this$1.attributionElements_[attributionKey] = attributionElement;
    this$1.attributionElementRenderedVisible_[attributionKey] = true;
  }
  for (attributionKey in hiddenAttributions) {
    attributionElement = document.createElement('LI');
    attributionElement.innerHTML = hiddenAttributions[attributionKey].getHTML();
    attributionElement.style.display = 'none';
    this$1.ulElement_.appendChild(attributionElement);
    this$1.attributionElements_[attributionKey] = attributionElement;
  }

  var renderVisible = !_obj2.default.isEmpty(this.attributionElementRenderedVisible_) || !_obj2.default.isEmpty(frameState.logos);
  if (this.renderedVisible_ != renderVisible) {
    this.element.style.display = renderVisible ? '' : 'none';
    this.renderedVisible_ = renderVisible;
  }
  if (renderVisible && _obj2.default.isEmpty(this.attributionElementRenderedVisible_)) {
    this.element.classList.add('ol-logo-only');
  } else {
    this.element.classList.remove('ol-logo-only');
  }

  this.insertLogos_(frameState);
};

/**
 * @param {?olx.FrameState} frameState Frame state.
 * @private
 */
_ol_control_Attribution_.prototype.insertLogos_ = function (frameState) {
  var this$1 = this;


  var logo;
  var logos = frameState.logos;
  var logoElements = this.logoElements_;

  for (logo in logoElements) {
    if (!(logo in logos)) {
      _dom2.default.removeNode(logoElements[logo]);
      delete logoElements[logo];
    }
  }

  var image, logoElement, logoKey;
  for (logoKey in logos) {
    var logoValue = logos[logoKey];
    if (logoValue instanceof HTMLElement) {
      this$1.logoLi_.appendChild(logoValue);
      logoElements[logoKey] = logoValue;
    }
    if (!(logoKey in logoElements)) {
      image = new Image();
      image.src = logoKey;
      if (logoValue === '') {
        logoElement = image;
      } else {
        logoElement = document.createElement('a');
        logoElement.href = logoValue;
        logoElement.appendChild(image);
      }
      this$1.logoLi_.appendChild(logoElement);
      logoElements[logoKey] = logoElement;
    }
  }

  this.logoLi_.style.display = !_obj2.default.isEmpty(logos) ? '' : 'none';
};

/**
 * @param {Event} event The event to handle
 * @private
 */
_ol_control_Attribution_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  this.handleToggle_();
};

/**
 * @private
 */
_ol_control_Attribution_.prototype.handleToggle_ = function () {
  this.element.classList.toggle('ol-collapsed');
  if (this.collapsed_) {
    _dom2.default.replaceNode(this.collapseLabel_, this.label_);
  } else {
    _dom2.default.replaceNode(this.label_, this.collapseLabel_);
  }
  this.collapsed_ = !this.collapsed_;
};

/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * @return {boolean} True if the widget is collapsible.
 * @api
 */
_ol_control_Attribution_.prototype.getCollapsible = function () {
  return this.collapsible_;
};

/**
 * Set whether the attribution should be collapsible.
 * @param {boolean} collapsible True if the widget is collapsible.
 * @api
 */
_ol_control_Attribution_.prototype.setCollapsible = function (collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }
  this.collapsible_ = collapsible;
  this.element.classList.toggle('ol-uncollapsible');
  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};

/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * @param {boolean} collapsed True if the widget is collapsed.
 * @api
 */
_ol_control_Attribution_.prototype.setCollapsed = function (collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }
  this.handleToggle_();
};

/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * @return {boolean} True if the widget is collapsed.
 * @api
 */
_ol_control_Attribution_.prototype.getCollapsed = function () {
  return this.collapsed_;
};
exports.default = _ol_control_Attribution_;


},{"../control/control":54,"../css":58,"../dom":60,"../events":62,"../events/eventtype":66,"../index":110,"../obj":146}],54:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _mapeventtype = require('../mapeventtype');

var _mapeventtype2 = _interopRequireDefault(_mapeventtype);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @constructor
 * @extends {ol.Object}
 * @implements {oli.control.Control}
 * @param {olx.control.ControlOptions} options Control options.
 * @api
 */
var _ol_control_Control_ = function (options) {

  _object2.default.call(this);

  /**
   * @protected
   * @type {Element}
   */
  this.element = options.element ? options.element : null;

  /**
   * @private
   * @type {Element}
   */
  this.target_ = null;

  /**
   * @private
   * @type {ol.Map}
   */
  this.map_ = null;

  /**
   * @protected
   * @type {!Array.<ol.EventsKey>}
   */
  this.listenerKeys = [];

  /**
   * @type {function(ol.MapEvent)}
   */
  this.render = options.render ? options.render : _index2.default.nullFunction;

  if (options.target) {
    this.setTarget(options.target);
  }
};

_index2.default.inherits(_ol_control_Control_, _object2.default);

/**
 * @inheritDoc
 */
_ol_control_Control_.prototype.disposeInternal = function () {
  _dom2.default.removeNode(this.element);
  _object2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the map associated with this control.
 * @return {ol.Map} Map.
 * @api
 */
_ol_control_Control_.prototype.getMap = function () {
  return this.map_;
};

/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.Map} map Map.
 * @override
 * @api
 */
_ol_control_Control_.prototype.setMap = function (map) {
  var this$1 = this;

  if (this.map_) {
    _dom2.default.removeNode(this.element);
  }
  for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
    _events2.default.unlistenByKey(this$1.listenerKeys[i]);
  }
  this.listenerKeys.length = 0;
  this.map_ = map;
  if (this.map_) {
    var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
    target.appendChild(this.element);
    if (this.render !== _index2.default.nullFunction) {
      this.listenerKeys.push(_events2.default.listen(map, _mapeventtype2.default.POSTRENDER, this.render, this));
    }
    map.render();
  }
};

/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * @param {Element|string} target Target.
 * @api
 */
_ol_control_Control_.prototype.setTarget = function (target) {
  this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
};
exports.default = _ol_control_Control_;


},{"../dom":60,"../events":62,"../index":110,"../mapeventtype":142,"../object":147}],55:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _control = require('../control/control');

var _control2 = _interopRequireDefault(_control);

var _css = require('../css');

var _css2 = _interopRequireDefault(_css);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.RotateOptions=} opt_options Rotate options.
 * @api
 */
var _ol_control_Rotate_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var className = options.className !== undefined ? options.className : 'ol-rotate';

  var label = options.label !== undefined ? options.label : '\u21E7';

  /**
   * @type {Element}
   * @private
   */
  this.label_ = null;

  if (typeof label === 'string') {
    this.label_ = document.createElement('span');
    this.label_.className = 'ol-compass';
    this.label_.textContent = label;
  } else {
    this.label_ = label;
    this.label_.classList.add('ol-compass');
  }

  var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

  var button = document.createElement('button');
  button.className = className + '-reset';
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(this.label_);

  _events2.default.listen(button, _eventtype2.default.CLICK, _ol_control_Rotate_.prototype.handleClick_, this);

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(button);

  var render = options.render ? options.render : _ol_control_Rotate_.render;

  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

  _control2.default.call(this, {
    element: element,
    render: render,
    target: options.target
  });

  /**
   * @type {number}
   * @private
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;

  /**
   * @type {boolean}
   * @private
   */
  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

  /**
   * @private
   * @type {number|undefined}
   */
  this.rotation_ = undefined;

  if (this.autoHide_) {
    this.element.classList.add(_css2.default.CLASS_HIDDEN);
  }
};

_index2.default.inherits(_ol_control_Rotate_, _control2.default);

/**
 * @param {Event} event The event to handle
 * @private
 */
_ol_control_Rotate_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  if (this.callResetNorth_ !== undefined) {
    this.callResetNorth_();
  } else {
    this.resetNorth_();
  }
};

/**
 * @private
 */
_ol_control_Rotate_.prototype.resetNorth_ = function () {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }
  if (view.getRotation() !== undefined) {
    if (this.duration_ > 0) {
      view.animate({
        rotation: 0,
        duration: this.duration_,
        easing: _easing2.default.easeOut
      });
    } else {
      view.setRotation(0);
    }
  }
};

/**
 * Update the rotate control element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Rotate}
 * @api
 */
_ol_control_Rotate_.render = function (mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';
    if (this.autoHide_) {
      var contains = this.element.classList.contains(_css2.default.CLASS_HIDDEN);
      if (!contains && rotation === 0) {
        this.element.classList.add(_css2.default.CLASS_HIDDEN);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(_css2.default.CLASS_HIDDEN);
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
};
exports.default = _ol_control_Rotate_;


},{"../control/control":54,"../css":58,"../easing":61,"../events":62,"../events/eventtype":66,"../index":110}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _control = require('../control/control');

var _control2 = _interopRequireDefault(_control);

var _css = require('../css');

var _css2 = _interopRequireDefault(_css);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api
 */
var _ol_control_Zoom_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var className = options.className !== undefined ? options.className : 'ol-zoom';

  var delta = options.delta !== undefined ? options.delta : 1;

  var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
  var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

  var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
  var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';

  var inElement = document.createElement('button');
  inElement.className = className + '-in';
  inElement.setAttribute('type', 'button');
  inElement.title = zoomInTipLabel;
  inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);

  _events2.default.listen(inElement, _eventtype2.default.CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, delta));

  var outElement = document.createElement('button');
  outElement.className = className + '-out';
  outElement.setAttribute('type', 'button');
  outElement.title = zoomOutTipLabel;
  outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);

  _events2.default.listen(outElement, _eventtype2.default.CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, -delta));

  var cssClasses = className + ' ' + _css2.default.CLASS_UNSELECTABLE + ' ' + _css2.default.CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(inElement);
  element.appendChild(outElement);

  _control2.default.call(this, {
    element: element,
    target: options.target
  });

  /**
   * @type {number}
   * @private
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_control_Zoom_, _control2.default);

/**
 * @param {number} delta Zoom delta.
 * @param {Event} event The event to handle
 * @private
 */
_ol_control_Zoom_.prototype.handleClick_ = function (delta, event) {
  event.preventDefault();
  this.zoomByDelta_(delta);
};

/**
 * @param {number} delta Zoom delta.
 * @private
 */
_ol_control_Zoom_.prototype.zoomByDelta_ = function (delta) {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }
  var currentResolution = view.getResolution();
  if (currentResolution) {
    var newResolution = view.constrainResolution(currentResolution, delta);
    if (this.duration_ > 0) {
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      view.animate({
        resolution: newResolution,
        duration: this.duration_,
        easing: _easing2.default.easeOut
      });
    } else {
      view.setResolution(newResolution);
    }
  }
};
exports.default = _ol_control_Zoom_;


},{"../control/control":54,"../css":58,"../easing":61,"../events":62,"../events/eventtype":66,"../index":110}],57:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

var _string = require('./string');

var _string2 = _interopRequireDefault(_string);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_coordinate_ = {};

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} The input coordinate adjusted by the given delta.
 * @api
 */
_ol_coordinate_.add = function (coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
};

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.
 * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to
 *     the segment.
 */
_ol_coordinate_.closestOnSegment = function (coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
};

/**
 * Returns a {@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {ol.CoordinateFormatType} Coordinate format.
 * @api
 */
_ol_coordinate_.createStringXY = function (opt_fractionDigits) {
  return (
    /**
     * @param {ol.Coordinate|undefined} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return _ol_coordinate_.toStringXY(coordinate, opt_fractionDigits);
    }
  );
};

/**
 * @private
 * @param {number} degrees Degrees.
 * @param {string} hemispheres Hemispheres.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
_ol_coordinate_.degreesToStringHDMS_ = function (degrees, hemispheres, opt_fractionDigits) {
  var normalizedDegrees = _math2.default.modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\u00b0 ' + _string2.default.padNumber(min, 2) + '\u2032 ' + _string2.default.padNumber(sec, 2, dflPrecision) + '\u2033 ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
};

/**
 * Transforms the given {@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
_ol_coordinate_.format = function (coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
};

/**
 * @param {ol.Coordinate} coordinate1 First coordinate.
 * @param {ol.Coordinate} coordinate2 Second coordinate.
 * @return {boolean} Whether the passed coordinates are equal.
 */
_ol_coordinate_.equals = function (coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
};

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_coordinate_.rotate = function (coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
};

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     ol.coordinate.scale(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_coordinate_.scale = function (coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
};

/**
 * Subtract `delta` to `coordinate`. `coordinate` is modified in place and
 * returned by the function.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_coordinate_.sub = function (coordinate, delta) {
  coordinate[0] -= delta[0];
  coordinate[1] -= delta[1];
  return coordinate;
};

/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
_ol_coordinate_.squaredDistance = function (coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
};

/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
_ol_coordinate_.distance = function (coord1, coord2) {
  return Math.sqrt(_ol_coordinate_.squaredDistance(coord1, coord2));
};

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {ol.Coordinate} coordinate Coordinate of the point.
 * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
_ol_coordinate_.squaredDistanceToSegment = function (coordinate, segment) {
  return _ol_coordinate_.squaredDistance(coordinate, _ol_coordinate_.closestOnSegment(coordinate, segment));
};

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47 58 60 N 7 50 60 E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47 58 60.0 N 7 50 60.0 E'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
_ol_coordinate_.toStringHDMS = function (coordinate, opt_fractionDigits) {
  if (coordinate) {
    return _ol_coordinate_.degreesToStringHDMS_(coordinate[1], 'NS', opt_fractionDigits) + ' ' + _ol_coordinate_.degreesToStringHDMS_(coordinate[0], 'EW', opt_fractionDigits);
  } else {
    return '';
  }
};

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
_ol_coordinate_.toStringXY = function (coordinate, opt_fractionDigits) {
  return _ol_coordinate_.format(coordinate, '{x}, {y}', opt_fractionDigits);
};
exports.default = _ol_coordinate_;


},{"./math":144,"./string":232}],58:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_css_ = {};

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_HIDDEN = 'ol-hidden';

/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_SELECTABLE = 'ol-selectable';

/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_UNSELECTABLE = 'ol-unselectable';

/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_UNSUPPORTED = 'ol-unsupported';

/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_CONTROL = 'ol-control';
exports.default = _ol_css_;


},{}],59:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var _ol_Disposable_ = function () {};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
_ol_Disposable_.prototype.disposed_ = false;

/**
 * Clean up.
 */
_ol_Disposable_.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
_ol_Disposable_.prototype.disposeInternal = _index2.default.nullFunction;
exports.default = _ol_Disposable_;


},{"./index":110}],60:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_dom_ = {};

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
_ol_dom_.createCanvasContext2D = function (opt_width, opt_height) {
  var canvas = document.createElement('CANVAS');
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return canvas.getContext('2d');
};

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */
_ol_dom_.outerWidth = function (element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
};

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */
_ol_dom_.outerHeight = function (element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
};

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
_ol_dom_.replaceNode = function (newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
_ol_dom_.removeNode = function (node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};

/**
 * @param {Node} node The node to remove the children from.
 */
_ol_dom_.removeChildren = function (node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};
exports.default = _ol_dom_;


},{}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_easing_ = {};

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.easeIn = function (t) {
  return Math.pow(t, 3);
};

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.easeOut = function (t) {
  return 1 - _ol_easing_.easeIn(1 - t);
};

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.inAndOut = function (t) {
  return 3 * t * t - 2 * t * t * t;
};

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.linear = function (t) {
  return t;
};

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.upAndDown = function (t) {
  if (t < 0.5) {
    return _ol_easing_.inAndOut(2 * t);
  } else {
    return 1 - _ol_easing_.inAndOut(2 * (t - 0.5));
  }
};
exports.default = _ol_easing_;


},{}],62:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_events_ = {};

/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */
_ol_events_.bindListener_ = function (listenerObj) {
  var boundListener = function (evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      _ol_events_.unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
};

/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */
_ol_events_.findListener_ = function (listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
};

/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */
_ol_events_.getListeners = function (target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};

/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */
_ol_events_.getListenerMap_ = function (target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
};

/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */
_ol_events_.removeListeners_ = function (target, type) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      _obj2.default.clear(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};

/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */
_ol_events_.listen = function (target, type, listener, opt_this, opt_once) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {ol.EventsKey} */{
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
};

/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */
_ol_events_.listenOnce = function (target, type, listener, opt_this) {
  return _ol_events_.listen(target, type, listener, opt_this, true);
};

/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
_ol_events_.unlisten = function (target, type, listener, opt_this) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, true);
    if (listenerObj) {
      _ol_events_.unlistenByKey(listenerObj);
    }
  }
};

/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */
_ol_events_.unlistenByKey = function (key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = _ol_events_.getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        _ol_events_.removeListeners_(key.target, key.type);
      }
    }
    _obj2.default.clear(key);
  }
};

/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */
_ol_events_.unlistenAll = function (target) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  for (var type in listenerMap) {
    _ol_events_.removeListeners_(target, type);
  }
};
exports.default = _ol_events_;


},{"./obj":146}],63:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _mapbrowsereventtype = require('../mapbrowsereventtype');

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _has = require('../has');

var _has2 = _interopRequireDefault(_has);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_events_condition_ = {};

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
_ol_events_condition_.altKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
_ol_events_condition_.altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return always true.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */
_ol_events_condition_.always = _functions2.default.TRUE;

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
_ol_events_condition_.click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.CLICK;
};

/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
_ol_events_condition_.mouseActionButton = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(_has2.default.WEBKIT && _has2.default.MAC && originalEvent.ctrlKey);
};

/**
 * Return always false.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */
_ol_events_condition_.never = _functions2.default.FALSE;

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
_ol_events_condition_.pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
_ol_events_condition_.singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.SINGLECLICK;
};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
_ol_events_condition_.doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == _mapbrowsereventtype2.default.DBLCLICK;
};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
_ol_events_condition_.noModifierKeys = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
_ol_events_condition_.platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (_has2.default.MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
_ol_events_condition_.shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
_ol_events_condition_.targetNotEditable = function (mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};

/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
_ol_events_condition_.mouseOnly = function (mapBrowserEvent) {
  _asserts2.default.assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return (/** @type {ol.MapBrowserEvent} */mapBrowserEvent.pointerEvent.pointerType == 'mouse'
  );
};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
_ol_events_condition_.primaryAction = function (mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
exports.default = _ol_events_condition_;


},{"../asserts":44,"../functions":78,"../has":107,"../mapbrowsereventtype":139}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */
var _ol_events_Event_ = function (type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.preventDefault =

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.stopPropagation = function (evt) {
  evt.stopPropagation();
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.preventDefault = function (evt) {
  evt.preventDefault();
};
exports.default = _ol_events_Event_;


},{}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _disposable = require('../disposable');

var _disposable2 = _interopRequireDefault(_disposable);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */
var _ol_events_EventTarget_ = function () {

  _disposable2.default.call(this);

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.pendingRemovals_ = {};

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.dispatching_ = {};

  /**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */
  this.listeners_ = {};
};

_index2.default.inherits(_ol_events_EventTarget_, _disposable2.default);

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};

/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */
_ol_events_EventTarget_.prototype.dispatchEvent = function (event) {
  var this$1 = this;

  var evt = typeof event === 'string' ? new _event2.default(event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this$1, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this$1.removeEventListener(type, _index2.default.nullFunction);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};

/**
 * @inheritDoc
 */
_ol_events_EventTarget_.prototype.disposeInternal = function () {
  _events2.default.unlistenAll(this);
};

/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */
_ol_events_EventTarget_.prototype.getListeners = function (type) {
  return this.listeners_[type];
};

/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */
_ol_events_EventTarget_.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = _index2.default.nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
exports.default = _ol_events_EventTarget_;


},{"../disposable":59,"../events":62,"../events/event":64,"../index":110}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 * @const
 */
var _ol_events_EventType_ = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */
  CHANGE: 'change',

  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};

exports.default = _ol_events_EventType_;


},{}],67:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 * @const
 */
var _ol_events_KeyCode_ = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};

exports.default = _ol_events_KeyCode_;


},{}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _corner = require('./extent/corner');

var _corner2 = _interopRequireDefault(_corner);

var _relationship = require('./extent/relationship');

var _relationship2 = _interopRequireDefault(_relationship);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_extent_ = {};

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Bounding extent.
 * @api
 */
_ol_extent_.boundingExtent = function (coordinates) {
  var extent = _ol_extent_.createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};

/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @private
 * @return {ol.Extent} Extent.
 */
_ol_extent_.boundingExtentXYs_ = function (xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Return extent increased by the provided value.
 * @param {ol.Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_extent_.buffer = function (extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
};

/**
 * Creates a clone of an extent.
 *
 * @param {ol.Extent} extent Extent to clone.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} The clone.
 */
_ol_extent_.clone = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
_ol_extent_.closestSquaredDistanceXY = function (extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
_ol_extent_.containsCoordinate = function (extent, coordinate) {
  return _ol_extent_.containsXY(extent, coordinate[0], coordinate[1]);
};

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
_ol_extent_.containsExtent = function (extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
_ol_extent_.containsXY = function (extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
};

/**
 * Get the relationship between a coordinate and extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} coordinate The coordinate.
 * @return {number} The relationship (bitwise compare with
 *     ol.extent.Relationship).
 */
_ol_extent_.coordinateRelationship = function (extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = _relationship2.default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | _relationship2.default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | _relationship2.default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | _relationship2.default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | _relationship2.default.ABOVE;
  }
  if (relationship === _relationship2.default.UNKNOWN) {
    relationship = _relationship2.default.INTERSECTING;
  }
  return relationship;
};

/**
 * Create an empty extent.
 * @return {ol.Extent} Empty extent.
 * @api
 */
_ol_extent_.createEmpty = function () {
  return [Infinity, Infinity, -Infinity, -Infinity];
};

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdate = function (minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
};

/**
 * Create a new empty extent or make the provided one empty.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateEmpty = function (opt_extent) {
  return _ol_extent_.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromCoordinate = function (coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return _ol_extent_.createOrUpdate(x, y, x, y, opt_extent);
};

/**
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromCoordinates = function (coordinates, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendCoordinates(extent, coordinates);
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromFlatCoordinates = function (flatCoordinates, offset, end, stride, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
};

/**
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromRings = function (rings, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendRings(extent, rings);
};

/**
 * Determine if two extents are equivalent.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
_ol_extent_.equals = function (extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
};

/**
 * Modify an extent to include another extent.
 * @param {ol.Extent} extent1 The extent to be modified.
 * @param {ol.Extent} extent2 The extent that will be included in the first.
 * @return {ol.Extent} A reference to the first (extended) extent.
 * @api
 */
_ol_extent_.extend = function (extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 */
_ol_extent_.extendCoordinate = function (extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendCoordinates = function (extent, coordinates) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendFlatCoordinates = function (extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    _ol_extent_.extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendRings = function (extent, rings) {
  var i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    _ol_extent_.extendCoordinates(extent, rings[i]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
_ol_extent_.extendXY = function (extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
};

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {ol.Extent} extent Extent.
 * @param {function(this:T, ol.Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
_ol_extent_.forEachCorner = function (extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, _ol_extent_.getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
};

/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Area.
 */
_ol_extent_.getArea = function (extent) {
  var area = 0;
  if (!_ol_extent_.isEmpty(extent)) {
    area = _ol_extent_.getWidth(extent) * _ol_extent_.getHeight(extent);
  }
  return area;
};

/**
 * Get the bottom left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom left coordinate.
 * @api
 */
_ol_extent_.getBottomLeft = function (extent) {
  return [extent[0], extent[1]];
};

/**
 * Get the bottom right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom right coordinate.
 * @api
 */
_ol_extent_.getBottomRight = function (extent) {
  return [extent[2], extent[1]];
};

/**
 * Get the center coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Center.
 * @api
 */
_ol_extent_.getCenter = function (extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
};

/**
 * Get a corner coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.extent.Corner} corner Corner.
 * @return {ol.Coordinate} Corner coordinate.
 */
_ol_extent_.getCorner = function (extent, corner) {
  var coordinate;
  if (corner === _corner2.default.BOTTOM_LEFT) {
    coordinate = _ol_extent_.getBottomLeft(extent);
  } else if (corner === _corner2.default.BOTTOM_RIGHT) {
    coordinate = _ol_extent_.getBottomRight(extent);
  } else if (corner === _corner2.default.TOP_LEFT) {
    coordinate = _ol_extent_.getTopLeft(extent);
  } else if (corner === _corner2.default.TOP_RIGHT) {
    coordinate = _ol_extent_.getTopRight(extent);
  } else {
    _asserts2.default.assert(false, 13); // Invalid corner
  }
  return (/** @type {!ol.Coordinate} */coordinate
  );
};

/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
_ol_extent_.getEnlargedArea = function (extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
};

/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.getForViewAndSize = function (center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return _ol_extent_.createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
};

/**
 * Get the height of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
_ol_extent_.getHeight = function (extent) {
  return extent[3] - extent[1];
};

/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
_ol_extent_.getIntersectionArea = function (extent1, extent2) {
  var intersection = _ol_extent_.getIntersection(extent1, extent2);
  return _ol_extent_.getArea(intersection);
};

/**
 * Get the intersection of two extents.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.
 * @return {ol.Extent} Intersecting extent.
 * @api
 */
_ol_extent_.getIntersection = function (extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : _ol_extent_.createEmpty();
  if (_ol_extent_.intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }
  return intersection;
};

/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Margin.
 */
_ol_extent_.getMargin = function (extent) {
  return _ol_extent_.getWidth(extent) + _ol_extent_.getHeight(extent);
};

/**
 * Get the size (width, height) of an extent.
 * @param {ol.Extent} extent The extent.
 * @return {ol.Size} The extent size.
 * @api
 */
_ol_extent_.getSize = function (extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
};

/**
 * Get the top left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top left coordinate.
 * @api
 */
_ol_extent_.getTopLeft = function (extent) {
  return [extent[0], extent[3]];
};

/**
 * Get the top right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top right coordinate.
 * @api
 */
_ol_extent_.getTopRight = function (extent) {
  return [extent[2], extent[3]];
};

/**
 * Get the width of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
_ol_extent_.getWidth = function (extent) {
  return extent[2] - extent[0];
};

/**
 * Determine if one extent intersects another.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
_ol_extent_.intersects = function (extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
};

/**
 * Determine if an extent is empty.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
_ol_extent_.isEmpty = function (extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.returnOrUpdate = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} value Value.
 */
_ol_extent_.scaleFromCenter = function (extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
};

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} start Segment start coordinate.
 * @param {ol.Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
_ol_extent_.intersectsSegment = function (extent, start, end) {
  var intersects = false;
  var startRel = _ol_extent_.coordinateRelationship(extent, start);
  var endRel = _ol_extent_.coordinateRelationship(extent, end);
  if (startRel === _relationship2.default.INTERSECTING || endRel === _relationship2.default.INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & _relationship2.default.ABOVE) && !(startRel & _relationship2.default.ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _relationship2.default.RIGHT) && !(startRel & _relationship2.default.RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & _relationship2.default.BELOW) && !(startRel & _relationship2.default.BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & _relationship2.default.LEFT) && !(startRel & _relationship2.default.LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
};

/**
 * Apply a transform function to the extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.TransformFunction} transformFn Transform function.  Called with
 * [minX, minY, maxX, maxY] extent coordinates.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_extent_.applyTransform = function (extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _ol_extent_.boundingExtentXYs_(xs, ys, opt_extent);
};
exports.default = _ol_extent_;


},{"./asserts":44,"./extent/corner":69,"./extent/relationship":70}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Extent corner.
 * @enum {string}
 */
var _ol_extent_Corner_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

exports.default = _ol_extent_Corner_;


},{}],70:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Relationship to an extent.
 * @enum {number}
 */
var _ol_extent_Relationship_ = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

exports.default = _ol_extent_Relationship_;


},{}],71:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _object = require('./object');

var _object2 = _interopRequireDefault(_object);

var _geometry = require('./geom/geometry');

var _geometry2 = _interopRequireDefault(_geometry);

var _style = require('./style/style');

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @constructor
 * @extends {ol.Object}
 * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * @api
 */
var _ol_Feature_ = function (opt_geometryOrProperties) {

  _object2.default.call(this);

  /**
   * @private
   * @type {number|string|undefined}
   */
  this.id_ = undefined;

  /**
   * @type {string}
   * @private
   */
  this.geometryName_ = 'geometry';

  /**
   * User provided style.
   * @private
   * @type {ol.style.Style|Array.<ol.style.Style>|
   *     ol.FeatureStyleFunction}
   */
  this.style_ = null;

  /**
   * @private
   * @type {ol.FeatureStyleFunction|undefined}
   */
  this.styleFunction_ = undefined;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.geometryChangeKey_ = null;

  _events2.default.listen(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  if (opt_geometryOrProperties !== undefined) {
    if (opt_geometryOrProperties instanceof _geometry2.default || !opt_geometryOrProperties) {
      var geometry = opt_geometryOrProperties;
      this.setGeometry(geometry);
    } else {
      /** @type {Object.<string, *>} */
      var properties = opt_geometryOrProperties;
      this.setProperties(properties);
    }
  }
};

_index2.default.inherits(_ol_Feature_, _object2.default);

/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * @return {ol.Feature} The clone.
 * @api
 */
_ol_Feature_.prototype.clone = function () {
  var clone = new _ol_Feature_(this.getProperties());
  clone.setGeometryName(this.getGeometryName());
  var geometry = this.getGeometry();
  if (geometry) {
    clone.setGeometry(geometry.clone());
  }
  var style = this.getStyle();
  if (style) {
    clone.setStyle(style);
  }
  return clone;
};

/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {@link ol.Feature#setGeometry}.
 * @return {ol.geom.Geometry|undefined} The default geometry for the feature.
 * @api
 * @observable
 */
_ol_Feature_.prototype.getGeometry = function () {
  return (/** @type {ol.geom.Geometry|undefined} */this.get(this.geometryName_)
  );
};

/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {@link ol.Feature#setId}.
 * @return {number|string|undefined} Id.
 * @api
 */
_ol_Feature_.prototype.getId = function () {
  return this.id_;
};

/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 * @return {string} Get the property name associated with the default geometry
 *     for this feature.
 * @api
 */
_ol_Feature_.prototype.getGeometryName = function () {
  return this.geometryName_;
};

/**
 * Get the feature's style. Will return what was provided to the
 * {@link ol.Feature#setStyle} method.
 * @return {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.
 * @api
 */
_ol_Feature_.prototype.getStyle = function () {
  return this.style_;
};

/**
 * Get the feature's style function.
 * @return {ol.FeatureStyleFunction|undefined} Return a function
 * representing the current style of this feature.
 * @api
 */
_ol_Feature_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};

/**
 * @private
 */
_ol_Feature_.prototype.handleGeometryChange_ = function () {
  this.changed();
};

/**
 * @private
 */
_ol_Feature_.prototype.handleGeometryChanged_ = function () {
  if (this.geometryChangeKey_) {
    _events2.default.unlistenByKey(this.geometryChangeKey_);
    this.geometryChangeKey_ = null;
  }
  var geometry = this.getGeometry();
  if (geometry) {
    this.geometryChangeKey_ = _events2.default.listen(geometry, _eventtype2.default.CHANGE, this.handleGeometryChange_, this);
  }
  this.changed();
};

/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {@link ol.Feature#getGeometryName}.
 * @param {ol.geom.Geometry|undefined} geometry The new geometry.
 * @api
 * @observable
 */
_ol_Feature_.prototype.setGeometry = function (geometry) {
  this.set(this.geometryName_, geometry);
};

/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 * @param {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.
 * @api
 * @fires ol.events.Event#event:change
 */
_ol_Feature_.prototype.setStyle = function (style) {
  this.style_ = style;
  this.styleFunction_ = !style ? undefined : _ol_Feature_.createStyleFunction(style);
  this.changed();
};

/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {@link ol.source.Vector#getFeatureById}
 * method.
 * @param {number|string|undefined} id The feature id.
 * @api
 * @fires ol.events.Event#event:change
 */
_ol_Feature_.prototype.setId = function (id) {
  this.id_ = id;
  this.changed();
};

/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * @param {string} name The property name of the default geometry.
 * @api
 */
_ol_Feature_.prototype.setGeometryName = function (name) {
  _events2.default.unlisten(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.geometryName_ = name;
  _events2.default.listen(this, _object2.default.getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.handleGeometryChanged_();
};

/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of ol.style.Style or single style objects wrapped
 * in a new feature style function.
 * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {ol.FeatureStyleFunction} A style function.
 */
_ol_Feature_.createStyleFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    if (obj.length == 2) {
      styleFunction = function (resolution) {
        return (/** @type {ol.StyleFunction} */obj(this, resolution)
        );
      };
    } else {
      styleFunction = obj;
    }
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts2.default.assert(obj instanceof _style2.default, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`
      styles = [obj];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
};
exports.default = _ol_Feature_;


},{"./asserts":44,"./events":62,"./events/eventtype":66,"./geom/geometry":95,"./index":110,"./object":147,"./style/style":244}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _formattype = require('./format/formattype');

var _formattype2 = _interopRequireDefault(_formattype);

var _xml = require('./xml');

var _xml2 = _interopRequireDefault(_xml);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_featureloader_ = {};

/**
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection)|function(this:ol.source.Vector, Array.<ol.Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {ol.FeatureLoader} The feature loader.
 */
_ol_featureloader_.loadFeaturesXhr = function (url, format, success, failure) {
  return (
    /**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {ol.proj.Projection} projection Projection.
     * @this {ol.source.Vector|ol.VectorTile}
     */
    function (extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
      if (format.getType() == _formattype2.default.ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == _formattype2.default.JSON || type == _formattype2.default.TEXT) {
            source = xhr.responseText;
          } else if (type == _formattype2.default.XML) {
            source = xhr.responseXML;
            if (!source) {
              source = _xml2.default.parse(xhr.responseText);
            }
          } else if (type == _formattype2.default.ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */xhr.response;
          }
          if (source) {
            success.call(this, format.readFeatures(source, { featureProjection: projection }), format.readProjection(source));
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function () {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
};

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @return {ol.FeatureLoader} The feature loader.
 * @api
 */
_ol_featureloader_.xhr = function (url, format) {
  return _ol_featureloader_.loadFeaturesXhr(url, format,
  /**
   * @param {Array.<ol.Feature>} features The loaded features.
   * @param {ol.proj.Projection} dataProjection Data projection.
   * @this {ol.source.Vector}
   */
  function (features, dataProjection) {
    this.addFeatures(features);
  }, /* FIXME handle error */_index2.default.nullFunction);
};
exports.default = _ol_featureloader_;


},{"./format/formattype":74,"./index":110,"./xml":267}],73:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _geometry = require('../geom/geometry');

var _geometry2 = _interopRequireDefault(_geometry);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {ol.format.Feature} subclasses provide the ability to decode and encode
 * {@link ol.Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @constructor
 * @abstract
 * @api
 */
var _ol_format_Feature_ = function () {

  /**
   * @protected
   * @type {ol.proj.Projection}
   */
  this.defaultDataProjection = null;

  /**
   * @protected
   * @type {ol.proj.Projection}
   */
  this.defaultFeatureProjection = null;
};

/**
 * Adds the data projection to the read options.
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {olx.format.ReadOptions|undefined} Options.
 * @protected
 */
_ol_format_Feature_.prototype.getReadOptions = function (source, opt_options) {
  var options;
  if (opt_options) {
    options = {
      dataProjection: opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source),
      featureProjection: opt_options.featureProjection
    };
  }
  return this.adaptOptions(options);
};

/**
 * Sets the `defaultDataProjection` on the options, if no `dataProjection`
 * is set.
 * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options
 *     Options.
 * @protected
 * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}
 *     Updated options.
 */
_ol_format_Feature_.prototype.adaptOptions = function (options) {
  return _obj2.default.assign({
    dataProjection: this.defaultDataProjection,
    featureProjection: this.defaultFeatureProjection
  }, options);
};

/**
 * @abstract
 * @return {ol.format.FormatType} Format.
 */
_ol_format_Feature_.prototype.getType = function () {};

/**
 * Read a single feature from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 */
_ol_format_Feature_.prototype.readFeature = function (source, opt_options) {};

/**
 * Read all features from a source.
 *
 * @abstract
 * @param {Document|Node|ArrayBuffer|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 */
_ol_format_Feature_.prototype.readFeatures = function (source, opt_options) {};

/**
 * Read a single geometry from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 */
_ol_format_Feature_.prototype.readGeometry = function (source, opt_options) {};

/**
 * Read the projection from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 */
_ol_format_Feature_.prototype.readProjection = function (source) {};

/**
 * Encode a feature in this format.
 *
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeFeature = function (feature, opt_options) {};

/**
 * Encode an array of features in this format.
 *
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeFeatures = function (features, opt_options) {};

/**
 * Write a single geometry in this format.
 *
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeGeometry = function (geometry, opt_options) {};

/**
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options
 *     Options.
 * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.
 * @protected
 */
_ol_format_Feature_.transformWithOptions = function (geometry, write, opt_options) {
  var featureProjection = opt_options ? _proj2.default.get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? _proj2.default.get(opt_options.dataProjection) : null;
  /**
   * @type {ol.geom.Geometry|ol.Extent}
   */
  var transformed;
  if (featureProjection && dataProjection && !_proj2.default.equivalent(featureProjection, dataProjection)) {
    if (geometry instanceof _geometry2.default) {
      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    } else {
      // FIXME this is necessary because ol.format.GML treats extents
      // as geometries
      transformed = _proj2.default.transformExtent(write ? geometry.slice() : geometry, write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    }
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals) {
    var power = Math.pow(10, opt_options.decimals);
    // if decimals option on write, round each coordinate appropriately
    /**
     * @param {Array.<number>} coordinates Coordinates.
     * @return {Array.<number>} Transformed coordinates.
     */
    var transform = function (coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }
      return coordinates;
    };
    if (Array.isArray(transformed)) {
      transform(transformed);
    } else {
      transformed.applyTransform(transform);
    }
  }
  return transformed;
};
exports.default = _ol_format_Feature_;


},{"../geom/geometry":95,"../obj":146,"../proj":158}],74:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_format_FormatType_ = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};

exports.default = _ol_format_FormatType_;


},{}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _feature = require('../feature');

var _feature2 = _interopRequireDefault(_feature);

var _feature3 = require('../format/feature');

var _feature4 = _interopRequireDefault(_feature3);

var _jsonfeature = require('../format/jsonfeature');

var _jsonfeature2 = _interopRequireDefault(_jsonfeature);

var _geometrycollection = require('../geom/geometrycollection');

var _geometrycollection2 = _interopRequireDefault(_geometrycollection);

var _linestring = require('../geom/linestring');

var _linestring2 = _interopRequireDefault(_linestring);

var _multilinestring = require('../geom/multilinestring');

var _multilinestring2 = _interopRequireDefault(_multilinestring);

var _multipoint = require('../geom/multipoint');

var _multipoint2 = _interopRequireDefault(_multipoint);

var _multipolygon = require('../geom/multipolygon');

var _multipolygon2 = _interopRequireDefault(_multipolygon);

var _point = require('../geom/point');

var _point2 = _interopRequireDefault(_point);

var _polygon = require('../geom/polygon');

var _polygon2 = _interopRequireDefault(_polygon);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @constructor
 * @extends {ol.format.JSONFeature}
 * @param {olx.format.GeoJSONOptions=} opt_options Options.
 * @api
 */
// TODO: serialize dataProjection as crs member when writing
// see https://github.com/openlayers/openlayers/issues/2078

var _ol_format_GeoJSON_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  _jsonfeature2.default.call(this);

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = _proj2.default.get(options.defaultDataProjection ? options.defaultDataProjection : 'EPSG:4326');

  if (options.featureProjection) {
    this.defaultFeatureProjection = _proj2.default.get(options.featureProjection);
  }

  /**
   * Name of the geometry attribute for features.
   * @type {string|undefined}
   * @private
   */
  this.geometryName_ = options.geometryName;
};

_index2.default.inherits(_ol_format_GeoJSON_, _jsonfeature2.default);

/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 */
_ol_format_GeoJSON_.readGeometry_ = function (object, opt_options) {
  if (!object) {
    return null;
  }
  var geometryReader = _ol_format_GeoJSON_.GEOMETRY_READERS_[object.type];
  return (/** @type {ol.geom.Geometry} */_feature4.default.transformWithOptions(geometryReader(object), false, opt_options)
  );
};

/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.GeometryCollection} Geometry collection.
 */
_ol_format_GeoJSON_.readGeometryCollectionGeometry_ = function (object, opt_options) {
  var geometries = object.geometries.map(
  /**
   * @param {GeoJSONGeometry} geometry Geometry.
   * @return {ol.geom.Geometry} geometry Geometry.
   */
  function (geometry) {
    return _ol_format_GeoJSON_.readGeometry_(geometry, opt_options);
  });
  return new _geometrycollection2.default(geometries);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 */
_ol_format_GeoJSON_.readPointGeometry_ = function (object) {
  return new _point2.default(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.LineString} LineString.
 */
_ol_format_GeoJSON_.readLineStringGeometry_ = function (object) {
  return new _linestring2.default(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiLineString} MultiLineString.
 */
_ol_format_GeoJSON_.readMultiLineStringGeometry_ = function (object) {
  return new _multilinestring2.default(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPoint} MultiPoint.
 */
_ol_format_GeoJSON_.readMultiPointGeometry_ = function (object) {
  return new _multipoint2.default(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPolygon} MultiPolygon.
 */
_ol_format_GeoJSON_.readMultiPolygonGeometry_ = function (object) {
  return new _multipolygon2.default(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Polygon} Polygon.
 */
_ol_format_GeoJSON_.readPolygonGeometry_ = function (object) {
  return new _polygon2.default(object.coordinates);
};

/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writeGeometry_ = function (geometry, opt_options) {
  var geometryWriter = _ol_format_GeoJSON_.GEOMETRY_WRITERS_[geometry.getType()];
  return geometryWriter( /** @type {ol.geom.Geometry} */_feature4.default.transformWithOptions(geometry, true, opt_options), opt_options);
};

/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @private
 * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.
 */
_ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_ = function (geometry) {
  return (/** @type {GeoJSONGeometryCollection} */{
      type: 'GeometryCollection',
      geometries: []
    }
  );
};

/**
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */
_ol_format_GeoJSON_.writeGeometryCollectionGeometry_ = function (geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function (geometry) {
    var options = _obj2.default.assign({}, opt_options);
    delete options.featureProjection;
    return _ol_format_GeoJSON_.writeGeometry_(geometry, options);
  });
  return (/** @type {GeoJSONGeometryCollection} */{
      type: 'GeometryCollection',
      geometries: geometries
    }
  );
};

/**
 * @param {ol.geom.LineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writeLineStringGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'LineString',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiLineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writeMultiLineStringGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiLineString',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiPoint} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writeMultiPointGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiPoint',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writeMultiPolygonGeometry_ = function (geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiPolygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};

/**
 * @param {ol.geom.Point} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writePointGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'Point',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.Polygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
_ol_format_GeoJSON_.writePolygonGeometry_ = function (geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return (/** @type {GeoJSONGeometry} */{
      type: 'Polygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};

/**
 * @const
 * @private
 * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}
 */
_ol_format_GeoJSON_.GEOMETRY_READERS_ = {
  'Point': _ol_format_GeoJSON_.readPointGeometry_,
  'LineString': _ol_format_GeoJSON_.readLineStringGeometry_,
  'Polygon': _ol_format_GeoJSON_.readPolygonGeometry_,
  'MultiPoint': _ol_format_GeoJSON_.readMultiPointGeometry_,
  'MultiLineString': _ol_format_GeoJSON_.readMultiLineStringGeometry_,
  'MultiPolygon': _ol_format_GeoJSON_.readMultiPolygonGeometry_,
  'GeometryCollection': _ol_format_GeoJSON_.readGeometryCollectionGeometry_
};

/**
 * @const
 * @private
 * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}
 */
_ol_format_GeoJSON_.GEOMETRY_WRITERS_ = {
  'Point': _ol_format_GeoJSON_.writePointGeometry_,
  'LineString': _ol_format_GeoJSON_.writeLineStringGeometry_,
  'Polygon': _ol_format_GeoJSON_.writePolygonGeometry_,
  'MultiPoint': _ol_format_GeoJSON_.writeMultiPointGeometry_,
  'MultiLineString': _ol_format_GeoJSON_.writeMultiLineStringGeometry_,
  'MultiPolygon': _ol_format_GeoJSON_.writeMultiPolygonGeometry_,
  'GeometryCollection': _ol_format_GeoJSON_.writeGeometryCollectionGeometry_,
  'Circle': _ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_
};

/**
 * Read a feature from a GeoJSON Feature source.  Only works for Feature or
 * geometry types.  Use {@link ol.format.GeoJSON#readFeatures} to read
 * FeatureCollection source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 * @api
 */
_ol_format_GeoJSON_.prototype.readFeature;

/**
 * Read all features from a GeoJSON source.  Works for all GeoJSON types.
 * If the source includes only geometries, features will be created with those
 * geometries.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
_ol_format_GeoJSON_.prototype.readFeatures;

/**
 * @inheritDoc
 */
_ol_format_GeoJSON_.prototype.readFeatureFromObject = function (object, opt_options) {
  /**
   * @type {GeoJSONFeature}
   */
  var geoJSONFeature = null;
  if (object.type === 'Feature') {
    geoJSONFeature = /** @type {GeoJSONFeature} */object;
  } else {
    geoJSONFeature = /** @type {GeoJSONFeature} */{
      type: 'Feature',
      geometry: /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */object
    };
  }

  var geometry = _ol_format_GeoJSON_.readGeometry_(geoJSONFeature.geometry, opt_options);
  var feature = new _feature2.default();
  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  }
  feature.setGeometry(geometry);
  if (geoJSONFeature.id !== undefined) {
    feature.setId(geoJSONFeature.id);
  }
  if (geoJSONFeature.properties) {
    feature.setProperties(geoJSONFeature.properties);
  }
  return feature;
};

/**
 * @inheritDoc
 */
_ol_format_GeoJSON_.prototype.readFeaturesFromObject = function (object, opt_options) {
  var this$1 = this;

  var geoJSONObject = /** @type {GeoJSONObject} */object;
  /** @type {Array.<ol.Feature>} */
  var features = null;
  if (geoJSONObject.type === 'FeatureCollection') {
    var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */
    object;
    features = [];
    var geoJSONFeatures = geoJSONFeatureCollection.features;
    var i, ii;
    for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
      features.push(this$1.readFeatureFromObject(geoJSONFeatures[i], opt_options));
    }
  } else {
    features = [this.readFeatureFromObject(object, opt_options)];
  }
  return features;
};

/**
 * Read a geometry from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 * @api
 */
_ol_format_GeoJSON_.prototype.readGeometry;

/**
 * @inheritDoc
 */
_ol_format_GeoJSON_.prototype.readGeometryFromObject = function (object, opt_options) {
  return _ol_format_GeoJSON_.readGeometry_(
  /** @type {GeoJSONGeometry} */object, opt_options);
};

/**
 * Read the projection from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */
_ol_format_GeoJSON_.prototype.readProjection;

/**
 * @inheritDoc
 */
_ol_format_GeoJSON_.prototype.readProjectionFromObject = function (object) {
  var geoJSONObject = /** @type {GeoJSONObject} */object;
  var crs = geoJSONObject.crs;
  var projection;
  if (crs) {
    if (crs.type == 'name') {
      projection = _proj2.default.get(crs.properties.name);
    } else if (crs.type == 'EPSG') {
      // 'EPSG' is not part of the GeoJSON specification, but is generated by
      // GeoServer.
      // TODO: remove this when http://jira.codehaus.org/browse/GEOS-5996
      // is fixed and widely deployed.
      projection = _proj2.default.get('EPSG:' + crs.properties.code);
    } else {
      _asserts2.default.assert(false, 36); // Unknown SRS type
    }
  } else {
    projection = this.defaultDataProjection;
  }
  return (/** @type {ol.proj.Projection} */projection
  );
};

/**
 * Encode a feature as a GeoJSON Feature string.
 *
 * @function
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @override
 * @api
 */
_ol_format_GeoJSON_.prototype.writeFeature;

/**
 * Encode a feature as a GeoJSON Feature object.
 *
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeature} Object.
 * @override
 * @api
 */
_ol_format_GeoJSON_.prototype.writeFeatureObject = function (feature, opt_options) {
  opt_options = this.adaptOptions(opt_options);

  var object = /** @type {GeoJSONFeature} */{
    'type': 'Feature'
  };
  var id = feature.getId();
  if (id !== undefined) {
    object.id = id;
  }
  var geometry = feature.getGeometry();
  if (geometry) {
    object.geometry = _ol_format_GeoJSON_.writeGeometry_(geometry, opt_options);
  } else {
    object.geometry = null;
  }
  var properties = feature.getProperties();
  delete properties[feature.getGeometryName()];
  if (!_obj2.default.isEmpty(properties)) {
    object.properties = properties;
  } else {
    object.properties = null;
  }
  return object;
};

/**
 * Encode an array of features as GeoJSON.
 *
 * @function
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */
_ol_format_GeoJSON_.prototype.writeFeatures;

/**
 * Encode an array of features as a GeoJSON object.
 *
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeatureCollection} GeoJSON Object.
 * @override
 * @api
 */
_ol_format_GeoJSON_.prototype.writeFeaturesObject = function (features, opt_options) {
  var this$1 = this;

  opt_options = this.adaptOptions(opt_options);
  var objects = [];
  var i, ii;
  for (i = 0, ii = features.length; i < ii; ++i) {
    objects.push(this$1.writeFeatureObject(features[i], opt_options));
  }
  return (/** @type {GeoJSONFeatureCollection} */{
      type: 'FeatureCollection',
      features: objects
    }
  );
};

/**
 * Encode a geometry as a GeoJSON string.
 *
 * @function
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */
_ol_format_GeoJSON_.prototype.writeGeometry;

/**
 * Encode a geometry as a GeoJSON object.
 *
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
 * @override
 * @api
 */
_ol_format_GeoJSON_.prototype.writeGeometryObject = function (geometry, opt_options) {
  return _ol_format_GeoJSON_.writeGeometry_(geometry, this.adaptOptions(opt_options));
};
exports.default = _ol_format_GeoJSON_;


},{"../asserts":44,"../feature":71,"../format/feature":73,"../format/jsonfeature":76,"../geom/geometrycollection":96,"../geom/linestring":100,"../geom/multilinestring":101,"../geom/multipoint":102,"../geom/multipolygon":103,"../geom/point":104,"../geom/polygon":105,"../index":110,"../obj":146,"../proj":158}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _feature = require('../format/feature');

var _feature2 = _interopRequireDefault(_feature);

var _formattype = require('../format/formattype');

var _formattype2 = _interopRequireDefault(_formattype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 */
var _ol_format_JSONFeature_ = function () {
  _feature2.default.call(this);
};

_index2.default.inherits(_ol_format_JSONFeature_, _feature2.default);

/**
 * @param {Document|Node|Object|string} source Source.
 * @private
 * @return {Object} Object.
 */
_ol_format_JSONFeature_.prototype.getObject_ = function (source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ? /** @type {Object} */object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.getType = function () {
  return _formattype2.default.JSON;
};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.readFeature = function (source, opt_options) {
  return this.readFeatureFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.readFeatures = function (source, opt_options) {
  return this.readFeaturesFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.Feature} Feature.
 */
_ol_format_JSONFeature_.prototype.readFeatureFromObject = function (object, opt_options) {};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */
_ol_format_JSONFeature_.prototype.readFeaturesFromObject = function (object, opt_options) {};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.readGeometry = function (source, opt_options) {
  return this.readGeometryFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */
_ol_format_JSONFeature_.prototype.readGeometryFromObject = function (object, opt_options) {};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.readProjection = function (source) {
  return this.readProjectionFromObject(this.getObject_(source));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */
_ol_format_JSONFeature_.prototype.readProjectionFromObject = function (object) {};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.writeFeature = function (feature, opt_options) {
  return JSON.stringify(this.writeFeatureObject(feature, opt_options));
};

/**
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
_ol_format_JSONFeature_.prototype.writeFeatureObject = function (feature, opt_options) {};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.writeFeatures = function (features, opt_options) {
  return JSON.stringify(this.writeFeaturesObject(features, opt_options));
};

/**
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
_ol_format_JSONFeature_.prototype.writeFeaturesObject = function (features, opt_options) {};

/**
 * @inheritDoc
 */
_ol_format_JSONFeature_.prototype.writeGeometry = function (geometry, opt_options) {
  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
};

/**
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
_ol_format_JSONFeature_.prototype.writeGeometryObject = function (geometry, opt_options) {};
exports.default = _ol_format_JSONFeature_;


},{"../format/feature":73,"../format/formattype":74,"../index":110}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _pbf = require('pbf');

var _pbf2 = _interopRequireDefault(_pbf);

var _vectorTile = require('vector-tile');

var _vectorTile2 = _interopRequireDefault(_vectorTile);

var _feature = require('../format/feature');

var _feature2 = _interopRequireDefault(_feature);

var _formattype = require('../format/formattype');

var _formattype2 = _interopRequireDefault(_formattype);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _linestring = require('../geom/linestring');

var _linestring2 = _interopRequireDefault(_linestring);

var _multilinestring = require('../geom/multilinestring');

var _multilinestring2 = _interopRequireDefault(_multilinestring);

var _multipoint = require('../geom/multipoint');

var _multipoint2 = _interopRequireDefault(_multipoint);

var _point = require('../geom/point');

var _point2 = _interopRequireDefault(_point);

var _polygon = require('../geom/polygon');

var _polygon2 = _interopRequireDefault(_polygon);

var _projection = require('../proj/projection');

var _projection2 = _interopRequireDefault(_projection);

var _units = require('../proj/units');

var _units2 = _interopRequireDefault(_units);

var _feature3 = require('../render/feature');

var _feature4 = _interopRequireDefault(_feature3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Feature format for reading data in the Mapbox MVT format.
 *
 * @constructor
 * @extends {ol.format.Feature}
 * @param {olx.format.MVTOptions=} opt_options Options.
 * @api
 */
var _ol_format_MVT_ = function (opt_options) {

  _feature2.default.call(this);

  var options = opt_options ? opt_options : {};

  /**
   * @type {ol.proj.Projection}
   */
  this.defaultDataProjection = new _projection2.default({
    code: '',
    units: _units2.default.TILE_PIXELS
  });

  /**
   * @private
   * @type {function((ol.geom.Geometry|Object.<string, *>)=)|
   *     function(ol.geom.GeometryType,Array.<number>,
   *         (Array.<number>|Array.<Array.<number>>),Object.<string, *>)}
   */
  this.featureClass_ = options.featureClass ? options.featureClass : _feature4.default;

  /**
   * @private
   * @type {string|undefined}
   */
  this.geometryName_ = options.geometryName;

  /**
   * @private
   * @type {string}
   */
  this.layerName_ = options.layerName ? options.layerName : 'layer';

  /**
   * @private
   * @type {Array.<string>}
   */
  this.layers_ = options.layers ? options.layers : null;
}; //FIXME Implement projection handling

_index2.default.inherits(_ol_format_MVT_, _feature2.default);

/**
 * @inheritDoc
 */
_ol_format_MVT_.prototype.getType = function () {
  return _formattype2.default.ARRAY_BUFFER;
};

/**
 * @private
 * @param {Object} rawFeature Raw Mapbox feature.
 * @param {string} layer Layer.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 */
_ol_format_MVT_.prototype.readFeature_ = function (rawFeature, layer, opt_options) {
  var feature = new this.featureClass_();
  var id = rawFeature.id;
  var values = rawFeature.properties;
  values[this.layerName_] = layer;
  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  }
  var geometry = _feature2.default.transformWithOptions(_ol_format_MVT_.readGeometry_(rawFeature), false, this.adaptOptions(opt_options));
  feature.setGeometry(geometry);
  feature.setId(id);
  feature.setProperties(values);
  return feature;
};

/**
 * @private
 * @param {Object} rawFeature Raw Mapbox feature.
 * @param {string} layer Layer.
 * @return {ol.render.Feature} Feature.
 */
_ol_format_MVT_.prototype.readRenderFeature_ = function (rawFeature, layer) {
  var coords = rawFeature.loadGeometry();
  var ends = [];
  var flatCoordinates = [];
  _ol_format_MVT_.calculateFlatCoordinates_(coords, flatCoordinates, ends);

  var type = rawFeature.type;
  /** @type {ol.geom.GeometryType} */
  var geometryType;
  if (type === 1) {
    geometryType = coords.length === 1 ? _geometrytype2.default.POINT : _geometrytype2.default.MULTI_POINT;
  } else if (type === 2) {
    if (coords.length === 1) {
      geometryType = _geometrytype2.default.LINE_STRING;
    } else {
      geometryType = _geometrytype2.default.MULTI_LINE_STRING;
    }
  } else if (type === 3) {
    geometryType = _geometrytype2.default.POLYGON;
  }

  var values = rawFeature.properties;
  values[this.layerName_] = layer;

  return new this.featureClass_(geometryType, flatCoordinates, ends, values);
};

/**
 * @inheritDoc
 * @api
 */
_ol_format_MVT_.prototype.readFeatures = function (source, opt_options) {
  var this$1 = this;

  var layers = this.layers_;

  var pbf = new _pbf2.default(source);
  var tile = new _vectorTile2.default.VectorTile(pbf);
  var features = [];
  var featureClass = this.featureClass_;
  var layer, feature;
  for (var name in tile.layers) {
    if (layers && layers.indexOf(name) == -1) {
      continue;
    }
    layer = tile.layers[name];

    for (var i = 0, ii = layer.length; i < ii; ++i) {
      if (featureClass === _feature4.default) {
        feature = this$1.readRenderFeature_(layer.feature(i), name);
      } else {
        feature = this$1.readFeature_(layer.feature(i), name, opt_options);
      }
      features.push(feature);
    }
  }

  return features;
};

/**
 * @inheritDoc
 * @api
 */
_ol_format_MVT_.prototype.readProjection = function (source) {
  return this.defaultDataProjection;
};

/**
 * Sets the layers that features will be read from.
 * @param {Array.<string>} layers Layers.
 * @api
 */
_ol_format_MVT_.prototype.setLayers = function (layers) {
  this.layers_ = layers;
};

/**
 * @private
 * @param {Object} coords Raw feature coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates to be populated by
 *     this function.
 * @param {Array.<number>} ends Ends to be populated by this function.
 */
_ol_format_MVT_.calculateFlatCoordinates_ = function (coords, flatCoordinates, ends) {
  var end = 0;
  for (var i = 0, ii = coords.length; i < ii; ++i) {
    var line = coords[i];
    var j, jj;
    for (j = 0, jj = line.length; j < jj; ++j) {
      var coord = line[j];
      // Non-tilespace coords can be calculated here when a TileGrid and
      // TileCoord are known.
      flatCoordinates.push(coord.x, coord.y);
    }
    end += 2 * j;
    ends.push(end);
  }
};

/**
 * @private
 * @param {Object} rawFeature Raw Mapbox feature.
 * @return {ol.geom.Geometry} Geometry.
 */
_ol_format_MVT_.readGeometry_ = function (rawFeature) {
  var type = rawFeature.type;
  if (type === 0) {
    return null;
  }

  var coords = rawFeature.loadGeometry();
  var ends = [];
  var flatCoordinates = [];
  _ol_format_MVT_.calculateFlatCoordinates_(coords, flatCoordinates, ends);

  var geom;
  if (type === 1) {
    geom = coords.length === 1 ? new _point2.default(null) : new _multipoint2.default(null);
  } else if (type === 2) {
    if (coords.length === 1) {
      geom = new _linestring2.default(null);
    } else {
      geom = new _multilinestring2.default(null);
    }
  } else if (type === 3) {
    geom = new _polygon2.default(null);
  }

  geom.setFlatCoordinates(_geometrylayout2.default.XY, flatCoordinates, ends);

  return geom;
};

/**
 * Not implemented.
 * @override
 */
_ol_format_MVT_.prototype.readFeature = function () {};

/**
 * Not implemented.
 * @override
 */
_ol_format_MVT_.prototype.readGeometry = function () {};

/**
 * Not implemented.
 * @override
 */
_ol_format_MVT_.prototype.writeFeature = function () {};

/**
 * Not implemented.
 * @override
 */
_ol_format_MVT_.prototype.writeGeometry = function () {};

/**
 * Not implemented.
 * @override
 */
_ol_format_MVT_.prototype.writeFeatures = function () {};
exports.default = _ol_format_MVT_;


},{"../format/feature":73,"../format/formattype":74,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/linestring":100,"../geom/multilinestring":101,"../geom/multipoint":102,"../geom/point":104,"../geom/polygon":105,"../index":110,"../proj/projection":162,"../proj/units":165,"../render/feature":178,"pbf":268,"vector-tile":285}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_functions_ = {};

/**
 * Always returns true.
 * @returns {boolean} true.
 */
_ol_functions_.TRUE = function () {
  return true;
};

/**
 * Always returns false.
 * @returns {boolean} false.
 */
_ol_functions_.FALSE = function () {
  return false;
};
exports.default = _ol_functions_;


},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_area_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRing = function (flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRings = function (flatCoordinates, offset, ends, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += _ol_geom_flat_area_.linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += _ol_geom_flat_area_.linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
};
exports.default = _ol_geom_flat_area_;


},{}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_center_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array.<number>} Flat centers.
 */
_ol_geom_flat_center_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var i, ii;
  var extent = _extent2.default.createEmpty();
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = _extent2.default.createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
};
exports.default = _ol_geom_flat_center_;


},{"../../extent":68}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('../../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_closest_ = {};

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */
_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var i, offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = _math2.default.lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
};

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = _math2.default.squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > maxSquaredDelta) {
      maxSquaredDelta = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);
    offset = end;
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);
    offset = ends[ends.length - 1];
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = _math2.default.squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = _math2.default.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = _math2.default.squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
};
exports.default = _ol_geom_flat_closest_;


},{"../../math":144}],82:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_contains_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
_ol_geom_flat_contains_.linearRingContainsExtent = function (flatCoordinates, offset, end, stride, extent) {
  var outside = _extent2.default.forEachCorner(extent,
  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingContainsXY = function (flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingsContainsXY = function (flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingssContainsXY = function (flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
exports.default = _ol_geom_flat_contains_;


},{"../../extent":68}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_deflate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
_ol_geom_flat_deflate_.coordinate = function (flatCoordinates, offset, coordinate, stride) {
  var i, ii;
  for (i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
_ol_geom_flat_deflate_.coordinates = function (flatCoordinates, offset, coordinates, stride) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    var j;
    for (j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */
_ol_geom_flat_deflate_.coordinatess = function (flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = _ol_geom_flat_deflate_.coordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */
_ol_geom_flat_deflate_.coordinatesss = function (flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = _ol_geom_flat_deflate_.coordinatess(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
};
exports.default = _ol_geom_flat_deflate_;


},{}],84:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_inflate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<ol.Coordinate>} Coordinates.
 */
_ol_geom_flat_inflate_.coordinates = function (flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.
 */
_ol_geom_flat_inflate_.coordinatess = function (flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = _ol_geom_flat_inflate_.coordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.
 */
_ol_geom_flat_inflate_.coordinatesss = function (flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = _ol_geom_flat_inflate_.coordinatess(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
};
exports.default = _ol_geom_flat_inflate_;


},{}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _contains = require('../flat/contains');

var _contains2 = _interopRequireDefault(_contains);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_interiorpoint_ = {};

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */
_ol_geom_flat_interiorpoint_.linearRings = function (flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array.<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  var end = ends[0];
  x1 = flatCoordinates[end - stride];
  y1 = flatCoordinates[end - stride + 1];
  for (i = offset; i < end; i += stride) {
    x2 = flatCoordinates[i];
    y2 = flatCoordinates[i + 1];
    if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
      x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
      intersections.push(x);
    }
    x1 = x2;
    y1 = y2;
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(_array2.default.numberSafeCompareFunction);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (_contains2.default.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y);
    return opt_dest;
  } else {
    return [pointX, y];
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points.
 */
_ol_geom_flat_interiorpoint_.linearRingss = function (flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = _ol_geom_flat_interiorpoint_.linearRings(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
};
exports.default = _ol_geom_flat_interiorpoint_;


},{"../../array":42,"../flat/contains":82}],86:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _math = require('../../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_interpolate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */
_ol_geom_flat_interpolate_.lineString = function (flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    var i;
    for (i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = _array2.default.binarySearch(cumulativeLengths, target);
    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = _math2.default.lerp(flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = _math2.default.lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function (flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  var i;
  for (i = 0; i < stride - 1; ++i) {
    coordinate.push(_math2.default.lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function (flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
};
exports.default = _ol_geom_flat_interpolate_;


},{"../../array":42,"../../math":144}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _contains = require('../flat/contains');

var _contains2 = _interopRequireDefault(_contains);

var _segments = require('../flat/segments');

var _segments2 = _interopRequireDefault(_segments);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_intersectsextent_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.lineString = function (flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = _extent2.default.extendFlatCoordinates(_extent2.default.createEmpty(), flatCoordinates, offset, end, stride);
  if (!_extent2.default.intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (_extent2.default.containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return _segments2.default.forEach(flatCoordinates, offset, end, stride,
  /**
   * @param {ol.Coordinate} point1 Start point.
   * @param {ol.Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return _extent2.default.intersectsSegment(extent, point1, point2);
  });
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.lineStrings = function (flatCoordinates, offset, ends, stride, extent) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRing = function (flatCoordinates, offset, end, stride, extent) {
  if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (_contains2.default.linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRings = function (flatCoordinates, offset, ends, stride, extent) {
  if (!_ol_geom_flat_intersectsextent_.linearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_contains2.default.linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRingss = function (flatCoordinates, offset, endss, stride, extent) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (_ol_geom_flat_intersectsextent_.linearRings(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
exports.default = _ol_geom_flat_intersectsextent_;


},{"../../extent":68,"../flat/contains":82,"../flat/segments":91}],88:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_length_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
_ol_geom_flat_length_.lineString = function (flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  var i;
  for (i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
_ol_geom_flat_length_.linearRing = function (flatCoordinates, offset, end, stride) {
  var perimeter = _ol_geom_flat_length_.lineString(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
};
exports.default = _ol_geom_flat_length_;


},{}],89:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _reverse = require('../flat/reverse');

var _reverse2 = _interopRequireDefault(_reverse);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_orient_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
_ol_geom_flat_orient_.linearRingIsClockwise = function (flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
};

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
_ol_geom_flat_orient_.linearRingsAreOriented = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
};

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
_ol_geom_flat_orient_.linearRingssAreOriented = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    if (!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
};

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
_ol_geom_flat_orient_.orientLinearRings = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      _reverse2.default.coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
};

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
_ol_geom_flat_orient_.orientLinearRingss = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
};
exports.default = _ol_geom_flat_orient_;


},{"../flat/reverse":90}],90:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_reverse_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
_ol_geom_flat_reverse_.coordinates = function (flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    var i;
    for (i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
};
exports.default = _ol_geom_flat_reverse_;


},{}],91:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_segments_ = {};

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
_ol_geom_flat_segments_.forEach = function (flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
};
exports.default = _ol_geom_flat_segments_;


},{}],92:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('../../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_simplify_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.

_ol_geom_flat_simplify_.lineString = function (flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeucker = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array.<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array.<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  var i;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = _math2.default.squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeuckers = function (flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeuckerss = function (flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.radialDistance = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (_math2.default.squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
};

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
_ol_geom_flat_simplify_.snap = function (value, tolerance) {
  return tolerance * Math.round(value / tolerance);
};

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantize = function (flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    var x3, y3;
    // snap the next coordinate (P3)
    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantizes = function (flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantizess = function (flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};
exports.default = _ol_geom_flat_simplify_;


},{"../../math":144}],93:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _area = require('../flat/area');

var _area2 = _interopRequireDefault(_area);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_geom_flat_topology_ = {};

/**
 * Check if the linestring is a boundary.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */
_ol_geom_flat_topology_.lineStringIsClosed = function (flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;
  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!_area2.default.linearRing(flatCoordinates, offset, end, stride);
  }
  return false;
};
exports.default = _ol_geom_flat_topology_;


},{"../flat/area":79}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_geom_flat_transform_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.transform2D = function (flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.rotate = function (flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.scale = function (flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.translate = function (flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j, k;
  for (j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
exports.default = _ol_geom_flat_transform_;


},{}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @api
 */
var _ol_geom_Geometry_ = function () {

  _object2.default.call(this);

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = _extent2.default.createEmpty();

  /**
   * @private
   * @type {number}
   */
  this.extentRevision_ = -1;

  /**
   * @protected
   * @type {Object.<string, ol.geom.Geometry>}
   */
  this.simplifiedGeometryCache = {};

  /**
   * @protected
   * @type {number}
   */
  this.simplifiedGeometryMaxMinSquaredTolerance = 0;

  /**
   * @protected
   * @type {number}
   */
  this.simplifiedGeometryRevision = 0;
};

_index2.default.inherits(_ol_geom_Geometry_, _object2.default);

/**
 * Make a complete copy of the geometry.
 * @abstract
 * @return {!ol.geom.Geometry} Clone.
 */
_ol_geom_Geometry_.prototype.clone = function () {};

/**
 * @abstract
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.Coordinate} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @return {number} Minimum squared distance.
 */
_ol_geom_Geometry_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {};

/**
 * Return the closest point of the geometry to the passed point as
 * {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} point Point.
 * @param {ol.Coordinate=} opt_closestPoint Closest point.
 * @return {ol.Coordinate} Closest point.
 * @api
 */
_ol_geom_Geometry_.prototype.getClosestPoint = function (point, opt_closestPoint) {
  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
  this.closestPointXY(point[0], point[1], closestPoint, Infinity);
  return closestPoint;
};

/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} Contains coordinate.
 * @api
 */
_ol_geom_Geometry_.prototype.intersectsCoordinate = function (coordinate) {
  return this.containsXY(coordinate[0], coordinate[1]);
};

/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @protected
 * @return {ol.Extent} extent Extent.
 */
_ol_geom_Geometry_.prototype.computeExtent = function (extent) {};

/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_Geometry_.prototype.containsXY = _functions2.default.FALSE;

/**
 * Get the extent of the geometry.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} extent Extent.
 * @api
 */
_ol_geom_Geometry_.prototype.getExtent = function (opt_extent) {
  if (this.extentRevision_ != this.getRevision()) {
    this.extent_ = this.computeExtent(this.extent_);
    this.extentRevision_ = this.getRevision();
  }
  return _extent2.default.returnOrUpdate(this.extent_, opt_extent);
};

/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} angle Rotation angle in radians.
 * @param {ol.Coordinate} anchor The rotation center.
 * @api
 */
_ol_geom_Geometry_.prototype.rotate = function (angle, anchor) {};

/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} sx The scaling factor in the x-direction.
 * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
 *     sx).
 * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center
 *     of the geometry extent).
 * @api
 */
_ol_geom_Geometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {};

/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 * @function
 * @param {number} tolerance The tolerance distance for simplification.
 * @return {ol.geom.Geometry} A new, simplified version of the original
 *     geometry.
 * @api
 */
_ol_geom_Geometry_.prototype.simplify = function (tolerance) {
  return this.getSimplifiedGeometry(tolerance * tolerance);
};

/**
 * Create a simplified version of this geometry using the Douglas Peucker
 * algorithm.
 * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * @abstract
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.Geometry} Simplified geometry.
 */
_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {};

/**
 * Get the type of this geometry.
 * @abstract
 * @return {ol.geom.GeometryType} Geometry type.
 */
_ol_geom_Geometry_.prototype.getType = function () {};

/**
 * Apply a transform function to each coordinate of the geometry.
 * The geometry is modified in place.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * @abstract
 * @param {ol.TransformFunction} transformFn Transform.
 */
_ol_geom_Geometry_.prototype.applyTransform = function (transformFn) {};

/**
 * Test if the geometry and the passed extent intersect.
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @return {boolean} `true` if the geometry and the extent intersect.
 */
_ol_geom_Geometry_.prototype.intersectsExtent = function (extent) {};

/**
 * Translate the geometry.  This modifies the geometry coordinates in place.  If
 * instead you want a new geometry, first `clone()` this geometry.
 * @abstract
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 */
_ol_geom_Geometry_.prototype.translate = function (deltaX, deltaY) {};

/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 *
 * @param {ol.ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @param {ol.ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @return {ol.geom.Geometry} This geometry.  Note that original geometry is
 *     modified in place.
 * @api
 */
_ol_geom_Geometry_.prototype.transform = function (source, destination) {
  this.applyTransform(_proj2.default.getTransform(source, destination));
  return this;
};
exports.default = _ol_geom_Geometry_;


},{"../extent":68,"../functions":78,"../index":110,"../object":147,"../proj":158}],96:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometry = require('../geom/geometry');

var _geometry2 = _interopRequireDefault(_geometry);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * An array of {@link ol.geom.Geometry} objects.
 *
 * @constructor
 * @extends {ol.geom.Geometry}
 * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.
 * @api
 */
var _ol_geom_GeometryCollection_ = function (opt_geometries) {

  _geometry2.default.call(this);

  /**
   * @private
   * @type {Array.<ol.geom.Geometry>}
   */
  this.geometries_ = opt_geometries ? opt_geometries : null;

  this.listenGeometriesChange_();
};

_index2.default.inherits(_ol_geom_GeometryCollection_, _geometry2.default);

/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @private
 * @return {Array.<ol.geom.Geometry>} Cloned geometries.
 */
_ol_geom_GeometryCollection_.cloneGeometries_ = function (geometries) {
  var clonedGeometries = [];
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
};

/**
 * @private
 */
_ol_geom_GeometryCollection_.prototype.unlistenGeometriesChange_ = function () {
  var this$1 = this;

  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    _events2.default.unlisten(this$1.geometries_[i], _eventtype2.default.CHANGE, this$1.changed, this$1);
  }
};

/**
 * @private
 */
_ol_geom_GeometryCollection_.prototype.listenGeometriesChange_ = function () {
  var this$1 = this;

  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    _events2.default.listen(this$1.geometries_[i], _eventtype2.default.CHANGE, this$1.changed, this$1);
  }
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.GeometryCollection} Clone.
 * @override
 * @api
 */
_ol_geom_GeometryCollection_.prototype.clone = function () {
  var geometryCollection = new _ol_geom_GeometryCollection_(null);
  geometryCollection.setGeometries(this.geometries_);
  return geometryCollection;
};

/**
 * @inheritDoc
 */
_ol_geom_GeometryCollection_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
  }
  return minSquaredDistance;
};

/**
 * @inheritDoc
 */
_ol_geom_GeometryCollection_.prototype.containsXY = function (x, y) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].containsXY(x, y)) {
      return true;
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
_ol_geom_GeometryCollection_.prototype.computeExtent = function (extent) {
  _extent2.default.createOrUpdateEmpty(extent);
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    _extent2.default.extend(extent, geometries[i].getExtent());
  }
  return extent;
};

/**
 * Return the geometries that make up this geometry collection.
 * @return {Array.<ol.geom.Geometry>} Geometries.
 * @api
 */
_ol_geom_GeometryCollection_.prototype.getGeometries = function () {
  return _ol_geom_GeometryCollection_.cloneGeometries_(this.geometries_);
};

/**
 * @return {Array.<ol.geom.Geometry>} Geometries.
 */
_ol_geom_GeometryCollection_.prototype.getGeometriesArray = function () {
  return this.geometries_;
};

/**
 * @inheritDoc
 */
_ol_geom_GeometryCollection_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    _obj2.default.clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    var i, ii;
    for (i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new _ol_geom_GeometryCollection_(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_GeometryCollection_.prototype.getType = function () {
  return _geometrytype2.default.GEOMETRY_COLLECTION;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_GeometryCollection_.prototype.intersectsExtent = function (extent) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].intersectsExtent(extent)) {
      return true;
    }
  }
  return false;
};

/**
 * @return {boolean} Is empty.
 */
_ol_geom_GeometryCollection_.prototype.isEmpty = function () {
  return this.geometries_.length === 0;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_GeometryCollection_.prototype.rotate = function (angle, anchor) {
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].rotate(angle, anchor);
  }
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_GeometryCollection_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = _extent2.default.getCenter(this.getExtent());
  }
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].scale(sx, opt_sy, anchor);
  }
  this.changed();
};

/**
 * Set the geometries that make up this geometry collection.
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @api
 */
_ol_geom_GeometryCollection_.prototype.setGeometries = function (geometries) {
  this.setGeometriesArray(_ol_geom_GeometryCollection_.cloneGeometries_(geometries));
};

/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 */
_ol_geom_GeometryCollection_.prototype.setGeometriesArray = function (geometries) {
  this.unlistenGeometriesChange_();
  this.geometries_ = geometries;
  this.listenGeometriesChange_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_GeometryCollection_.prototype.applyTransform = function (transformFn) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].applyTransform(transformFn);
  }
  this.changed();
};

/**
 * Translate the geometry.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @override
 * @api
 */
_ol_geom_GeometryCollection_.prototype.translate = function (deltaX, deltaY) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].translate(deltaX, deltaY);
  }
  this.changed();
};

/**
 * @inheritDoc
 */
_ol_geom_GeometryCollection_.prototype.disposeInternal = function () {
  this.unlistenGeometriesChange_();
  _geometry2.default.prototype.disposeInternal.call(this);
};
exports.default = _ol_geom_GeometryCollection_;


},{"../events":62,"../events/eventtype":66,"../extent":68,"../geom/geometry":95,"../geom/geometrytype":98,"../index":110,"../obj":146}],97:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _ol_geom_GeometryLayout_ = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};

exports.default = _ol_geom_GeometryLayout_;


},{}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _ol_geom_GeometryType_ = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

exports.default = _ol_geom_GeometryType_;


},{}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _area = require('../geom/flat/area');

var _area2 = _interopRequireDefault(_area);

var _closest = require('../geom/flat/closest');

var _closest2 = _interopRequireDefault(_closest);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _simplify = require('../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_LinearRing_ = function (coordinates, opt_layout) {

  _simplegeometry2.default.call(this);

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_LinearRing_, _simplegeometry2.default);

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LinearRing} Clone.
 * @override
 * @api
 */
_ol_geom_LinearRing_.prototype.clone = function () {
  var linearRing = new _ol_geom_LinearRing_(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return linearRing;
};

/**
 * @inheritDoc
 */
_ol_geom_LinearRing_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return _closest2.default.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * Return the area of the linear ring on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
_ol_geom_LinearRing_.prototype.getArea = function () {
  return _area2.default.linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the coordinates of the linear ring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
_ol_geom_LinearRing_.prototype.getCoordinates = function () {
  return _inflate2.default.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * @inheritDoc
 */
_ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = _simplify2.default.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLinearRing = new _ol_geom_LinearRing_(null);
  simplifiedLinearRing.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates);
  return simplifiedLinearRing;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_LinearRing_.prototype.getType = function () {
  return _geometrytype2.default.LINEAR_RING;
};

/**
 * @inheritDoc
 */
_ol_geom_LinearRing_.prototype.intersectsExtent = function (extent) {};

/**
 * Set the coordinates of the linear ring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_LinearRing_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = _deflate2.default.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
_ol_geom_LinearRing_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
exports.default = _ol_geom_LinearRing_;


},{"../extent":68,"../geom/flat/area":79,"../geom/flat/closest":81,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/flat/simplify":92,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/simplegeometry":106,"../index":110}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _closest = require('../geom/flat/closest');

var _closest2 = _interopRequireDefault(_closest);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _interpolate = require('../geom/flat/interpolate');

var _interpolate2 = _interopRequireDefault(_interpolate);

var _intersectsextent = require('../geom/flat/intersectsextent');

var _intersectsextent2 = _interopRequireDefault(_intersectsextent);

var _length = require('../geom/flat/length');

var _length2 = _interopRequireDefault(_length);

var _segments = require('../geom/flat/segments');

var _segments2 = _interopRequireDefault(_segments);

var _simplify = require('../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_LineString_ = function (coordinates, opt_layout) {

  _simplegeometry2.default.call(this);

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.flatMidpoint_ = null;

  /**
   * @private
   * @type {number}
   */
  this.flatMidpointRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_LineString_, _simplegeometry2.default);

/**
 * Append the passed coordinate to the coordinates of the linestring.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @api
 */
_ol_geom_LineString_.prototype.appendCoordinate = function (coordinate) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = coordinate.slice();
  } else {
    _array2.default.extend(this.flatCoordinates, coordinate);
  }
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LineString} Clone.
 * @override
 * @api
 */
_ol_geom_LineString_.prototype.clone = function () {
  var lineString = new _ol_geom_LineString_(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return lineString;
};

/**
 * @inheritDoc
 */
_ol_geom_LineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return _closest2.default.getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};

/**
 * Iterate over each segment, calling the provided callback.
 * If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 *
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 * @api
 */
_ol_geom_LineString_.prototype.forEachSegment = function (callback, opt_this) {
  return _segments2.default.forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback, opt_this);
};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_geom_LineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
  if (this.layout != _geometrylayout2.default.XYM && this.layout != _geometrylayout2.default.XYZM) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  return _interpolate2.default.lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
};

/**
 * Return the coordinates of the linestring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
_ol_geom_LineString_.prototype.getCoordinates = function () {
  return _inflate2.default.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the coordinate at the provided fraction along the linestring.
 * The `fraction` is a number between 0 and 1, where 0 is the start of the
 * linestring and 1 is the end.
 * @param {number} fraction Fraction.
 * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will
 *     be modified. If not provided, a new coordinate will be returned.
 * @return {ol.Coordinate} Coordinate of the interpolated point.
 * @api
 */
_ol_geom_LineString_.prototype.getCoordinateAt = function (fraction, opt_dest) {
  return _interpolate2.default.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);
};

/**
 * Return the length of the linestring on projected plane.
 * @return {number} Length (on projected plane).
 * @api
 */
_ol_geom_LineString_.prototype.getLength = function () {
  return _length2.default.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * @return {Array.<number>} Flat midpoint.
 */
_ol_geom_LineString_.prototype.getFlatMidpoint = function () {
  if (this.flatMidpointRevision_ != this.getRevision()) {
    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
    this.flatMidpointRevision_ = this.getRevision();
  }
  return this.flatMidpoint_;
};

/**
 * @inheritDoc
 */
_ol_geom_LineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = _simplify2.default.douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLineString = new _ol_geom_LineString_(null);
  simplifiedLineString.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates);
  return simplifiedLineString;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_LineString_.prototype.getType = function () {
  return _geometrytype2.default.LINE_STRING;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_LineString_.prototype.intersectsExtent = function (extent) {
  return _intersectsextent2.default.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};

/**
 * Set the coordinates of the linestring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_LineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = _deflate2.default.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
_ol_geom_LineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
exports.default = _ol_geom_LineString_;


},{"../array":42,"../extent":68,"../geom/flat/closest":81,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/flat/interpolate":86,"../geom/flat/intersectsextent":87,"../geom/flat/length":88,"../geom/flat/segments":91,"../geom/flat/simplify":92,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/simplegeometry":106,"../index":110}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _linestring = require('../geom/linestring');

var _linestring2 = _interopRequireDefault(_linestring);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _closest = require('../geom/flat/closest');

var _closest2 = _interopRequireDefault(_closest);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _interpolate = require('../geom/flat/interpolate');

var _interpolate2 = _interopRequireDefault(_interpolate);

var _intersectsextent = require('../geom/flat/intersectsextent');

var _intersectsextent2 = _interopRequireDefault(_intersectsextent);

var _simplify = require('../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_MultiLineString_ = function (coordinates, opt_layout) {

  _simplegeometry2.default.call(this);

  /**
   * @type {Array.<number>}
   * @private
   */
  this.ends_ = [];

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_MultiLineString_, _simplegeometry2.default);

/**
 * Append the passed linestring to the multilinestring.
 * @param {ol.geom.LineString} lineString LineString.
 * @api
 */
_ol_geom_MultiLineString_.prototype.appendLineString = function (lineString) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = lineString.getFlatCoordinates().slice();
  } else {
    _array2.default.extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiLineString} Clone.
 * @override
 * @api
 */
_ol_geom_MultiLineString_.prototype.clone = function () {
  var multiLineString = new _ol_geom_MultiLineString_(null);
  multiLineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return multiLineString;
};

/**
 * @inheritDoc
 */
_ol_geom_MultiLineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return _closest2.default.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * `opt_interpolate` controls interpolation between consecutive LineStrings
 * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
 * will be linearly interpolated between the last coordinate of one LineString
 * and the first coordinate of the next LineString.  If `opt_interpolate` is
 * `false` then the function will return `null` for Ms falling between
 * LineStrings.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_geom_MultiLineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
  if (this.layout != _geometrylayout2.default.XYM && this.layout != _geometrylayout2.default.XYZM || this.flatCoordinates.length === 0) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
  return _interpolate2.default.lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
};

/**
 * Return the coordinates of the multilinestring.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */
_ol_geom_MultiLineString_.prototype.getCoordinates = function () {
  return _inflate2.default.coordinatess(this.flatCoordinates, 0, this.ends_, this.stride);
};

/**
 * @return {Array.<number>} Ends.
 */
_ol_geom_MultiLineString_.prototype.getEnds = function () {
  return this.ends_;
};

/**
 * Return the linestring at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.LineString} LineString.
 * @api
 */
_ol_geom_MultiLineString_.prototype.getLineString = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var lineString = new _linestring2.default(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return lineString;
};

/**
 * Return the linestrings of this multilinestring.
 * @return {Array.<ol.geom.LineString>} LineStrings.
 * @api
 */
_ol_geom_MultiLineString_.prototype.getLineStrings = function () {
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var layout = this.layout;
  /** @type {Array.<ol.geom.LineString>} */
  var lineStrings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var lineString = new _linestring2.default(null);
    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    lineStrings.push(lineString);
    offset = end;
  }
  return lineStrings;
};

/**
 * @return {Array.<number>} Flat midpoints.
 */
_ol_geom_MultiLineString_.prototype.getFlatMidpoints = function () {
  var midpoints = [];
  var flatCoordinates = this.flatCoordinates;
  var offset = 0;
  var ends = this.ends_;
  var stride = this.stride;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var midpoint = _interpolate2.default.lineString(flatCoordinates, offset, end, stride, 0.5);
    _array2.default.extend(midpoints, midpoint);
    offset = end;
  }
  return midpoints;
};

/**
 * @inheritDoc
 */
_ol_geom_MultiLineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = _simplify2.default.douglasPeuckers(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedMultiLineString = new _ol_geom_MultiLineString_(null);
  simplifiedMultiLineString.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedMultiLineString;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiLineString_.prototype.getType = function () {
  return _geometrytype2.default.MULTI_LINE_STRING;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiLineString_.prototype.intersectsExtent = function (extent) {
  return _intersectsextent2.default.lineStrings(this.flatCoordinates, 0, this.ends_, this.stride, extent);
};

/**
 * Set the coordinates of the multilinestring.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_MultiLineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = _deflate2.default.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */
_ol_geom_MultiLineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};

/**
 * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.
 */
_ol_geom_MultiLineString_.prototype.setLineStrings = function (lineStrings) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var ends = [];
  var i, ii;
  for (i = 0, ii = lineStrings.length; i < ii; ++i) {
    var lineString = lineStrings[i];
    if (i === 0) {
      layout = lineString.getLayout();
    }
    _array2.default.extend(flatCoordinates, lineString.getFlatCoordinates());
    ends.push(flatCoordinates.length);
  }
  this.setFlatCoordinates(layout, flatCoordinates, ends);
};
exports.default = _ol_geom_MultiLineString_;


},{"../array":42,"../extent":68,"../geom/flat/closest":81,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/flat/interpolate":86,"../geom/flat/intersectsextent":87,"../geom/flat/simplify":92,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/linestring":100,"../geom/simplegeometry":106,"../index":110}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _point = require('../geom/point');

var _point2 = _interopRequireDefault(_point);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Multi-point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_MultiPoint_ = function (coordinates, opt_layout) {
  _simplegeometry2.default.call(this);
  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_MultiPoint_, _simplegeometry2.default);

/**
 * Append the passed point to this multipoint.
 * @param {ol.geom.Point} point Point.
 * @api
 */
_ol_geom_MultiPoint_.prototype.appendPoint = function (point) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = point.getFlatCoordinates().slice();
  } else {
    _array2.default.extend(this.flatCoordinates, point.getFlatCoordinates());
  }
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPoint} Clone.
 * @override
 * @api
 */
_ol_geom_MultiPoint_.prototype.clone = function () {
  var multiPoint = new _ol_geom_MultiPoint_(null);
  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return multiPoint;
};

/**
 * @inheritDoc
 */
_ol_geom_MultiPoint_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, j;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var squaredDistance = _math2.default.squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (j = 0; j < stride; ++j) {
        closestPoint[j] = flatCoordinates[i + j];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};

/**
 * Return the coordinates of the multipoint.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
_ol_geom_MultiPoint_.prototype.getCoordinates = function () {
  return _inflate2.default.coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the point at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Point} Point.
 * @api
 */
_ol_geom_MultiPoint_.prototype.getPoint = function (index) {
  var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
  if (index < 0 || n <= index) {
    return null;
  }
  var point = new _point2.default(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride));
  return point;
};

/**
 * Return the points of this multipoint.
 * @return {Array.<ol.geom.Point>} Points.
 * @api
 */
_ol_geom_MultiPoint_.prototype.getPoints = function () {
  var flatCoordinates = this.flatCoordinates;
  var layout = this.layout;
  var stride = this.stride;
  /** @type {Array.<ol.geom.Point>} */
  var points = [];
  var i, ii;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var point = new _point2.default(null);
    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));
    points.push(point);
  }
  return points;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiPoint_.prototype.getType = function () {
  return _geometrytype2.default.MULTI_POINT;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiPoint_.prototype.intersectsExtent = function (extent) {
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, x, y;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    x = flatCoordinates[i];
    y = flatCoordinates[i + 1];
    if (_extent2.default.containsXY(extent, x, y)) {
      return true;
    }
  }
  return false;
};

/**
 * Set the coordinates of the multipoint.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_MultiPoint_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = _deflate2.default.coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
_ol_geom_MultiPoint_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
exports.default = _ol_geom_MultiPoint_;


},{"../array":42,"../extent":68,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/point":104,"../geom/simplegeometry":106,"../index":110,"../math":144}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _multipoint = require('../geom/multipoint');

var _multipoint2 = _interopRequireDefault(_multipoint);

var _polygon = require('../geom/polygon');

var _polygon2 = _interopRequireDefault(_polygon);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _area = require('../geom/flat/area');

var _area2 = _interopRequireDefault(_area);

var _center = require('../geom/flat/center');

var _center2 = _interopRequireDefault(_center);

var _closest = require('../geom/flat/closest');

var _closest2 = _interopRequireDefault(_closest);

var _contains = require('../geom/flat/contains');

var _contains2 = _interopRequireDefault(_contains);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _interiorpoint = require('../geom/flat/interiorpoint');

var _interiorpoint2 = _interopRequireDefault(_interiorpoint);

var _intersectsextent = require('../geom/flat/intersectsextent');

var _intersectsextent2 = _interopRequireDefault(_intersectsextent);

var _orient = require('../geom/flat/orient');

var _orient2 = _interopRequireDefault(_orient);

var _simplify = require('../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_MultiPolygon_ = function (coordinates, opt_layout) {

  _simplegeometry2.default.call(this);

  /**
   * @type {Array.<Array.<number>>}
   * @private
   */
  this.endss_ = [];

  /**
   * @private
   * @type {number}
   */
  this.flatInteriorPointsRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.flatInteriorPoints_ = null;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.orientedRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.orientedFlatCoordinates_ = null;

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_MultiPolygon_, _simplegeometry2.default);

/**
 * Append the passed polygon to this multipolygon.
 * @param {ol.geom.Polygon} polygon Polygon.
 * @api
 */
_ol_geom_MultiPolygon_.prototype.appendPolygon = function (polygon) {
  /** @type {Array.<number>} */
  var ends;
  if (!this.flatCoordinates) {
    this.flatCoordinates = polygon.getFlatCoordinates().slice();
    ends = polygon.getEnds().slice();
    this.endss_.push();
  } else {
    var offset = this.flatCoordinates.length;
    _array2.default.extend(this.flatCoordinates, polygon.getFlatCoordinates());
    ends = polygon.getEnds().slice();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] += offset;
    }
  }
  this.endss_.push(ends);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPolygon} Clone.
 * @override
 * @api
 */
_ol_geom_MultiPolygon_.prototype.clone = function () {
  var this$1 = this;

  var multiPolygon = new _ol_geom_MultiPolygon_(null);

  var len = this.endss_.length;
  var newEndss = new Array(len);
  for (var i = 0; i < len; ++i) {
    newEndss[i] = this$1.endss_[i].slice();
  }

  multiPolygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), newEndss);
  return multiPolygon;
};

/**
 * @inheritDoc
 */
_ol_geom_MultiPolygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getssMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return _closest2.default.getssClosestPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * @inheritDoc
 */
_ol_geom_MultiPolygon_.prototype.containsXY = function (x, y) {
  return _contains2.default.linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
};

/**
 * Return the area of the multipolygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getArea = function () {
  return _area2.default.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for multi-polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.
 * @override
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    _orient2.default.orientLinearRingss(flatCoordinates, 0, this.endss_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return _inflate2.default.coordinatesss(flatCoordinates, 0, this.endss_, this.stride);
};

/**
 * @return {Array.<Array.<number>>} Endss.
 */
_ol_geom_MultiPolygon_.prototype.getEndss = function () {
  return this.endss_;
};

/**
 * @return {Array.<number>} Flat interior points.
 */
_ol_geom_MultiPolygon_.prototype.getFlatInteriorPoints = function () {
  if (this.flatInteriorPointsRevision_ != this.getRevision()) {
    var flatCenters = _center2.default.linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
    this.flatInteriorPoints_ = _interiorpoint2.default.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
    this.flatInteriorPointsRevision_ = this.getRevision();
  }
  return this.flatInteriorPoints_;
};

/**
 * Return the interior points as {@link ol.geom.MultiPoint multipoint}.
 * @return {ol.geom.MultiPoint} Interior points.
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getInteriorPoints = function () {
  var interiorPoints = new _multipoint2.default(null);
  interiorPoints.setFlatCoordinates(_geometrylayout2.default.XY, this.getFlatInteriorPoints().slice());
  return interiorPoints;
};

/**
 * @return {Array.<number>} Oriented flat coordinates.
 */
_ol_geom_MultiPolygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (_orient2.default.linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = _orient2.default.orientLinearRingss(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};

/**
 * @inheritDoc
 */
_ol_geom_MultiPolygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEndss = [];
  simplifiedFlatCoordinates.length = _simplify2.default.quantizess(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
  var simplifiedMultiPolygon = new _ol_geom_MultiPolygon_(null);
  simplifiedMultiPolygon.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates, simplifiedEndss);
  return simplifiedMultiPolygon;
};

/**
 * Return the polygon at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Polygon} Polygon.
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getPolygon = function (index) {
  if (index < 0 || this.endss_.length <= index) {
    return null;
  }
  var offset;
  if (index === 0) {
    offset = 0;
  } else {
    var prevEnds = this.endss_[index - 1];
    offset = prevEnds[prevEnds.length - 1];
  }
  var ends = this.endss_[index].slice();
  var end = ends[ends.length - 1];
  if (offset !== 0) {
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] -= offset;
    }
  }
  var polygon = new _polygon2.default(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(offset, end), ends);
  return polygon;
};

/**
 * Return the polygons of this multipolygon.
 * @return {Array.<ol.geom.Polygon>} Polygons.
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getPolygons = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var endss = this.endss_;
  var polygons = [];
  var offset = 0;
  var i, ii, j, jj;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (j = 0, jj = ends.length; j < jj; ++j) {
        ends[j] -= offset;
      }
    }
    var polygon = new _polygon2.default(null);
    polygon.setFlatCoordinates(layout, flatCoordinates.slice(offset, end), ends);
    polygons.push(polygon);
    offset = end;
  }
  return polygons;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiPolygon_.prototype.getType = function () {
  return _geometrytype2.default.MULTI_POLYGON;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_MultiPolygon_.prototype.intersectsExtent = function (extent) {
  return _intersectsextent2.default.linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
};

/**
 * Set the coordinates of the multipolygon.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_MultiPolygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null, this.endss_);
  } else {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = _deflate2.default.coordinatesss(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} endss Endss.
 */
_ol_geom_MultiPolygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, endss) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.endss_ = endss;
  this.changed();
};

/**
 * @param {Array.<ol.geom.Polygon>} polygons Polygons.
 */
_ol_geom_MultiPolygon_.prototype.setPolygons = function (polygons) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var endss = [];
  var i, ii, ends;
  for (i = 0, ii = polygons.length; i < ii; ++i) {
    var polygon = polygons[i];
    if (i === 0) {
      layout = polygon.getLayout();
    }
    var offset = flatCoordinates.length;
    ends = polygon.getEnds();
    var j, jj;
    for (j = 0, jj = ends.length; j < jj; ++j) {
      ends[j] += offset;
    }
    _array2.default.extend(flatCoordinates, polygon.getFlatCoordinates());
    endss.push(ends);
  }
  this.setFlatCoordinates(layout, flatCoordinates, endss);
};
exports.default = _ol_geom_MultiPolygon_;


},{"../array":42,"../extent":68,"../geom/flat/area":79,"../geom/flat/center":80,"../geom/flat/closest":81,"../geom/flat/contains":82,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/flat/interiorpoint":85,"../geom/flat/intersectsextent":87,"../geom/flat/orient":89,"../geom/flat/simplify":92,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/multipoint":102,"../geom/polygon":105,"../geom/simplegeometry":106,"../index":110}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_Point_ = function (coordinates, opt_layout) {
  _simplegeometry2.default.call(this);
  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_Point_, _simplegeometry2.default);

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Point} Clone.
 * @override
 * @api
 */
_ol_geom_Point_.prototype.clone = function () {
  var point = new _ol_geom_Point_(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return point;
};

/**
 * @inheritDoc
 */
_ol_geom_Point_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;
  var squaredDistance = _math2.default.squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
  if (squaredDistance < minSquaredDistance) {
    var stride = this.stride;
    var i;
    for (i = 0; i < stride; ++i) {
      closestPoint[i] = flatCoordinates[i];
    }
    closestPoint.length = stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};

/**
 * Return the coordinate of the point.
 * @return {ol.Coordinate} Coordinates.
 * @override
 * @api
 */
_ol_geom_Point_.prototype.getCoordinates = function () {
  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
};

/**
 * @inheritDoc
 */
_ol_geom_Point_.prototype.computeExtent = function (extent) {
  return _extent2.default.createOrUpdateFromCoordinate(this.flatCoordinates, extent);
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.getType = function () {
  return _geometrytype2.default.POINT;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.intersectsExtent = function (extent) {
  return _extent2.default.containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = _deflate2.default.coordinate(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
_ol_geom_Point_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
exports.default = _ol_geom_Point_;


},{"../extent":68,"../geom/flat/deflate":83,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/simplegeometry":106,"../index":110,"../math":144}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _linearring = require('../geom/linearring');

var _linearring2 = _interopRequireDefault(_linearring);

var _point = require('../geom/point');

var _point2 = _interopRequireDefault(_point);

var _simplegeometry = require('../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _area = require('../geom/flat/area');

var _area2 = _interopRequireDefault(_area);

var _closest = require('../geom/flat/closest');

var _closest2 = _interopRequireDefault(_closest);

var _contains = require('../geom/flat/contains');

var _contains2 = _interopRequireDefault(_contains);

var _deflate = require('../geom/flat/deflate');

var _deflate2 = _interopRequireDefault(_deflate);

var _inflate = require('../geom/flat/inflate');

var _inflate2 = _interopRequireDefault(_inflate);

var _interiorpoint = require('../geom/flat/interiorpoint');

var _interiorpoint2 = _interopRequireDefault(_interiorpoint);

var _intersectsextent = require('../geom/flat/intersectsextent');

var _intersectsextent2 = _interopRequireDefault(_intersectsextent);

var _orient = require('../geom/flat/orient');

var _orient2 = _interopRequireDefault(_orient);

var _simplify = require('../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear
 *     rings that define the polygon. The first linear ring of the array
 *     defines the outer-boundary or surface of the polygon. Each subsequent
 *     linear ring defines a hole in the surface of the polygon. A linear ring
 *     is an array of vertices' coordinates where the first coordinate and the
 *     last are equivalent.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_Polygon_ = function (coordinates, opt_layout) {

  _simplegeometry2.default.call(this);

  /**
   * @type {Array.<number>}
   * @private
   */
  this.ends_ = [];

  /**
   * @private
   * @type {number}
   */
  this.flatInteriorPointRevision_ = -1;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.flatInteriorPoint_ = null;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.orientedRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.orientedFlatCoordinates_ = null;

  this.setCoordinates(coordinates, opt_layout);
};

_index2.default.inherits(_ol_geom_Polygon_, _simplegeometry2.default);

/**
 * Append the passed linear ring to this polygon.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @api
 */
_ol_geom_Polygon_.prototype.appendLinearRing = function (linearRing) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = linearRing.getFlatCoordinates().slice();
  } else {
    _array2.default.extend(this.flatCoordinates, linearRing.getFlatCoordinates());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Polygon} Clone.
 * @override
 * @api
 */
_ol_geom_Polygon_.prototype.clone = function () {
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return polygon;
};

/**
 * @inheritDoc
 */
_ol_geom_Polygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < _extent2.default.closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(_closest2.default.getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return _closest2.default.getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * @inheritDoc
 */
_ol_geom_Polygon_.prototype.containsXY = function (x, y) {
  return _contains2.default.linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
};

/**
 * Return the area of the polygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
_ol_geom_Polygon_.prototype.getArea = function () {
  return _area2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */
_ol_geom_Polygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    _orient2.default.orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return _inflate2.default.coordinatess(flatCoordinates, 0, this.ends_, this.stride);
};

/**
 * @return {Array.<number>} Ends.
 */
_ol_geom_Polygon_.prototype.getEnds = function () {
  return this.ends_;
};

/**
 * @return {Array.<number>} Interior point.
 */
_ol_geom_Polygon_.prototype.getFlatInteriorPoint = function () {
  if (this.flatInteriorPointRevision_ != this.getRevision()) {
    var flatCenter = _extent2.default.getCenter(this.getExtent());
    this.flatInteriorPoint_ = _interiorpoint2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
    this.flatInteriorPointRevision_ = this.getRevision();
  }
  return this.flatInteriorPoint_;
};

/**
 * Return an interior point of the polygon.
 * @return {ol.geom.Point} Interior point.
 * @api
 */
_ol_geom_Polygon_.prototype.getInteriorPoint = function () {
  return new _point2.default(this.getFlatInteriorPoint());
};

/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 *
 * @return {number} Number of rings.
 * @api
 */
_ol_geom_Polygon_.prototype.getLinearRingCount = function () {
  return this.ends_.length;
};

/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 *
 * @param {number} index Index.
 * @return {ol.geom.LinearRing} Linear ring.
 * @api
 */
_ol_geom_Polygon_.prototype.getLinearRing = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var linearRing = new _linearring2.default(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return linearRing;
};

/**
 * Return the linear rings of the polygon.
 * @return {Array.<ol.geom.LinearRing>} Linear rings.
 * @api
 */
_ol_geom_Polygon_.prototype.getLinearRings = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var linearRings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var linearRing = new _linearring2.default(null);
    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    linearRings.push(linearRing);
    offset = end;
  }
  return linearRings;
};

/**
 * @return {Array.<number>} Oriented flat coordinates.
 */
_ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (_orient2.default.linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = _orient2.default.orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};

/**
 * @inheritDoc
 */
_ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = _simplify2.default.quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedPolygon = new _ol_geom_Polygon_(null);
  simplifiedPolygon.setFlatCoordinates(_geometrylayout2.default.XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedPolygon;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Polygon_.prototype.getType = function () {
  return _geometrytype2.default.POLYGON;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Polygon_.prototype.intersectsExtent = function (extent) {
  return _intersectsextent2.default.linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
};

/**
 * Set the coordinates of the polygon.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
_ol_geom_Polygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(_geometrylayout2.default.XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = _deflate2.default.coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */
_ol_geom_Polygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};

/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {ol.Sphere} sphere The sphere.
 * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @return {ol.geom.Polygon} The "circular" polygon.
 * @api
 */
_ol_geom_Polygon_.circular = function (sphere, center, radius, opt_n) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array.<number>} */
  var flatCoordinates = [];
  var i;
  for (i = 0; i < n; ++i) {
    _array2.default.extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geometrylayout2.default.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {ol.Extent} extent The extent.
 * @return {ol.geom.Polygon} The polygon.
 * @api
 */
_ol_geom_Polygon_.fromExtent = function (extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  var polygon = new _ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(_geometrylayout2.default.XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};

/**
 * Create a regular polygon from a circle.
 * @param {ol.geom.Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {ol.geom.Polygon} Polygon geometry.
 * @api
 */
_ol_geom_Polygon_.fromCircle = function (circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var polygon = new _ol_geom_Polygon_(null, layout);
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i++) {
    flatCoordinates[i] = 0;
  }
  var ends = [flatCoordinates.length];
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
  _ol_geom_Polygon_.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);
  return polygon;
};

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {ol.Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */
_ol_geom_Polygon_.makeRegular = function (polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var layout = polygon.getLayout();
  var stride = polygon.getStride();
  var ends = polygon.getEnds();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  var angle, offset;
  for (var i = 0; i <= sides; ++i) {
    offset = i * stride;
    angle = startAngle + _math2.default.modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
};
exports.default = _ol_geom_Polygon_;


},{"../array":42,"../extent":68,"../geom/flat/area":79,"../geom/flat/closest":81,"../geom/flat/contains":82,"../geom/flat/deflate":83,"../geom/flat/inflate":84,"../geom/flat/interiorpoint":85,"../geom/flat/intersectsextent":87,"../geom/flat/orient":89,"../geom/flat/simplify":92,"../geom/geometrylayout":97,"../geom/geometrytype":98,"../geom/linearring":99,"../geom/point":104,"../geom/simplegeometry":106,"../index":110,"../math":144}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometry = require('../geom/geometry');

var _geometry2 = _interopRequireDefault(_geometry);

var _geometrylayout = require('../geom/geometrylayout');

var _geometrylayout2 = _interopRequireDefault(_geometrylayout);

var _transform = require('../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @constructor
 * @abstract
 * @extends {ol.geom.Geometry}
 * @api
 */
var _ol_geom_SimpleGeometry_ = function () {

  _geometry2.default.call(this);

  /**
   * @protected
   * @type {ol.geom.GeometryLayout}
   */
  this.layout = _geometrylayout2.default.XY;

  /**
   * @protected
   * @type {number}
   */
  this.stride = 2;

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.flatCoordinates = null;
};

_index2.default.inherits(_ol_geom_SimpleGeometry_, _geometry2.default);

/**
 * @param {number} stride Stride.
 * @private
 * @return {ol.geom.GeometryLayout} layout Layout.
 */
_ol_geom_SimpleGeometry_.getLayoutForStride_ = function (stride) {
  var layout;
  if (stride == 2) {
    layout = _geometrylayout2.default.XY;
  } else if (stride == 3) {
    layout = _geometrylayout2.default.XYZ;
  } else if (stride == 4) {
    layout = _geometrylayout2.default.XYZM;
  }
  return (/** @type {ol.geom.GeometryLayout} */layout
  );
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
_ol_geom_SimpleGeometry_.getStrideForLayout = function (layout) {
  var stride;
  if (layout == _geometrylayout2.default.XY) {
    stride = 2;
  } else if (layout == _geometrylayout2.default.XYZ || layout == _geometrylayout2.default.XYM) {
    stride = 3;
  } else if (layout == _geometrylayout2.default.XYZM) {
    stride = 4;
  }
  return (/** @type {number} */stride
  );
};

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.containsXY = _functions2.default.FALSE;

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.computeExtent = function (extent) {
  return _extent2.default.createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};

/**
 * @abstract
 * @return {Array} Coordinates.
 */
_ol_geom_SimpleGeometry_.prototype.getCoordinates = function () {};

/**
 * Return the first coordinate of the geometry.
 * @return {ol.Coordinate} First coordinate.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate = function () {
  return this.flatCoordinates.slice(0, this.stride);
};

/**
 * @return {Array.<number>} Flat coordinates.
 */
_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates = function () {
  return this.flatCoordinates;
};

/**
 * Return the last coordinate of the geometry.
 * @return {ol.Coordinate} Last point.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getLastCoordinate = function () {
  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
};

/**
 * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
 * @return {ol.geom.GeometryLayout} Layout.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getLayout = function () {
  return this.layout;
};

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    _obj2.default.clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  // If squaredTolerance is negative or if we know that simplification will not
  // have any effect then just return this.
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      this.simplifiedGeometryCache[key] = simplifiedGeometry;
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};

/**
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.SimpleGeometry} Simplified geometry.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  return this;
};

/**
 * @return {number} Stride.
 */
_ol_geom_SimpleGeometry_.prototype.getStride = function () {
  return this.stride;
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal = function (layout, flatCoordinates) {
  this.stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  this.layout = layout;
  this.flatCoordinates = flatCoordinates;
};

/**
 * @abstract
 * @param {Array} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 */
_ol_geom_SimpleGeometry_.prototype.setCoordinates = function (coordinates, opt_layout) {};

/**
 * @param {ol.geom.GeometryLayout|undefined} layout Layout.
 * @param {Array} coordinates Coordinates.
 * @param {number} nesting Nesting.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.setLayout = function (layout, coordinates, nesting) {
  var this$1 = this;

  /** @type {number} */
  var stride;
  if (layout) {
    stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  } else {
    var i;
    for (i = 0; i < nesting; ++i) {
      if (coordinates.length === 0) {
        this$1.layout = _geometrylayout2.default.XY;
        this$1.stride = 2;
        return;
      } else {
        coordinates = /** @type {Array} */coordinates[0];
      }
    }
    stride = coordinates.length;
    layout = _ol_geom_SimpleGeometry_.getLayoutForStride_(stride);
  }
  this.layout = layout;
  this.stride = stride;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.applyTransform = function (transformFn) {
  if (this.flatCoordinates) {
    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.rotate = function (angle, anchor) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    _transform2.default.rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var sy = opt_sy;
  if (sy === undefined) {
    sy = sx;
  }
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = _extent2.default.getCenter(this.getExtent());
  }
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    _transform2.default.scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.translate = function (deltaX, deltaY) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
    this.changed();
  }
};

/**
 * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */
_ol_geom_SimpleGeometry_.transform2D = function (simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return _transform2.default.transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
};
exports.default = _ol_geom_SimpleGeometry_;


},{"../extent":68,"../functions":78,"../geom/flat/transform":94,"../geom/geometry":95,"../geom/geometrylayout":97,"../index":110,"../obj":146}],107:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _webgl = require('./webgl');

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_has_ = {};

var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
_ol_has_.MAC = ua.indexOf('macintosh') !== -1;

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
_ol_has_.DEVICE_PIXEL_RATIO = window.devicePixelRatio || 1;

/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
_ol_has_.CANVAS_LINE_DASH = false;

/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.CANVAS = _index2.default.ENABLE_CANVAS &&
/**
 * @return {boolean} Canvas supported.
 */
function () {
  if (!('HTMLCanvasElement' in window)) {
    return false;
  }
  try {
    var context = document.createElement('CANVAS').getContext('2d');
    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        _ol_has_.CANVAS_LINE_DASH = true;
      }
      return true;
    }
  } catch (e) {
    return false;
  }
}();

/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.DEVICE_ORIENTATION = 'DeviceOrientationEvent' in window;

/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.GEOLOCATION = 'geolocation' in navigator;

/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.TOUCH = _index2.default.ASSUME_TOUCH || 'ontouchstart' in window;

/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
_ol_has_.POINTER = 'PointerEvent' in window;

/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
_ol_has_.MSPOINTER = !!navigator.msPointerEnabled;

/**
 * True if both OpenLayers and browser support WebGL.  Always `false`
 * if `ol.ENABLE_WEBGL` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.WEBGL;

(function () {
  if (false) {
    var hasWebGL = false;
    var textureSize;
    var /** @type {Array.<string>} */extensions = [];

    if ('WebGLRenderingContext' in window) {
      try {
        var canvas = /** @type {HTMLCanvasElement} */
        document.createElement('CANVAS');
        var gl = _webgl2.default.getContext(canvas, {
          failIfMajorPerformanceCaveat: true
        });
        if (gl) {
          hasWebGL = true;
          textureSize = /** @type {number} */
          gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {
        // pass
      }
    }
    _ol_has_.WEBGL = hasWebGL;
    _index2.default.WEBGL_EXTENSIONS = extensions;
    _index2.default.WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();
exports.default = _ol_has_;


},{"./index":110,"./webgl":260}],108:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 */
var _ol_ImageState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};

exports.default = _ol_ImageState_;


},{}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _tile = require('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _tilestate = require('./tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 */
var _ol_ImageTile_ = function (tileCoord, state, src, crossOrigin, tileLoadFunction) {

  _tile2.default.call(this, tileCoord, state);

  /**
   * Image URI
   *
   * @private
   * @type {string}
   */
  this.src_ = src;

  /**
   * @private
   * @type {Image}
   */
  this.image_ = new Image();
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {ol.TileLoadFunctionType}
   */
  this.tileLoadFunction_ = tileLoadFunction;
};

_index2.default.inherits(_ol_ImageTile_, _tile2.default);

/**
 * @inheritDoc
 */
_ol_ImageTile_.prototype.disposeInternal = function () {
  if (this.state == _tilestate2.default.LOADING) {
    this.unlistenImage_();
  }
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = _tilestate2.default.ABORT;
  this.changed();
  _tile2.default.prototype.disposeInternal.call(this);
};

/**
 * Get the image element for this tile.
 * @inheritDoc
 * @api
 */
_ol_ImageTile_.prototype.getImage = function () {
  return this.image_;
};

/**
 * @inheritDoc
 */
_ol_ImageTile_.prototype.getKey = function () {
  return this.src_;
};

/**
 * Tracks loading or read errors.
 *
 * @private
 */
_ol_ImageTile_.prototype.handleImageError_ = function () {
  this.state = _tilestate2.default.ERROR;
  this.unlistenImage_();
  this.changed();
};

/**
 * Tracks successful image load.
 *
 * @private
 */
_ol_ImageTile_.prototype.handleImageLoad_ = function () {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = _tilestate2.default.LOADED;
  } else {
    this.state = _tilestate2.default.EMPTY;
  }
  this.unlistenImage_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
_ol_ImageTile_.prototype.load = function () {
  if (this.state == _tilestate2.default.IDLE || this.state == _tilestate2.default.ERROR) {
    this.state = _tilestate2.default.LOADING;
    this.changed();
    this.imageListenerKeys_ = [_events2.default.listenOnce(this.image_, _eventtype2.default.ERROR, this.handleImageError_, this), _events2.default.listenOnce(this.image_, _eventtype2.default.LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
_ol_ImageTile_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.imageListenerKeys_ = null;
};
exports.default = _ol_ImageTile_;


},{"./events":62,"./events/eventtype":66,"./index":110,"./tile":245,"./tilestate":252}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_ = {};

/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 */

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */
_ol_.ASSUME_TOUCH = false;

/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */
_ol_.DEFAULT_MAX_ZOOM = 42;

/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */
_ol_.DEFAULT_MIN_ZOOM = 0;

/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */
_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;

/**
 * @define {number} Default tile size.
 */
_ol_.DEFAULT_TILE_SIZE = 256;

/**
 * @define {string} Default WMS version.
 */
_ol_.DEFAULT_WMS_VERSION = '1.3.0';

/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */
_ol_.ENABLE_CANVAS = true;

/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */
_ol_.ENABLE_PROJ4JS = true;

/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */
_ol_.ENABLE_RASTER_REPROJECTION = true;

/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */
_ol_.ENABLE_WEBGL = true;

/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */
_ol_.DEBUG_WEBGL = true;

/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */
_ol_.INITIAL_ATLAS_SIZE = 256;

/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */
_ol_.MAX_ATLAS_SIZE = -1;

/**
 * @define {number} Maximum mouse wheel delta.
 */
_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;

/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */
_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;

/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */
_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;

/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */
_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;

/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */
_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;

/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */
_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */
_ol_.SIMPLIFY_TOLERANCE = 0.5;

/**
 * @define {number} Texture cache high water mark.
 */
_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;

/**
 * @define {string} OpenLayers version.
 */
_ol_.VERSION = '4.1.1';

/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @const
 * @type {number|undefined}
 */
_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`


/**
 * List of supported WebGL extensions.
 * @const
 * @type {Array.<string>}
 */
_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */
_ol_.inherits = function (childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
_ol_.nullFunction = function () {};

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
_ol_.getUid = function (obj) {
  return obj.ol_uid || (obj.ol_uid = ++_ol_.uidCounter_);
};

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
_ol_.uidCounter_ = 0;
exports.default = _ol_;


},{}],111:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _kinetic = require('./kinetic');

var _kinetic2 = _interopRequireDefault(_kinetic);

var _doubleclickzoom = require('./interaction/doubleclickzoom');

var _doubleclickzoom2 = _interopRequireDefault(_doubleclickzoom);

var _dragpan = require('./interaction/dragpan');

var _dragpan2 = _interopRequireDefault(_dragpan);

var _dragrotate = require('./interaction/dragrotate');

var _dragrotate2 = _interopRequireDefault(_dragrotate);

var _dragzoom = require('./interaction/dragzoom');

var _dragzoom2 = _interopRequireDefault(_dragzoom);

var _keyboardpan = require('./interaction/keyboardpan');

var _keyboardpan2 = _interopRequireDefault(_keyboardpan);

var _keyboardzoom = require('./interaction/keyboardzoom');

var _keyboardzoom2 = _interopRequireDefault(_keyboardzoom);

var _mousewheelzoom = require('./interaction/mousewheelzoom');

var _mousewheelzoom2 = _interopRequireDefault(_mousewheelzoom);

var _pinchrotate = require('./interaction/pinchrotate');

var _pinchrotate2 = _interopRequireDefault(_pinchrotate);

var _pinchzoom = require('./interaction/pinchzoom');

var _pinchzoom2 = _interopRequireDefault(_pinchzoom);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_interaction_ = {};

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link ol.interaction.Interaction} instances and insert them into a
 * {@link ol.Collection} in the order you want before creating your
 * {@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {@link ol.interaction.DragRotate}
 * * {@link ol.interaction.DoubleClickZoom}
 * * {@link ol.interaction.DragPan}
 * * {@link ol.interaction.PinchRotate}
 * * {@link ol.interaction.PinchZoom}
 * * {@link ol.interaction.KeyboardPan}
 * * {@link ol.interaction.KeyboardZoom}
 * * {@link ol.interaction.MouseWheelZoom}
 * * {@link ol.interaction.DragZoom}
 *
 * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.interaction.Interaction>} A collection of
 * interactions to be used with the ol.Map constructor's interactions option.
 * @api
 */
_ol_interaction_.defaults = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var interactions = new _collection2.default();

  var kinetic = new _kinetic2.default(-0.005, 0.05, 100);

  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new _dragrotate2.default());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new _doubleclickzoom2.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new _dragpan2.default({
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new _pinchrotate2.default());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new _pinchzoom2.default({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new _keyboardpan2.default());
    interactions.push(new _keyboardzoom2.default({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new _mousewheelzoom2.default({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new _dragzoom2.default({
      duration: options.zoomDuration
    }));
  }

  return interactions;
};
exports.default = _ol_interaction_;


},{"./collection":47,"./interaction/doubleclickzoom":112,"./interaction/dragpan":114,"./interaction/dragrotate":115,"./interaction/dragzoom":116,"./interaction/keyboardpan":118,"./interaction/keyboardzoom":119,"./interaction/mousewheelzoom":120,"./interaction/pinchrotate":121,"./interaction/pinchzoom":122,"./kinetic":125}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _mapbrowsereventtype = require('../mapbrowsereventtype');

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DoubleClickZoom_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {number}
   */
  this.delta_ = options.delta ? options.delta : 1;

  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_DoubleClickZoom_.handleEvent
  });

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_DoubleClickZoom_, _interaction2.default);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.DoubleClickZoom}
 * @api
 */
_ol_interaction_DoubleClickZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;
  if (mapBrowserEvent.type == _mapbrowsereventtype2.default.DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    _interaction2.default.zoomByDelta(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
};
exports.default = _ol_interaction_DoubleClickZoom_;


},{"../index":110,"../interaction/interaction":117,"../mapbrowsereventtype":139}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _pointer = require('../interaction/pointer');

var _pointer2 = _interopRequireDefault(_pointer);

var _box = require('../render/box');

var _box2 = _interopRequireDefault(_box);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link ol.interaction.DragZoom} and
 * {@link ol.interaction.DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.DragBox.Event
 * @param {olx.interaction.DragBoxOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragBox_ = function (opt_options) {

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @type {ol.render.Box}
   * @private
   */
  this.box_ = new _box2.default(options.className || 'ol-dragbox');

  /**
   * @type {number}
   * @private
   */
  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

  /**
   * @type {ol.Pixel}
   * @private
   */
  this.startPixel_ = null;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : _condition2.default.always;

  /**
   * @private
   * @type {ol.DragBoxEndConditionType}
   */
  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;
}; // FIXME draw drag box


_index2.default.inherits(_ol_interaction_DragBox_, _pointer2.default);

/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {ol.Pixel} startPixel The starting pixel of the box.
 * @param {ol.Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {ol.interaction.DragBox}
 */
_ol_interaction_DragBox_.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */
_ol_interaction_DragBox_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return;
  }

  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

  this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
};

/**
 * Returns geometry of last drawn box.
 * @return {ol.geom.Polygon} Geometry.
 * @api
 */
_ol_interaction_DragBox_.prototype.getGeometry = function () {
  return this.box_.getGeometry();
};

/**
 * To be overriden by child classes.
 * FIXME: use constructor option instead of relying on overridding.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @protected
 */
_ol_interaction_DragBox_.prototype.onBoxEnd = _index2.default.nullFunction;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */
_ol_interaction_DragBox_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return true;
  }

  this.box_.setMap(null);

  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd(mapBrowserEvent);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
  }
  return false;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */
_ol_interaction_DragBox_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_condition2.default.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new _ol_interaction_DragBox_.Event(_ol_interaction_DragBox_.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
};

/**
 * @enum {string}
 * @private
 */
_ol_interaction_DragBox_.EventType_ = {
  /**
   * Triggered upon drag box start.
   * @event ol.interaction.DragBox.Event#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event ol.interaction.DragBox.Event#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event ol.interaction.DragBox.Event#boxend
   * @api
   */
  BOXEND: 'boxend'
};

/**
 * @classdesc
 * Events emitted by {@link ol.interaction.DragBox} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {ol.Coordinate} coordinate The event coordinate.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.
 * @extends {ol.events.Event}
 * @constructor
 * @implements {oli.DragBoxEvent}
 */
_ol_interaction_DragBox_.Event = function (type, coordinate, mapBrowserEvent) {
  _event2.default.call(this, type);

  /**
   * The coordinate of the drag event.
   * @const
   * @type {ol.Coordinate}
   * @api
   */
  this.coordinate = coordinate;

  /**
   * @const
   * @type {ol.MapBrowserEvent}
   * @api
   */
  this.mapBrowserEvent = mapBrowserEvent;
};
_index2.default.inherits(_ol_interaction_DragBox_.Event, _event2.default);
exports.default = _ol_interaction_DragBox_;


},{"../events/condition":63,"../events/event":64,"../index":110,"../interaction/pointer":123,"../render/box":166}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _coordinate = require('../coordinate');

var _coordinate2 = _interopRequireDefault(_coordinate);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _pointer = require('../interaction/pointer');

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragPanOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragPan_ = function (opt_options) {

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragPan_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragPan_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragPan_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {ol.Kinetic|undefined}
   */
  this.kinetic_ = options.kinetic;

  /**
   * @type {ol.Pixel}
   */
  this.lastCentroid = null;

  /**
   * @type {number}
   */
  this.lastPointersCount_;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : _condition2.default.noModifierKeys;

  /**
   * @private
   * @type {boolean}
   */
  this.noKinetic_ = false;
};

_index2.default.inherits(_ol_interaction_DragPan_, _pointer2.default);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragPan}
 * @private
 */
_ol_interaction_DragPan_.handleDragEvent_ = function (mapBrowserEvent) {
  var targetPointers = this.targetPointers;
  var centroid = _pointer2.default.centroid(targetPointers);
  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }
    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var viewState = view.getState();
      var center = [deltaX, deltaY];
      _coordinate2.default.scale(center, viewState.resolution);
      _coordinate2.default.rotate(center, viewState.rotation);
      _coordinate2.default.add(center, viewState.center);
      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else if (this.kinetic_) {
    // reset so we don't overestimate the kinetic energy after
    // after one finger down, tiny drag, second finger down
    this.kinetic_.begin();
  }
  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */
_ol_interaction_DragPan_.handleUpEvent_ = function (mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center = /** @type {!ol.Coordinate} */view.getCenter();
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
      view.animate({
        center: view.constrainCenter(dest),
        duration: 500,
        easing: _easing2.default.easeOut
      });
    }
    view.setHint(_viewhint2.default.INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */
_ol_interaction_DragPan_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;
    if (!this.handlingDownUpSequence) {
      view.setHint(_viewhint2.default.INTERACTING, 1);
    }
    // stop any current animation
    if (view.getHints()[_viewhint2.default.ANIMATING]) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    // No kinetic as soon as more than one pointer on the screen is
    // detected. This is to prevent nasty pans after pinch.
    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
_ol_interaction_DragPan_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_DragPan_;


},{"../coordinate":57,"../easing":61,"../events/condition":63,"../functions":78,"../index":110,"../interaction/pointer":123,"../viewhint":258}],115:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require('../interaction/pointer');

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragRotate_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_DragRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragRotate_.handleUpEvent_
  });

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : _condition2.default.altShiftKeysOnly;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastAngle_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_DragRotate_, _pointer2.default);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotate}
 * @private
 */
_ol_interaction_DragRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var view = map.getView();
    var rotation = view.getRotation();
    _interaction2.default.rotateWithoutConstraints(view, rotation - delta);
  }
  this.lastAngle_ = theta;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */
_ol_interaction_DragRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(_viewhint2.default.INTERACTING, -1);
  var rotation = view.getRotation();
  _interaction2.default.rotate(view, rotation, undefined, this.duration_);
  return false;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */
_ol_interaction_DragRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!_condition2.default.mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (_condition2.default.mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
_ol_interaction_DragRotate_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_DragRotate_;


},{"../events/condition":63,"../functions":78,"../index":110,"../interaction/interaction":117,"../interaction/pointer":123,"../viewhint":258}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _dragbox = require('../interaction/dragbox');

var _dragbox2 = _interopRequireDefault(_dragbox);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_DragZoom_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  var condition = options.condition ? options.condition : _condition2.default.shiftKeyOnly;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 200;

  /**
   * @private
   * @type {boolean}
   */
  this.out_ = options.out !== undefined ? options.out : false;

  _dragbox2.default.call(this, {
    condition: condition,
    className: options.className || 'ol-dragzoom'
  });
};

_index2.default.inherits(_ol_interaction_DragZoom_, _dragbox2.default);

/**
 * @inheritDoc
 */
_ol_interaction_DragZoom_.prototype.onBoxEnd = function () {
  var map = this.getMap();

  var view = /** @type {!ol.View} */map.getView();

  var size = /** @type {!ol.Size} */map.getSize();

  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = _extent2.default.createOrUpdateFromCoordinates([map.getPixelFromCoordinate(_extent2.default.getBottomLeft(extent)), map.getPixelFromCoordinate(_extent2.default.getTopRight(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    _extent2.default.scaleFromCenter(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));

  var center = _extent2.default.getCenter(extent);
  center = view.constrainCenter(center);

  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: _easing2.default.easeOut
  });
};
exports.default = _ol_interaction_DragZoom_;


},{"../easing":61,"../events/condition":63,"../extent":68,"../index":110,"../interaction/dragbox":113}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

var _property = require('../interaction/property');

var _property2 = _interopRequireDefault(_property);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as
 * {@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 *
 * @constructor
 * @param {olx.interaction.InteractionOptions} options Options.
 * @extends {ol.Object}
 * @api
 */
// FIXME factor out key precondition (shift et. al)

var _ol_interaction_Interaction_ = function (options) {

  _object2.default.call(this);

  /**
   * @private
   * @type {ol.Map}
   */
  this.map_ = null;

  this.setActive(true);

  /**
   * @type {function(ol.MapBrowserEvent):boolean}
   */
  this.handleEvent = options.handleEvent;
};

_index2.default.inherits(_ol_interaction_Interaction_, _object2.default);

/**
 * Return whether the interaction is currently active.
 * @return {boolean} `true` if the interaction is active, `false` otherwise.
 * @observable
 * @api
 */
_ol_interaction_Interaction_.prototype.getActive = function () {
  return (/** @type {boolean} */this.get(_property2.default.ACTIVE)
  );
};

/**
 * Get the map associated with this interaction.
 * @return {ol.Map} Map.
 * @api
 */
_ol_interaction_Interaction_.prototype.getMap = function () {
  return this.map_;
};

/**
 * Activate or deactivate the interaction.
 * @param {boolean} active Active.
 * @observable
 * @api
 */
_ol_interaction_Interaction_.prototype.setActive = function (active) {
  this.set(_property2.default.ACTIVE, active);
};

/**
 * Remove the interaction from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.Map} map Map.
 */
_ol_interaction_Interaction_.prototype.setMap = function (map) {
  this.map_ = map;
};

/**
 * @param {ol.View} view View.
 * @param {ol.Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */
_ol_interaction_Interaction_.pan = function (view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: _easing2.default.linear,
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
_ol_interaction_Interaction_.rotate = function (view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  _ol_interaction_Interaction_.rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
_ol_interaction_Interaction_.rotateWithoutConstraints = function (view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing2.default.easeOut
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */
_ol_interaction_Interaction_.zoom = function (view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
_ol_interaction_Interaction_.zoomByDelta = function (view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);

    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];
  }

  _ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
_ol_interaction_Interaction_.zoomWithoutConstraints = function (view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: _easing2.default.easeOut
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
};
exports.default = _ol_interaction_Interaction_;


},{"../easing":61,"../index":110,"../interaction/property":124,"../object":147}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _coordinate = require('../coordinate');

var _coordinate2 = _interopRequireDefault(_coordinate);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _keycode = require('../events/keycode');

var _keycode2 = _interopRequireDefault(_keycode);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardZoom}.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_KeyboardPan_ = function (opt_options) {

  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_KeyboardPan_.handleEvent
  });

  var options = opt_options || {};

  /**
   * @private
   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.
   * @return {boolean} Combined condition result.
   */
  this.defaultCondition_ = function (mapBrowserEvent) {
    return _condition2.default.noModifierKeys(mapBrowserEvent) && _condition2.default.targetNotEditable(mapBrowserEvent);
  };

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 100;

  /**
   * @private
   * @type {number}
   */
  this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
};

_index2.default.inherits(_ol_interaction_KeyboardPan_, _interaction2.default);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardPan}
 * @api
 */
_ol_interaction_KeyboardPan_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _eventtype2.default.KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) && (keyCode == _keycode2.default.DOWN || keyCode == _keycode2.default.LEFT || keyCode == _keycode2.default.RIGHT || keyCode == _keycode2.default.UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0,
          deltaY = 0;
      if (keyCode == _keycode2.default.DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == _keycode2.default.LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == _keycode2.default.RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }
      var delta = [deltaX, deltaY];
      _coordinate2.default.rotate(delta, view.getRotation());
      _interaction2.default.pan(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
exports.default = _ol_interaction_KeyboardPan_;


},{"../coordinate":57,"../events/condition":63,"../events/eventtype":66,"../events/keycode":67,"../index":110,"../interaction/interaction":117}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _condition = require('../events/condition');

var _condition2 = _interopRequireDefault(_condition);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardPan}.
 *
 * @constructor
 * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var _ol_interaction_KeyboardZoom_ = function (opt_options) {

  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_KeyboardZoom_.handleEvent
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : _condition2.default.targetNotEditable;

  /**
   * @private
   * @type {number}
   */
  this.delta_ = options.delta ? options.delta : 1;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 100;
};

_index2.default.inherits(_ol_interaction_KeyboardZoom_, _interaction2.default);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardZoom}
 * @api
 */
_ol_interaction_KeyboardZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == _eventtype2.default.KEYDOWN || mapBrowserEvent.type == _eventtype2.default.KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();
      _interaction2.default.zoomByDelta(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
exports.default = _ol_interaction_KeyboardZoom_;


},{"../events/condition":63,"../events/eventtype":66,"../index":110,"../interaction/interaction":117}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _easing = require('../easing');

var _easing2 = _interopRequireDefault(_easing);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _has = require('../has');

var _has2 = _interopRequireDefault(_has);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_MouseWheelZoom_ = function (opt_options) {

  _interaction2.default.call(this, {
    handleEvent: _ol_interaction_MouseWheelZoom_.handleEvent
  });

  var options = opt_options || {};

  /**
   * @private
   * @type {number}
   */
  this.delta_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;

  /**
   * @private
   * @type {number}
   */
  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

  /**
   * @private
   * @type {boolean}
   */
  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

  /**
   * @private
   * @type {boolean}
   */
  this.constrainResolution_ = options.constrainResolution || false;

  /**
   * @private
   * @type {?ol.Coordinate}
   */
  this.lastAnchor_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.startTime_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.timeoutId_ = undefined;

  /**
   * @private
   * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}
   */
  this.mode_ = undefined;

  /**
   * Trackpad events separated by this delay will be considered separate
   * interactions.
   * @type {number}
   */
  this.trackpadEventGap_ = 400;

  /**
   * @type {number|undefined}
   */
  this.trackpadTimeoutId_ = undefined;

  /**
   * The number of delta values per zoom level
   * @private
   * @type {number}
   */
  this.trackpadDeltaPerZoom_ = 300;

  /**
   * The zoom factor by which scroll zooming is allowed to exceed the limits.
   * @private
   * @type {number}
   */
  this.trackpadZoomBuffer_ = 1.5;
};

_index2.default.inherits(_ol_interaction_MouseWheelZoom_, _interaction2.default);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {ol.interaction.MouseWheelZoom}
 * @api
 */
_ol_interaction_MouseWheelZoom_.handleEvent = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  if (type !== _eventtype2.default.WHEEL && type !== _eventtype2.default.MOUSEWHEEL) {
    return true;
  }

  mapBrowserEvent.preventDefault();

  var map = mapBrowserEvent.map;
  var wheelEvent = /** @type {WheelEvent} */mapBrowserEvent.originalEvent;

  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  }

  // Delta normalisation inspired by
  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
  var delta;
  if (mapBrowserEvent.type == _eventtype2.default.WHEEL) {
    delta = wheelEvent.deltaY;
    if (_has2.default.FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= _has2.default.DEVICE_PIXEL_RATIO;
    }
    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else if (mapBrowserEvent.type == _eventtype2.default.MOUSEWHEEL) {
    delta = -wheelEvent.wheelDeltaY;
    if (_has2.default.SAFARI) {
      delta /= 3;
    }
  }

  if (delta === 0) {
    return false;
  }

  var now = Date.now();

  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }

  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ? _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD : _ol_interaction_MouseWheelZoom_.Mode_.WHEEL;
  }

  if (this.mode_ === _ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD) {
    var view = map.getView();
    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(_viewhint2.default.INTERACTING, 1);
    }
    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;
    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else if (resolution > maxResolution) {
      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
      rebound = -1;
    }
    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }
    view.setResolution(resolution);

    if (rebound === 0 && this.constrainResolution_) {
      view.animate({
        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: this.duration_
      });
    }

    if (rebound > 0) {
      view.animate({
        resolution: minResolution,
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    } else if (rebound < 0) {
      view.animate({
        resolution: maxResolution,
        easing: _easing2.default.easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    }
    this.startTime_ = now;
    return false;
  }

  this.delta_ += delta;

  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

  return false;
};

/**
 * @private
 */
_ol_interaction_MouseWheelZoom_.prototype.decrementInteractingHint_ = function () {
  this.trackpadTimeoutId_ = undefined;
  var view = this.getMap().getView();
  view.setHint(_viewhint2.default.INTERACTING, -1);
};

/**
 * @private
 * @param {ol.Map} map Map.
 */
_ol_interaction_MouseWheelZoom_.prototype.handleWheelZoom_ = function (map) {
  var view = map.getView();
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  var maxDelta = _index2.default.MOUSEWHEELZOOM_MAXDELTA;
  var delta = _math2.default.clamp(this.delta_, -maxDelta, maxDelta);
  _interaction2.default.zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);
  this.mode_ = undefined;
  this.delta_ = 0;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
};

/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * @param {boolean} useAnchor true to zoom to the mouse's location, false
 * to zoom to the center of the map
 * @api
 */
_ol_interaction_MouseWheelZoom_.prototype.setMouseAnchor = function (useAnchor) {
  this.useAnchor_ = useAnchor;
  if (!useAnchor) {
    this.lastAnchor_ = null;
  }
};

/**
 * @enum {string}
 * @private
 */
_ol_interaction_MouseWheelZoom_.Mode_ = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
exports.default = _ol_interaction_MouseWheelZoom_;


},{"../easing":61,"../events/eventtype":66,"../has":107,"../index":110,"../interaction/interaction":117,"../math":144,"../viewhint":258}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require('../interaction/pointer');

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchRotateOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_PinchRotate_ = function (opt_options) {

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_PinchRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchRotate_.handleUpEvent_
  });

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastAngle_ = undefined;

  /**
   * @private
   * @type {boolean}
   */
  this.rotating_ = false;

  /**
   * @private
   * @type {number}
   */
  this.rotationDelta_ = 0.0;

  /**
   * @private
   * @type {number}
   */
  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

_index2.default.inherits(_ol_interaction_PinchRotate_, _pointer2.default);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchRotate}
 * @private
 */
_ol_interaction_PinchRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  var rotationDelta = 0.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];

  // angle between touches
  var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;
    if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }
    rotationDelta = delta;
  }
  this.lastAngle_ = angle;

  var map = mapBrowserEvent.map;

  // rotate anchor point.
  // FIXME: should be the intersection point between the lines:
  //     touch0,touch1 and previousTouch0,previousTouch1
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = _pointer2.default.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // rotate
  if (this.rotating_) {
    var view = map.getView();
    var rotation = view.getRotation();
    map.render();
    _interaction2.default.rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */
_ol_interaction_PinchRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint2.default.INTERACTING, -1);
    if (this.rotating_) {
      var rotation = view.getRotation();
      _interaction2.default.rotate(view, rotation, this.anchor_, this.duration_);
    }
    return false;
  } else {
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */
_ol_interaction_PinchRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
_ol_interaction_PinchRotate_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_PinchRotate_;


},{"../functions":78,"../index":110,"../interaction/interaction":117,"../interaction/pointer":123,"../viewhint":258}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _pointer = require('../interaction/pointer');

var _pointer2 = _interopRequireDefault(_pointer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchZoomOptions=} opt_options Options.
 * @api
 */
var _ol_interaction_PinchZoom_ = function (opt_options) {

  _pointer2.default.call(this, {
    handleDownEvent: _ol_interaction_PinchZoom_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchZoom_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchZoom_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {boolean}
   */
  this.constrainResolution_ = options.constrainResolution || false;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 400;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastDistance_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.lastScaleDelta_ = 1;
};

_index2.default.inherits(_ol_interaction_PinchZoom_, _pointer2.default);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchZoom}
 * @private
 */
_ol_interaction_PinchZoom_.handleDragEvent_ = function (mapBrowserEvent) {
  var scaleDelta = 1.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY;

  // distance between touches
  var distance = Math.sqrt(dx * dx + dy * dy);

  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }
  this.lastDistance_ = distance;

  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;
  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else if (newResolution < minResolution) {
    scaleDelta = minResolution / resolution;
    newResolution = minResolution;
  }

  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  }

  // scale anchor point.
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = _pointer2.default.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // scale, bypass the resolution constraint
  map.render();
  _interaction2.default.zoomWithoutConstraints(view, newResolution, this.anchor_);
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */
_ol_interaction_PinchZoom_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(_viewhint2.default.INTERACTING, -1);
    var resolution = view.getResolution();
    if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {
      // Zoom to final resolution, with an animation, and provide a
      // direction not to zoom out/in if user was pinching in/out.
      // Direction is > 0 if pinching out, and < 0 if pinching in.
      var direction = this.lastScaleDelta_ - 1;
      _interaction2.default.zoom(view, resolution, this.anchor_, this.duration_, direction);
    }
    return false;
  } else {
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */
_ol_interaction_PinchZoom_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(_viewhint2.default.INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
_ol_interaction_PinchZoom_.prototype.shouldStopEvent = _functions2.default.FALSE;
exports.default = _ol_interaction_PinchZoom_;


},{"../functions":78,"../index":110,"../interaction/interaction":117,"../interaction/pointer":123,"../viewhint":258}],123:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _mapbrowsereventtype = require('../mapbrowsereventtype');

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapbrowserpointerevent = require('../mapbrowserpointerevent');

var _mapbrowserpointerevent2 = _interopRequireDefault(_mapbrowserpointerevent);

var _interaction = require('../interaction/interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 *
 * @constructor
 * @param {olx.interaction.PointerOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var _ol_interaction_Pointer_ = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var handleEvent = options.handleEvent ? options.handleEvent : _ol_interaction_Pointer_.handleEvent;

  _interaction2.default.call(this, {
    handleEvent: handleEvent
  });

  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */
  this.handleDownEvent_ = options.handleDownEvent ? options.handleDownEvent : _ol_interaction_Pointer_.handleDownEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */
  this.handleDragEvent_ = options.handleDragEvent ? options.handleDragEvent : _ol_interaction_Pointer_.handleDragEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */
  this.handleMoveEvent_ = options.handleMoveEvent ? options.handleMoveEvent : _ol_interaction_Pointer_.handleMoveEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */
  this.handleUpEvent_ = options.handleUpEvent ? options.handleUpEvent : _ol_interaction_Pointer_.handleUpEvent;

  /**
   * @type {boolean}
   * @protected
   */
  this.handlingDownUpSequence = false;

  /**
   * @type {Object.<number, ol.pointer.PointerEvent>}
   * @private
   */
  this.trackedPointers_ = {};

  /**
   * @type {Array.<ol.pointer.PointerEvent>}
   * @protected
   */
  this.targetPointers = [];
};

_index2.default.inherits(_ol_interaction_Pointer_, _interaction2.default);

/**
 * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.
 * @return {ol.Pixel} Centroid pixel.
 */
_ol_interaction_Pointer_.centroid = function (pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 * @private
 */
_ol_interaction_Pointer_.prototype.isPointerDraggingEvent_ = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === _mapbrowsereventtype2.default.POINTERDOWN || type === _mapbrowsereventtype2.default.POINTERDRAG || type === _mapbrowsereventtype2.default.POINTERUP;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @private
 */
_ol_interaction_Pointer_.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
  if (this.isPointerDraggingEvent_(mapBrowserEvent)) {
    var event = mapBrowserEvent.pointerEvent;

    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERUP) {
      delete this.trackedPointers_[event.pointerId];
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDOWN) {
      this.trackedPointers_[event.pointerId] = event;
    } else if (event.pointerId in this.trackedPointers_) {
      // update only when there was a pointerdown event for this pointer
      this.trackedPointers_[event.pointerId] = event;
    }
    this.targetPointers = _obj2.default.getValues(this.trackedPointers_);
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */
_ol_interaction_Pointer_.handleDragEvent = _index2.default.nullFunction;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */
_ol_interaction_Pointer_.handleUpEvent = _functions2.default.FALSE;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */
_ol_interaction_Pointer_.handleDownEvent = _functions2.default.FALSE;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */
_ol_interaction_Pointer_.handleMoveEvent = _index2.default.nullFunction;

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Pointer}
 * @api
 */
_ol_interaction_Pointer_.handleEvent = function (mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof _mapbrowserpointerevent2.default)) {
    return true;
  }

  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);
  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERUP) {
      var handledUp = this.handleUpEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
    }
  } else {
    if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.shouldStopEvent(handled);
    } else if (mapBrowserEvent.type == _mapbrowsereventtype2.default.POINTERMOVE) {
      this.handleMoveEvent_(mapBrowserEvent);
    }
  }
  return !stopEvent;
};

/**
 * This method is used to determine if "down" events should be propagated to
 * other interactions or should be stopped.
 *
 * The method receives the return code of the "handleDownEvent" function.
 *
 * By default this function is the "identity" function. It's overidden in
 * child classes.
 *
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the event be stopped?
 * @protected
 */
_ol_interaction_Pointer_.prototype.shouldStopEvent = function (handled) {
  return handled;
};
exports.default = _ol_interaction_Pointer_;


},{"../functions":78,"../index":110,"../interaction/interaction":117,"../mapbrowsereventtype":139,"../mapbrowserpointerevent":140,"../obj":146}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_interaction_Property_ = {
  ACTIVE: 'active'
};

exports.default = _ol_interaction_Property_;


},{}],125:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @constructor
 * @param {number} decay Rate of decay (must be negative).
 * @param {number} minVelocity Minimum velocity (pixels/millisecond).
 * @param {number} delay Delay to consider to calculate the kinetic
 *     initial values (milliseconds).
 * @struct
 * @api
 */
var _ol_Kinetic_ = function (decay, minVelocity, delay) {

  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;

  /**
   * @private
   * @type {number}
   */
  this.minVelocity_ = minVelocity;

  /**
   * @private
   * @type {number}
   */
  this.delay_ = delay;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.points_ = [];

  /**
   * @private
   * @type {number}
   */
  this.angle_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.initialVelocity_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_Kinetic_.prototype.begin = function () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 */
_ol_Kinetic_.prototype.update = function (x, y) {
  this.points_.push(x, y, Date.now());
};

/**
 * @return {boolean} Whether we should do kinetic animation.
 */
_ol_Kinetic_.prototype.end = function () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  }

  // get the first point which still falls into the delay time
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }
  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};

/**
 * @return {number} Total distance travelled (pixels).
 */
_ol_Kinetic_.prototype.getDistance = function () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};

/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */
_ol_Kinetic_.prototype.getAngle = function () {
  return this.angle_;
};
exports.default = _ol_Kinetic_;


},{}],126:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _property = require('../layer/property');

var _property2 = _interopRequireDefault(_property);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {olx.layer.BaseOptions} options Layer options.
 * @api
 */
var _ol_layer_Base_ = function (options) {

  _object2.default.call(this);

  /**
   * @type {Object.<string, *>}
   */
  var properties = _obj2.default.assign({}, options);
  properties[_property2.default.OPACITY] = options.opacity !== undefined ? options.opacity : 1;
  properties[_property2.default.VISIBLE] = options.visible !== undefined ? options.visible : true;
  properties[_property2.default.Z_INDEX] = options.zIndex !== undefined ? options.zIndex : 0;
  properties[_property2.default.MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
  properties[_property2.default.MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;

  this.setProperties(properties);

  /**
   * @type {ol.LayerState}
   * @private
   */
  this.state_ = /** @type {ol.LayerState} */{
    layer: /** @type {ol.layer.Layer} */this,
    managed: true
  };
};

_index2.default.inherits(_ol_layer_Base_, _object2.default);

/**
 * Create a renderer for this layer.
 * @abstract
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @return {ol.renderer.Layer} A layer renderer.
 */
_ol_layer_Base_.prototype.createRenderer = function (mapRenderer) {};

/**
 * @return {ol.LayerState} Layer state.
 */
_ol_layer_Base_.prototype.getLayerState = function () {
  this.state_.opacity = _math2.default.clamp(this.getOpacity(), 0, 1);
  this.state_.sourceState = this.getSourceState();
  this.state_.visible = this.getVisible();
  this.state_.extent = this.getExtent();
  this.state_.zIndex = this.getZIndex();
  this.state_.maxResolution = this.getMaxResolution();
  this.state_.minResolution = Math.max(this.getMinResolution(), 0);

  return this.state_;
};

/**
 * @abstract
 * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be
 *     modified in place).
 * @return {Array.<ol.layer.Layer>} Array of layers.
 */
_ol_layer_Base_.prototype.getLayersArray = function (opt_array) {};

/**
 * @abstract
 * @param {Array.<ol.LayerState>=} opt_states Optional list of layer
 *     states (to be modified in place).
 * @return {Array.<ol.LayerState>} List of layer states.
 */
_ol_layer_Base_.prototype.getLayerStatesArray = function (opt_states) {};

/**
 * Return the {@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * @return {ol.Extent|undefined} The layer extent.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getExtent = function () {
  return (/** @type {ol.Extent|undefined} */this.get(_property2.default.EXTENT)
  );
};

/**
 * Return the maximum resolution of the layer.
 * @return {number} The maximum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getMaxResolution = function () {
  return (/** @type {number} */this.get(_property2.default.MAX_RESOLUTION)
  );
};

/**
 * Return the minimum resolution of the layer.
 * @return {number} The minimum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getMinResolution = function () {
  return (/** @type {number} */this.get(_property2.default.MIN_RESOLUTION)
  );
};

/**
 * Return the opacity of the layer (between 0 and 1).
 * @return {number} The opacity of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getOpacity = function () {
  return (/** @type {number} */this.get(_property2.default.OPACITY)
  );
};

/**
 * @abstract
 * @return {ol.source.State} Source state.
 */
_ol_layer_Base_.prototype.getSourceState = function () {};

/**
 * Return the visibility of the layer (`true` or `false`).
 * @return {boolean} The visibility of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getVisible = function () {
  return (/** @type {boolean} */this.get(_property2.default.VISIBLE)
  );
};

/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * @return {number} The Z-index of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getZIndex = function () {
  return (/** @type {number} */this.get(_property2.default.Z_INDEX)
  );
};

/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * @param {ol.Extent|undefined} extent The extent of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setExtent = function (extent) {
  this.set(_property2.default.EXTENT, extent);
};

/**
 * Set the maximum resolution at which the layer is visible.
 * @param {number} maxResolution The maximum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setMaxResolution = function (maxResolution) {
  this.set(_property2.default.MAX_RESOLUTION, maxResolution);
};

/**
 * Set the minimum resolution at which the layer is visible.
 * @param {number} minResolution The minimum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setMinResolution = function (minResolution) {
  this.set(_property2.default.MIN_RESOLUTION, minResolution);
};

/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * @param {number} opacity The opacity of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setOpacity = function (opacity) {
  this.set(_property2.default.OPACITY, opacity);
};

/**
 * Set the visibility of the layer (`true` or `false`).
 * @param {boolean} visible The visibility of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setVisible = function (visible) {
  this.set(_property2.default.VISIBLE, visible);
};

/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * @param {number} zindex The z-index of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setZIndex = function (zindex) {
  this.set(_property2.default.Z_INDEX, zindex);
};
exports.default = _ol_layer_Base_;


},{"../index":110,"../layer/property":129,"../math":144,"../obj":146,"../object":147}],127:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _collection = require('../collection');

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require('../collectioneventtype');

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _objecteventtype = require('../objecteventtype');

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _base = require('../layer/base');

var _base2 = _interopRequireDefault(_base);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A {@link ol.Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @constructor
 * @extends {ol.layer.Base}
 * @param {olx.layer.GroupOptions=} opt_options Layer options.
 * @api
 */
var _ol_layer_Group_ = function (opt_options) {

  var options = opt_options || {};
  var baseOptions = /** @type {olx.layer.GroupOptions} */
  _obj2.default.assign({}, options);
  delete baseOptions.layers;

  var layers = options.layers;

  _base2.default.call(this, baseOptions);

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.layersListenerKeys_ = [];

  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */
  this.listenerKeys_ = {};

  _events2.default.listen(this, _object2.default.getChangeEventType(_ol_layer_Group_.Property_.LAYERS), this.handleLayersChanged_, this);

  if (layers) {
    if (Array.isArray(layers)) {
      layers = new _collection2.default(layers.slice(), { unique: true });
    } else {
      _asserts2.default.assert(layers instanceof _collection2.default, 43); // Expected `layers` to be an array or an `ol.Collection`
      layers = layers;
    }
  } else {
    layers = new _collection2.default(undefined, { unique: true });
  }

  this.setLayers(layers);
};

_index2.default.inherits(_ol_layer_Group_, _base2.default);

/**
 * @inheritDoc
 */
_ol_layer_Group_.prototype.createRenderer = function (mapRenderer) {};

/**
 * @private
 */
_ol_layer_Group_.prototype.handleLayerChange_ = function () {
  if (this.getVisible()) {
    this.changed();
  }
};

/**
 * @param {ol.events.Event} event Event.
 * @private
 */
_ol_layer_Group_.prototype.handleLayersChanged_ = function (event) {
  var this$1 = this;

  this.layersListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.layersListenerKeys_.length = 0;

  var layers = this.getLayers();
  this.layersListenerKeys_.push(_events2.default.listen(layers, _collectioneventtype2.default.ADD, this.handleLayersAdd_, this), _events2.default.listen(layers, _collectioneventtype2.default.REMOVE, this.handleLayersRemove_, this));

  for (var id in this$1.listenerKeys_) {
    this$1.listenerKeys_[id].forEach(_events2.default.unlistenByKey);
  }
  _obj2.default.clear(this.listenerKeys_);

  var layersArray = layers.getArray();
  var i, ii, layer;
  for (i = 0, ii = layersArray.length; i < ii; i++) {
    layer = layersArray[i];
    this$1.listenerKeys_[_index2.default.getUid(layer).toString()] = [_events2.default.listen(layer, _objecteventtype2.default.PROPERTYCHANGE, this$1.handleLayerChange_, this$1), _events2.default.listen(layer, _eventtype2.default.CHANGE, this$1.handleLayerChange_, this$1)];
  }

  this.changed();
};

/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */
_ol_layer_Group_.prototype.handleLayersAdd_ = function (collectionEvent) {
  var layer = /** @type {ol.layer.Base} */collectionEvent.element;
  var key = _index2.default.getUid(layer).toString();
  this.listenerKeys_[key] = [_events2.default.listen(layer, _objecteventtype2.default.PROPERTYCHANGE, this.handleLayerChange_, this), _events2.default.listen(layer, _eventtype2.default.CHANGE, this.handleLayerChange_, this)];
  this.changed();
};

/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */
_ol_layer_Group_.prototype.handleLayersRemove_ = function (collectionEvent) {
  var layer = /** @type {ol.layer.Base} */collectionEvent.element;
  var key = _index2.default.getUid(layer).toString();
  this.listenerKeys_[key].forEach(_events2.default.unlistenByKey);
  delete this.listenerKeys_[key];
  this.changed();
};

/**
 * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @return {!ol.Collection.<ol.layer.Base>} Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */
_ol_layer_Group_.prototype.getLayers = function () {
  return (/** @type {!ol.Collection.<ol.layer.Base>} */this.get(_ol_layer_Group_.Property_.LAYERS)
  );
};

/**
 * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @param {!ol.Collection.<ol.layer.Base>} layers Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */
_ol_layer_Group_.prototype.setLayers = function (layers) {
  this.set(_ol_layer_Group_.Property_.LAYERS, layers);
};

/**
 * @inheritDoc
 */
_ol_layer_Group_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array !== undefined ? opt_array : [];
  this.getLayers().forEach(function (layer) {
    layer.getLayersArray(array);
  });
  return array;
};

/**
 * @inheritDoc
 */
_ol_layer_Group_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states !== undefined ? opt_states : [];

  var pos = states.length;

  this.getLayers().forEach(function (layer) {
    layer.getLayerStatesArray(states);
  });

  var ownLayerState = this.getLayerState();
  var i, ii, layerState;
  for (i = pos, ii = states.length; i < ii; i++) {
    layerState = states[i];
    layerState.opacity *= ownLayerState.opacity;
    layerState.visible = layerState.visible && ownLayerState.visible;
    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
    if (ownLayerState.extent !== undefined) {
      if (layerState.extent !== undefined) {
        layerState.extent = _extent2.default.getIntersection(layerState.extent, ownLayerState.extent);
      } else {
        layerState.extent = ownLayerState.extent;
      }
    }
  }

  return states;
};

/**
 * @inheritDoc
 */
_ol_layer_Group_.prototype.getSourceState = function () {
  return _state2.default.READY;
};

/**
 * @enum {string}
 * @private
 */
_ol_layer_Group_.Property_ = {
  LAYERS: 'layers'
};
exports.default = _ol_layer_Group_;


},{"../asserts":44,"../collection":47,"../collectioneventtype":48,"../events":62,"../events/eventtype":66,"../extent":68,"../index":110,"../layer/base":126,"../obj":146,"../object":147,"../objecteventtype":148,"../source/state":219}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _base = require('../layer/base');

var _base2 = _interopRequireDefault(_base);

var _property = require('../layer/property');

var _property2 = _interopRequireDefault(_property);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _eventtype3 = require('../render/eventtype');

var _eventtype4 = _interopRequireDefault(_eventtype3);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link ol.Map#addLayer}. Components
 * like {@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {@link ol.layer.Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.layer.Base}
 * @fires ol.render.Event
 * @param {olx.layer.LayerOptions} options Layer options.
 * @api
 */
var _ol_layer_Layer_ = function (options) {

  var baseOptions = _obj2.default.assign({}, options);
  delete baseOptions.source;

  _base2.default.call(this, /** @type {olx.layer.BaseOptions} */baseOptions);

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.mapPrecomposeKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.mapRenderKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.sourceChangeKey_ = null;

  if (options.map) {
    this.setMap(options.map);
  }

  _events2.default.listen(this, _object2.default.getChangeEventType(_property2.default.SOURCE), this.handleSourcePropertyChange_, this);

  var source = options.source ? options.source : null;
  this.setSource(source);
};

_index2.default.inherits(_ol_layer_Layer_, _base2.default);

/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
_ol_layer_Layer_.visibleAtResolution = function (layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;
};

/**
 * @inheritDoc
 */
_ol_layer_Layer_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array ? opt_array : [];
  array.push(this);
  return array;
};

/**
 * @inheritDoc
 */
_ol_layer_Layer_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states ? opt_states : [];
  states.push(this.getLayerState());
  return states;
};

/**
 * Get the layer source.
 * @return {ol.source.Source} The layer source (or `null` if not yet set).
 * @observable
 * @api
 */
_ol_layer_Layer_.prototype.getSource = function () {
  var source = this.get(_property2.default.SOURCE);
  return (/** @type {ol.source.Source} */source || null
  );
};

/**
  * @inheritDoc
  */
_ol_layer_Layer_.prototype.getSourceState = function () {
  var source = this.getSource();
  return !source ? _state2.default.UNDEFINED : source.getState();
};

/**
 * @private
 */
_ol_layer_Layer_.prototype.handleSourceChange_ = function () {
  this.changed();
};

/**
 * @private
 */
_ol_layer_Layer_.prototype.handleSourcePropertyChange_ = function () {
  if (this.sourceChangeKey_) {
    _events2.default.unlistenByKey(this.sourceChangeKey_);
    this.sourceChangeKey_ = null;
  }
  var source = this.getSource();
  if (source) {
    this.sourceChangeKey_ = _events2.default.listen(source, _eventtype2.default.CHANGE, this.handleSourceChange_, this);
  }
  this.changed();
};

/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 *
 * To add the layer to a map and have it managed by the map, use
 * {@link ol.Map#addLayer} instead.
 * @param {ol.Map} map Map.
 * @api
 */
_ol_layer_Layer_.prototype.setMap = function (map) {
  if (this.mapPrecomposeKey_) {
    _events2.default.unlistenByKey(this.mapPrecomposeKey_);
    this.mapPrecomposeKey_ = null;
  }
  if (!map) {
    this.changed();
  }
  if (this.mapRenderKey_) {
    _events2.default.unlistenByKey(this.mapRenderKey_);
    this.mapRenderKey_ = null;
  }
  if (map) {
    this.mapPrecomposeKey_ = _events2.default.listen(map, _eventtype4.default.PRECOMPOSE, function (evt) {
      var layerState = this.getLayerState();
      layerState.managed = false;
      layerState.zIndex = Infinity;
      evt.frameState.layerStatesArray.push(layerState);
      evt.frameState.layerStates[_index2.default.getUid(this)] = layerState;
    }, this);
    this.mapRenderKey_ = _events2.default.listen(this, _eventtype2.default.CHANGE, map.render, map);
    this.changed();
  }
};

/**
 * Set the layer source.
 * @param {ol.source.Source} source The layer source.
 * @observable
 * @api
 */
_ol_layer_Layer_.prototype.setSource = function (source) {
  this.set(_property2.default.SOURCE, source);
};
exports.default = _ol_layer_Layer_;


},{"../events":62,"../events/eventtype":66,"../index":110,"../layer/base":126,"../layer/property":129,"../obj":146,"../object":147,"../render/eventtype":177,"../source/state":219}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_layer_Property_ = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
};

exports.default = _ol_layer_Property_;


},{}],130:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _layer = require('../layer/layer');

var _layer2 = _interopRequireDefault(_layer);

var _tileproperty = require('../layer/tileproperty');

var _tileproperty2 = _interopRequireDefault(_tileproperty);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _type = require('../renderer/type');

var _type2 = _interopRequireDefault(_type);

var _tilelayer = require('../renderer/canvas/tilelayer');

var _tilelayer2 = _interopRequireDefault(_tilelayer);

var _tilelayer3 = require('../renderer/webgl/tilelayer');

var _tilelayer4 = _interopRequireDefault(_tilelayer3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.TileOptions=} opt_options Tile layer options.
 * @api
 */
var _ol_layer_Tile_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  var baseOptions = _obj2.default.assign({}, options);

  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;
  _layer2.default.call(this, /** @type {olx.layer.LayerOptions} */baseOptions);

  this.setPreload(options.preload !== undefined ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);
};

_index2.default.inherits(_ol_layer_Tile_, _layer2.default);

/**
 * @inheritDoc
 */
_ol_layer_Tile_.prototype.createRenderer = function (mapRenderer) {
  var renderer = null;
  var type = mapRenderer.getType();
  if (_index2.default.ENABLE_CANVAS && type === _type2.default.CANVAS) {
    renderer = new _tilelayer2.default(this);
  } else if (false && type === _type2.default.WEBGL) {
    renderer = new _tilelayer4.default(mapRenderer, this);
  }
  return renderer;
};

/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */
_ol_layer_Tile_.prototype.getPreload = function () {
  return (/** @type {number} */this.get(_tileproperty2.default.PRELOAD)
  );
};

/**
 * Return the associated {@link ol.source.Tile tilesource} of the layer.
 * @function
 * @return {ol.source.Tile} Source.
 * @api
 */
_ol_layer_Tile_.prototype.getSource;

/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */
_ol_layer_Tile_.prototype.setPreload = function (preload) {
  this.set(_tileproperty2.default.PRELOAD, preload);
};

/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */
_ol_layer_Tile_.prototype.getUseInterimTilesOnError = function () {
  return (/** @type {boolean} */this.get(_tileproperty2.default.USE_INTERIM_TILES_ON_ERROR)
  );
};

/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */
_ol_layer_Tile_.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
  this.set(_tileproperty2.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
exports.default = _ol_layer_Tile_;


},{"../index":110,"../layer/layer":128,"../layer/tileproperty":131,"../obj":146,"../renderer/canvas/tilelayer":199,"../renderer/type":204,"../renderer/webgl/tilelayer":209}],131:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_layer_TileProperty_ = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};

exports.default = _ol_layer_TileProperty_;


},{}],132:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _layer = require('../layer/layer');

var _layer2 = _interopRequireDefault(_layer);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _type = require('../renderer/type');

var _type2 = _interopRequireDefault(_type);

var _vectorlayer = require('../renderer/canvas/vectorlayer');

var _vectorlayer2 = _interopRequireDefault(_vectorlayer);

var _vectorlayer3 = require('../renderer/webgl/vectorlayer');

var _vectorlayer4 = _interopRequireDefault(_vectorlayer3);

var _style = require('../style/style');

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.VectorOptions=} opt_options Options.
 * @api
 */
var _ol_layer_Vector_ = function (opt_options) {
  var options = opt_options ? opt_options : /** @type {olx.layer.VectorOptions} */{};

  var baseOptions = _obj2.default.assign({}, options);

  delete baseOptions.style;
  delete baseOptions.renderBuffer;
  delete baseOptions.updateWhileAnimating;
  delete baseOptions.updateWhileInteracting;
  _layer2.default.call(this, /** @type {olx.layer.LayerOptions} */baseOptions);

  /**
   * @type {number}
   * @private
   */
  this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;

  /**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */
  this.style_ = null;

  /**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */
  this.styleFunction_ = undefined;

  this.setStyle(options.style);

  /**
   * @type {boolean}
   * @private
   */
  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;

  /**
   * @type {boolean}
   * @private
   */
  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;
};

_index2.default.inherits(_ol_layer_Vector_, _layer2.default);

/**
 * @inheritDoc
 */
_ol_layer_Vector_.prototype.createRenderer = function (mapRenderer) {
  var renderer = null;
  var type = mapRenderer.getType();
  if (_index2.default.ENABLE_CANVAS && type === _type2.default.CANVAS) {
    renderer = new _vectorlayer2.default(this);
  } else if (false && type === _type2.default.WEBGL) {
    renderer = new _vectorlayer4.default(mapRenderer, this);
  }
  return renderer;
};

/**
 * @return {number|undefined} Render buffer.
 */
_ol_layer_Vector_.prototype.getRenderBuffer = function () {
  return this.renderBuffer_;
};

/**
 * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render
 *     order.
 */
_ol_layer_Vector_.prototype.getRenderOrder = function () {
  return (/** @type {ol.RenderOrderFunction|null|undefined} */this.get(_ol_layer_Vector_.Property_.RENDER_ORDER)
  );
};

/**
 * Return the associated {@link ol.source.Vector vectorsource} of the layer.
 * @function
 * @return {ol.source.Vector} Source.
 * @api
 */
_ol_layer_Vector_.prototype.getSource;

/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */
_ol_layer_Vector_.prototype.getStyle = function () {
  return this.style_;
};

/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */
_ol_layer_Vector_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};

/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     animating.
 */
_ol_layer_Vector_.prototype.getUpdateWhileAnimating = function () {
  return this.updateWhileAnimating_;
};

/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     interacting.
 */
_ol_layer_Vector_.prototype.getUpdateWhileInteracting = function () {
  return this.updateWhileInteracting_;
};

/**
 * @param {ol.RenderOrderFunction|null|undefined} renderOrder
 *     Render order.
 */
_ol_layer_Vector_.prototype.setRenderOrder = function (renderOrder) {
  this.set(_ol_layer_Vector_.Property_.RENDER_ORDER, renderOrder);
};

/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}
 *     style Layer style.
 * @api
 */
_ol_layer_Vector_.prototype.setStyle = function (style) {
  this.style_ = style !== undefined ? style : _style2.default.defaultFunction;
  this.styleFunction_ = style === null ? undefined : _style2.default.createFunction(this.style_);
  this.changed();
};

/**
 * @enum {string}
 * @private
 */
_ol_layer_Vector_.Property_ = {
  RENDER_ORDER: 'renderOrder'
};
exports.default = _ol_layer_Vector_;


},{"../index":110,"../layer/layer":128,"../obj":146,"../renderer/canvas/vectorlayer":200,"../renderer/type":204,"../renderer/webgl/vectorlayer":211,"../style/style":244}],133:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _tileproperty = require('../layer/tileproperty');

var _tileproperty2 = _interopRequireDefault(_tileproperty);

var _vector = require('../layer/vector');

var _vector2 = _interopRequireDefault(_vector);

var _vectortilerendertype = require('../layer/vectortilerendertype');

var _vectortilerendertype2 = _interopRequireDefault(_vectortilerendertype);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _type = require('../renderer/type');

var _type2 = _interopRequireDefault(_type);

var _vectortilelayer = require('../renderer/canvas/vectortilelayer');

var _vectortilelayer2 = _interopRequireDefault(_vectortilelayer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Layer for vector tile data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Vector}
 * @param {olx.layer.VectorTileOptions=} opt_options Options.
 * @api
 */
var _ol_layer_VectorTile_ = function (opt_options) {
  var options = opt_options ? opt_options : {};

  var baseOptions = _obj2.default.assign({}, options);

  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;
  _vector2.default.call(this, /** @type {olx.layer.VectorOptions} */baseOptions);

  this.setPreload(options.preload ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError ? options.useInterimTilesOnError : true);

  _asserts2.default.assert(options.renderMode == undefined || options.renderMode == _vectortilerendertype2.default.IMAGE || options.renderMode == _vectortilerendertype2.default.HYBRID || options.renderMode == _vectortilerendertype2.default.VECTOR, 28); // `renderMode` must be `'image'`, `'hybrid'` or `'vector'`

  /**
   * @private
   * @type {ol.layer.VectorTileRenderType|string}
   */
  this.renderMode_ = options.renderMode || _vectortilerendertype2.default.HYBRID;
};

_index2.default.inherits(_ol_layer_VectorTile_, _vector2.default);

/**
 * @inheritDoc
 */
_ol_layer_VectorTile_.prototype.createRenderer = function (mapRenderer) {
  var renderer = null;
  var type = mapRenderer.getType();
  if (_index2.default.ENABLE_CANVAS && type === _type2.default.CANVAS) {
    renderer = new _vectortilelayer2.default(this);
  }
  return renderer;
};

/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */
_ol_layer_VectorTile_.prototype.getPreload = function () {
  return (/** @type {number} */this.get(_tileproperty2.default.PRELOAD)
  );
};

/**
 * @return {ol.layer.VectorTileRenderType|string} The render mode.
 */
_ol_layer_VectorTile_.prototype.getRenderMode = function () {
  return this.renderMode_;
};

/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */
_ol_layer_VectorTile_.prototype.getUseInterimTilesOnError = function () {
  return (/** @type {boolean} */this.get(_tileproperty2.default.USE_INTERIM_TILES_ON_ERROR)
  );
};

/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */
_ol_layer_VectorTile_.prototype.setPreload = function (preload) {
  this.set(_tileproperty2.default.PRELOAD, preload);
};

/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */
_ol_layer_VectorTile_.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
  this.set(_tileproperty2.default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
exports.default = _ol_layer_VectorTile_;


},{"../asserts":44,"../index":110,"../layer/tileproperty":131,"../layer/vector":132,"../layer/vectortilerendertype":134,"../obj":146,"../renderer/canvas/vectortilelayer":201,"../renderer/type":204}],134:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
var _ol_layer_VectorTileRenderType_ = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};

exports.default = _ol_layer_VectorTileRenderType_;


},{}],135:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_loadingstrategy_ = {};

/**
 * Strategy function for loading all features with a single request.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */
_ol_loadingstrategy_.all = function (extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
};

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */
_ol_loadingstrategy_.bbox = function (extent, resolution) {
  return [extent];
};

/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.
 * @api
 */
_ol_loadingstrategy_.tile = function (tileGrid) {
  return (
    /**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @return {Array.<ol.Extent>} Extents.
     */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array.<ol.Extent>} */
      var extents = [];
      /** @type {ol.TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
};
exports.default = _ol_loadingstrategy_;


},{}],136:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _collection = require('./collection');

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require('./collectioneventtype');

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _mapbrowserevent = require('./mapbrowserevent');

var _mapbrowserevent2 = _interopRequireDefault(_mapbrowserevent);

var _mapbrowsereventhandler = require('./mapbrowsereventhandler');

var _mapbrowsereventhandler2 = _interopRequireDefault(_mapbrowsereventhandler);

var _mapbrowsereventtype = require('./mapbrowsereventtype');

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapevent = require('./mapevent');

var _mapevent2 = _interopRequireDefault(_mapevent);

var _mapeventtype = require('./mapeventtype');

var _mapeventtype2 = _interopRequireDefault(_mapeventtype);

var _mapproperty = require('./mapproperty');

var _mapproperty2 = _interopRequireDefault(_mapproperty);

var _object = require('./object');

var _object2 = _interopRequireDefault(_object);

var _objecteventtype = require('./objecteventtype');

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _tilequeue = require('./tilequeue');

var _tilequeue2 = _interopRequireDefault(_tilequeue);

var _view = require('./view');

var _view2 = _interopRequireDefault(_view);

var _viewhint = require('./viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _control = require('./control');

var _control2 = _interopRequireDefault(_control);

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _event = require('./events/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('./extent');

var _extent2 = _interopRequireDefault(_extent);

var _functions = require('./functions');

var _functions2 = _interopRequireDefault(_functions);

var _has = require('./has');

var _has2 = _interopRequireDefault(_has);

var _interaction = require('./interaction');

var _interaction2 = _interopRequireDefault(_interaction);

var _group = require('./layer/group');

var _group2 = _interopRequireDefault(_group);

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

var _map = require('./renderer/map');

var _map2 = _interopRequireDefault(_map);

var _type = require('./renderer/type');

var _type2 = _interopRequireDefault(_type);

var _map3 = require('./renderer/canvas/map');

var _map4 = _interopRequireDefault(_map3);

var _map5 = require('./renderer/webgl/map');

var _map6 = _interopRequireDefault(_map5);

var _size = require('./size');

var _size2 = _interopRequireDefault(_size);

var _priorityqueue = require('./structs/priorityqueue');

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

var _transform = require('./transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @const
 * @type {string}
 */
_index2.default.OL_URL = 'https://openlayers.org/';

/**
 * @const
 * @type {string}
 */
// FIXME recheck layer/map projection compatibility when projection changes
// FIXME layer renderers should skip when they can't reproject
// FIXME add tilt and height?

_index2.default.OL_LOGO_URL = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI' + 'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA' + 'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW' + 'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY' + 'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX' + 'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk' + 'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW' + '2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP' + 'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT' + 'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar' + 'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi' + 'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn' + 'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF' + 'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ' + 'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC' + 'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe' + '0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8' + 'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a' + 'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn' + 'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg' + 'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';

/**
 * @type {Array.<ol.renderer.Type>}
 * @const
 */
_index2.default.DEFAULT_RENDERER_TYPES = [_type2.default.CANVAS, _type2.default.WEBGL];

/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link ol.layer.Tile} to display
 * {@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport.
 *
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */
var _ol_Map_ = function (options) {
  var this$1 = this;


  _object2.default.call(this);

  var optionsInternal = _ol_Map_.createOptionsInternal(options);

  /**
   * @type {boolean}
   * @private
   */
  this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;

  /**
   * @type {boolean}
   * @private
   */
  this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : _has2.default.DEVICE_PIXEL_RATIO;

  /**
   * @private
   * @type {Object.<string, string>}
   */
  this.logos_ = optionsInternal.logos;

  /**
   * @private
   * @type {number|undefined}
   */
  this.animationDelayKey_;

  /**
   * @private
   */
  this.animationDelay_ = function () {
    this.animationDelayKey_ = undefined;
    this.renderFrame_.call(this, Date.now());
  }.bind(this);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.coordinateToPixelTransform_ = _transform2.default.create();

  /**
   * @private
   * @type {ol.Transform}
   */
  this.pixelToCoordinateTransform_ = _transform2.default.create();

  /**
   * @private
   * @type {number}
   */
  this.frameIndex_ = 0;

  /**
   * @private
   * @type {?olx.FrameState}
   */
  this.frameState_ = null;

  /**
   * The extent at the previous 'moveend' event.
   * @private
   * @type {ol.Extent}
   */
  this.previousExtent_ = _extent2.default.createEmpty();

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.viewPropertyListenerKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.viewChangeListenerKey_ = null;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.layerGroupPropertyListenerKeys_ = null;

  /**
   * @private
   * @type {Element}
   */
  this.viewport_ = document.createElement('DIV');
  this.viewport_.className = 'ol-viewport' + (_has2.default.TOUCH ? ' ol-touch' : '');
  this.viewport_.style.position = 'relative';
  this.viewport_.style.overflow = 'hidden';
  this.viewport_.style.width = '100%';
  this.viewport_.style.height = '100%';
  // prevent page zoom on IE >= 10 browsers
  this.viewport_.style.msTouchAction = 'none';
  this.viewport_.style.touchAction = 'none';

  /**
   * @private
   * @type {!Element}
   */
  this.overlayContainer_ = document.createElement('DIV');
  this.overlayContainer_.className = 'ol-overlaycontainer';
  this.viewport_.appendChild(this.overlayContainer_);

  /**
   * @private
   * @type {!Element}
   */
  this.overlayContainerStopEvent_ = document.createElement('DIV');
  this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
  var overlayEvents = [_eventtype2.default.CLICK, _eventtype2.default.DBLCLICK, _eventtype2.default.MOUSEDOWN, _eventtype2.default.TOUCHSTART, _eventtype2.default.MSPOINTERDOWN, _mapbrowsereventtype2.default.POINTERDOWN, _eventtype2.default.MOUSEWHEEL, _eventtype2.default.WHEEL];
  for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
    _events2.default.listen(this$1.overlayContainerStopEvent_, overlayEvents[i], _event2.default.stopPropagation);
  }
  this.viewport_.appendChild(this.overlayContainerStopEvent_);

  /**
   * @private
   * @type {ol.MapBrowserEventHandler}
   */
  this.mapBrowserEventHandler_ = new _mapbrowsereventhandler2.default(this);
  for (var key in _mapbrowsereventtype2.default) {
    _events2.default.listen(this$1.mapBrowserEventHandler_, _mapbrowsereventtype2.default[key], this$1.handleMapBrowserEvent, this$1);
  }

  /**
   * @private
   * @type {Element|Document}
   */
  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.keyHandlerKeys_ = null;

  _events2.default.listen(this.viewport_, _eventtype2.default.WHEEL, this.handleBrowserEvent, this);
  _events2.default.listen(this.viewport_, _eventtype2.default.MOUSEWHEEL, this.handleBrowserEvent, this);

  /**
   * @type {ol.Collection.<ol.control.Control>}
   * @private
   */
  this.controls_ = optionsInternal.controls;

  /**
   * @type {ol.Collection.<ol.interaction.Interaction>}
   * @private
   */
  this.interactions_ = optionsInternal.interactions;

  /**
   * @type {ol.Collection.<ol.Overlay>}
   * @private
   */
  this.overlays_ = optionsInternal.overlays;

  /**
   * A lookup of overlays by id.
   * @private
   * @type {Object.<string, ol.Overlay>}
   */
  this.overlayIdIndex_ = {};

  /**
   * @type {ol.renderer.Map}
   * @private
   */
  this.renderer_ = new /** @type {Function} */optionsInternal.rendererConstructor(this.viewport_, this);

  /**
   * @type {function(Event)|undefined}
   * @private
   */
  this.handleResize_;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.focus_ = null;

  /**
   * @private
   * @type {Array.<ol.PostRenderFunction>}
   */
  this.postRenderFunctions_ = [];

  /**
   * @private
   * @type {ol.TileQueue}
   */
  this.tileQueue_ = new _tilequeue2.default(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));

  /**
   * Uids of features to skip at rendering time.
   * @type {Object.<string, boolean>}
   * @private
   */
  this.skippedFeatureUids_ = {};

  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.LAYERGROUP), this.handleLayerGroupChanged_, this);
  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.VIEW), this.handleViewChanged_, this);
  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.SIZE), this.handleSizeChanged_, this);
  _events2.default.listen(this, _object2.default.getChangeEventType(_mapproperty2.default.TARGET), this.handleTargetChanged_, this);

  // setProperties will trigger the rendering of the map if the map
  // is "defined" already.
  this.setProperties(optionsInternal.values);

  this.controls_.forEach(
  /**
   * @param {ol.control.Control} control Control.
   * @this {ol.Map}
   */
  function (control) {
    control.setMap(this);
  }, this);

  _events2.default.listen(this.controls_, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events2.default.listen(this.controls_, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.interactions_.forEach(
  /**
   * @param {ol.interaction.Interaction} interaction Interaction.
   * @this {ol.Map}
   */
  function (interaction) {
    interaction.setMap(this);
  }, this);

  _events2.default.listen(this.interactions_, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  _events2.default.listen(this.interactions_, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.overlays_.forEach(this.addOverlayInternal_, this);

  _events2.default.listen(this.overlays_, _collectioneventtype2.default.ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    this.addOverlayInternal_( /** @type {ol.Overlay} */event.element);
  }, this);

  _events2.default.listen(this.overlays_, _collectioneventtype2.default.REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    var overlay = /** @type {ol.Overlay} */event.element;
    var id = overlay.getId();
    if (id !== undefined) {
      delete this.overlayIdIndex_[id.toString()];
    }
    event.element.setMap(null);
  }, this);
};

_index2.default.inherits(_ol_Map_, _object2.default);

/**
 * Add the given control to the map.
 * @param {ol.control.Control} control Control.
 * @api
 */
_ol_Map_.prototype.addControl = function (control) {
  this.getControls().push(control);
};

/**
 * Add the given interaction to the map.
 * @param {ol.interaction.Interaction} interaction Interaction to add.
 * @api
 */
_ol_Map_.prototype.addInteraction = function (interaction) {
  this.getInteractions().push(interaction);
};

/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {@link ol.Collection}.
 * @param {ol.layer.Base} layer Layer.
 * @api
 */
_ol_Map_.prototype.addLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  layers.push(layer);
};

/**
 * Add the given overlay to the map.
 * @param {ol.Overlay} overlay Overlay.
 * @api
 */
_ol_Map_.prototype.addOverlay = function (overlay) {
  this.getOverlays().push(overlay);
};

/**
 * This deals with map's overlay collection changes.
 * @param {ol.Overlay} overlay Overlay.
 * @private
 */
_ol_Map_.prototype.addOverlayInternal_ = function (overlay) {
  var id = overlay.getId();
  if (id !== undefined) {
    this.overlayIdIndex_[id.toString()] = overlay;
  }
  overlay.setMap(this);
};

/**
 *
 * @inheritDoc
 */
_ol_Map_.prototype.disposeInternal = function () {
  this.mapBrowserEventHandler_.dispose();
  this.renderer_.dispose();
  _events2.default.unlisten(this.viewport_, _eventtype2.default.WHEEL, this.handleBrowserEvent, this);
  _events2.default.unlisten(this.viewport_, _eventtype2.default.MOUSEWHEEL, this.handleBrowserEvent, this);
  if (this.handleResize_ !== undefined) {
    window.removeEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
    this.handleResize_ = undefined;
  }
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
    this.animationDelayKey_ = undefined;
  }
  this.setTarget(null);
  _object2.default.prototype.disposeInternal.call(this);
};

/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {@link ol.Feature feature} or
 *     {@link ol.render.Feature render feature} at the pixel, the second is
 *     the {@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T
 * @api
 */
_ol_Map_.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
  if (!this.frameState_) {
    return;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions2.default.TRUE;
  return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);
};

/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback
 *     Layer callback. This callback will recieve two arguments: first is the
 *     {@link ol.layer.Layer layer}, second argument is an array representing
 *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
 *     that do not currently support this argument. To stop detection, callback
 *     functions can return a truthy value.
 * @param {S=} opt_this Value to use as `this` when executing `callback`.
 * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer
 *     filter function. The filter function will receive one argument, the
 *     {@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T,U
 * @api
 */
_ol_Map_.prototype.forEachLayerAtPixel = function (pixel, callback, opt_this, opt_layerFilter, opt_this2) {
  if (!this.frameState_) {
    return;
  }
  var thisArg = opt_this !== undefined ? opt_this : null;
  var layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : _functions2.default.TRUE;
  var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;
  return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, callback, thisArg, layerFilter, thisArg2);
};

/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {boolean} Is there a feature at the given pixel?
 * @template U
 * @api
 */
_ol_Map_.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
  if (!this.frameState_) {
    return false;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : _functions2.default.TRUE;
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);
};

/**
 * Returns the coordinate in view projection for a browser event.
 * @param {Event} event Event.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_Map_.prototype.getEventCoordinate = function (event) {
  return this.getCoordinateFromPixel(this.getEventPixel(event));
};

/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * @param {Event} event Event.
 * @return {ol.Pixel} Pixel.
 * @api
 */
_ol_Map_.prototype.getEventPixel = function (event) {
  var viewportPosition = this.viewport_.getBoundingClientRect();
  var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
  return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
};

/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 * @return {Element|string|undefined} The Element or id of the Element that the
 *     map is rendered in.
 * @observable
 * @api
 */
_ol_Map_.prototype.getTarget = function () {
  return (/** @type {Element|string|undefined} */this.get(_mapproperty2.default.TARGET)
  );
};

/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * @return {Element} The element that the map is rendered in.
 * @api
 */
_ol_Map_.prototype.getTargetElement = function () {
  var target = this.getTarget();
  if (target !== undefined) {
    return typeof target === 'string' ? document.getElementById(target) : target;
  } else {
    return null;
  }
};

/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * @param {ol.Pixel} pixel Pixel position in the map viewport.
 * @return {ol.Coordinate} The coordinate for the pixel position.
 * @api
 */
_ol_Map_.prototype.getCoordinateFromPixel = function (pixel) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
};

/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */
_ol_Map_.prototype.getControls = function () {
  return this.controls_;
};

/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * @return {ol.Collection.<ol.Overlay>} Overlays.
 * @api
 */
_ol_Map_.prototype.getOverlays = function () {
  return this.overlays_;
};

/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * @param {string|number} id Overlay identifier.
 * @return {ol.Overlay} Overlay.
 * @api
 */
_ol_Map_.prototype.getOverlayById = function (id) {
  var overlay = this.overlayIdIndex_[id.toString()];
  return overlay !== undefined ? overlay : null;
};

/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 *
 * Interactions are used for e.g. pan, zoom and rotate.
 * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.
 * @api
 */
_ol_Map_.prototype.getInteractions = function () {
  return this.interactions_;
};

/**
 * Get the layergroup associated with this map.
 * @return {ol.layer.Group} A layer group containing the layers in this map.
 * @observable
 * @api
 */
_ol_Map_.prototype.getLayerGroup = function () {
  return (/** @type {ol.layer.Group} */this.get(_mapproperty2.default.LAYERGROUP)
  );
};

/**
 * Get the collection of layers associated with this map.
 * @return {!ol.Collection.<ol.layer.Base>} Layers.
 * @api
 */
_ol_Map_.prototype.getLayers = function () {
  var layers = this.getLayerGroup().getLayers();
  return layers;
};

/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * @param {ol.Coordinate} coordinate A map coordinate.
 * @return {ol.Pixel} A pixel position in the map viewport.
 * @api
 */
_ol_Map_.prototype.getPixelFromCoordinate = function (coordinate) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return _transform2.default.apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
};

/**
 * Get the map renderer.
 * @return {ol.renderer.Map} Renderer
 */
_ol_Map_.prototype.getRenderer = function () {
  return this.renderer_;
};

/**
 * Get the size of this map.
 * @return {ol.Size|undefined} The size in pixels of the map in the DOM.
 * @observable
 * @api
 */
_ol_Map_.prototype.getSize = function () {
  return (/** @type {ol.Size|undefined} */this.get(_mapproperty2.default.SIZE)
  );
};

/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * @return {ol.View} The view that controls this map.
 * @observable
 * @api
 */
_ol_Map_.prototype.getView = function () {
  return (/** @type {ol.View} */this.get(_mapproperty2.default.VIEW)
  );
};

/**
 * Get the element that serves as the map viewport.
 * @return {Element} Viewport.
 * @api
 */
_ol_Map_.prototype.getViewport = function () {
  return this.viewport_;
};

/**
 * Get the element that serves as the container for overlays.  Elements added to
 * this container will let mousedown and touchstart events through to the map,
 * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}
 * events.
 * @return {!Element} The map's overlay container.
 */
_ol_Map_.prototype.getOverlayContainer = function () {
  return this.overlayContainer_;
};

/**
 * Get the element that serves as a container for overlays that don't allow
 * event propagation. Elements added to this container won't let mousedown and
 * touchstart events through to the map, so clicks and gestures on an overlay
 * don't trigger any {@link ol.MapBrowserEvent}.
 * @return {!Element} The map's overlay container that stops events.
 */
_ol_Map_.prototype.getOverlayContainerStopEvent = function () {
  return this.overlayContainerStopEvent_;
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {ol.Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
_ol_Map_.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  var frameState = this.frameState_;
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return _priorityqueue2.default.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return _priorityqueue2.default.DROP;
  }
  // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels
  // between the center of the tile and the focus.  The factor of 65536 means
  // that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.
  var deltaX = tileCenter[0] - frameState.focus[0];
  var deltaY = tileCenter[1] - frameState.focus[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
};

/**
 * @param {Event} browserEvent Browser event.
 * @param {string=} opt_type Type.
 */
_ol_Map_.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
  var type = opt_type || browserEvent.type;
  var mapBrowserEvent = new _mapbrowserevent2.default(type, this, browserEvent);
  this.handleMapBrowserEvent(mapBrowserEvent);
};

/**
 * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.
 */
_ol_Map_.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
  if (!this.frameState_) {
    // With no view defined, we cannot translate pixels into geographical
    // coordinates so interactions cannot be used.
    return;
  }
  this.focus_ = mapBrowserEvent.coordinate;
  mapBrowserEvent.frameState = this.frameState_;
  var interactionsArray = this.getInteractions().getArray();
  var i;
  if (this.dispatchEvent(mapBrowserEvent) !== false) {
    for (i = interactionsArray.length - 1; i >= 0; i--) {
      var interaction = interactionsArray[i];
      if (!interaction.getActive()) {
        continue;
      }
      var cont = interaction.handleEvent(mapBrowserEvent);
      if (!cont) {
        break;
      }
    }
  }
};

/**
 * @protected
 */
_ol_Map_.prototype.handlePostRender = function () {
  var this$1 = this;


  var frameState = this.frameState_;

  // Manage the tile queue
  // Image loads are expensive and a limited resource, so try to use them
  // efficiently:
  // * When the view is static we allow a large number of parallel tile loads
  //   to complete the frame as quickly as possible.
  // * When animating or interacting, image loads can cause janks, so we reduce
  //   the maximum number of loads per frame and limit the number of parallel
  //   tile loads to remain reactive to view changes and to reduce the chance of
  //   loading tiles that will quickly disappear from view.
  var tileQueue = this.tileQueue_;
  if (!tileQueue.isEmpty()) {
    var maxTotalLoading = 16;
    var maxNewLoads = maxTotalLoading;
    if (frameState) {
      var hints = frameState.viewHints;
      if (hints[_viewhint2.default.ANIMATING]) {
        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
        maxNewLoads = 2;
      }
      if (hints[_viewhint2.default.INTERACTING]) {
        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
        maxNewLoads = 2;
      }
    }
    if (tileQueue.getTilesLoading() < maxTotalLoading) {
      tileQueue.reprioritize(); // FIXME only call if view has changed
      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
    }
  }

  var postRenderFunctions = this.postRenderFunctions_;
  var i, ii;
  for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
    postRenderFunctions[i](this$1, frameState);
  }
  postRenderFunctions.length = 0;
};

/**
 * @private
 */
_ol_Map_.prototype.handleSizeChanged_ = function () {
  this.render();
};

/**
 * @private
 */
_ol_Map_.prototype.handleTargetChanged_ = function () {
  var this$1 = this;

  // target may be undefined, null, a string or an Element.
  // If it's a string we convert it to an Element before proceeding.
  // If it's not now an Element we remove the viewport from the DOM.
  // If it's an Element we append the viewport element to it.

  var targetElement;
  if (this.getTarget()) {
    targetElement = this.getTargetElement();
  }

  if (this.keyHandlerKeys_) {
    for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
      _events2.default.unlistenByKey(this$1.keyHandlerKeys_[i]);
    }
    this.keyHandlerKeys_ = null;
  }

  if (!targetElement) {
    _dom2.default.removeNode(this.viewport_);
    if (this.handleResize_ !== undefined) {
      window.removeEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
  } else {
    targetElement.appendChild(this.viewport_);

    var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
    this.keyHandlerKeys_ = [_events2.default.listen(keyboardEventTarget, _eventtype2.default.KEYDOWN, this.handleBrowserEvent, this), _events2.default.listen(keyboardEventTarget, _eventtype2.default.KEYPRESS, this.handleBrowserEvent, this)];

    if (!this.handleResize_) {
      this.handleResize_ = this.updateSize.bind(this);
      window.addEventListener(_eventtype2.default.RESIZE, this.handleResize_, false);
    }
  }

  this.updateSize();
  // updateSize calls setSize, so no need to call this.render
  // ourselves here.
};

/**
 * @private
 */
_ol_Map_.prototype.handleTileChange_ = function () {
  this.render();
};

/**
 * @private
 */
_ol_Map_.prototype.handleViewPropertyChanged_ = function () {
  this.render();
};

/**
 * @private
 */
_ol_Map_.prototype.handleViewChanged_ = function () {
  if (this.viewPropertyListenerKey_) {
    _events2.default.unlistenByKey(this.viewPropertyListenerKey_);
    this.viewPropertyListenerKey_ = null;
  }
  if (this.viewChangeListenerKey_) {
    _events2.default.unlistenByKey(this.viewChangeListenerKey_);
    this.viewChangeListenerKey_ = null;
  }
  var view = this.getView();
  if (view) {
    this.viewport_.setAttribute('data-view', _index2.default.getUid(view));
    this.viewPropertyListenerKey_ = _events2.default.listen(view, _objecteventtype2.default.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
    this.viewChangeListenerKey_ = _events2.default.listen(view, _eventtype2.default.CHANGE, this.handleViewPropertyChanged_, this);
  }
  this.render();
};

/**
 * @private
 */
_ol_Map_.prototype.handleLayerGroupChanged_ = function () {
  if (this.layerGroupPropertyListenerKeys_) {
    this.layerGroupPropertyListenerKeys_.forEach(_events2.default.unlistenByKey);
    this.layerGroupPropertyListenerKeys_ = null;
  }
  var layerGroup = this.getLayerGroup();
  if (layerGroup) {
    this.layerGroupPropertyListenerKeys_ = [_events2.default.listen(layerGroup, _objecteventtype2.default.PROPERTYCHANGE, this.render, this), _events2.default.listen(layerGroup, _eventtype2.default.CHANGE, this.render, this)];
  }
  this.render();
};

/**
 * @return {boolean} Is rendered.
 */
_ol_Map_.prototype.isRendered = function () {
  return !!this.frameState_;
};

/**
 * Requests an immediate render in a synchronous manner.
 * @api
 */
_ol_Map_.prototype.renderSync = function () {
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
  }
  this.animationDelay_();
};

/**
 * Request a map rendering (at the next animation frame).
 * @api
 */
_ol_Map_.prototype.render = function () {
  if (this.animationDelayKey_ === undefined) {
    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
  }
};

/**
 * Remove the given control from the map.
 * @param {ol.control.Control} control Control.
 * @return {ol.control.Control|undefined} The removed control (or undefined
 *     if the control was not found).
 * @api
 */
_ol_Map_.prototype.removeControl = function (control) {
  return this.getControls().remove(control);
};

/**
 * Remove the given interaction from the map.
 * @param {ol.interaction.Interaction} interaction Interaction to remove.
 * @return {ol.interaction.Interaction|undefined} The removed interaction (or
 *     undefined if the interaction was not found).
 * @api
 */
_ol_Map_.prototype.removeInteraction = function (interaction) {
  return this.getInteractions().remove(interaction);
};

/**
 * Removes the given layer from the map.
 * @param {ol.layer.Base} layer Layer.
 * @return {ol.layer.Base|undefined} The removed layer (or undefined if the
 *     layer was not found).
 * @api
 */
_ol_Map_.prototype.removeLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  return layers.remove(layer);
};

/**
 * Remove the given overlay from the map.
 * @param {ol.Overlay} overlay Overlay.
 * @return {ol.Overlay|undefined} The removed overlay (or undefined
 *     if the overlay was not found).
 * @api
 */
_ol_Map_.prototype.removeOverlay = function (overlay) {
  return this.getOverlays().remove(overlay);
};

/**
 * @param {number} time Time.
 * @private
 */
_ol_Map_.prototype.renderFrame_ = function (time) {
  var i, ii, viewState;

  var size = this.getSize();
  var view = this.getView();
  var extent = _extent2.default.createEmpty();
  /** @type {?olx.FrameState} */
  var frameState = null;
  if (size !== undefined && _size2.default.hasArea(size) && view && view.isDef()) {
    var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    var layerStates = {};
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[_index2.default.getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
    }
    viewState = view.getState();
    frameState = /** @type {olx.FrameState} */{
      animate: false,
      attributions: {},
      coordinateToPixelTransform: this.coordinateToPixelTransform_,
      extent: extent,
      focus: !this.focus_ ? viewState.center : this.focus_,
      index: this.frameIndex_++,
      layerStates: layerStates,
      layerStatesArray: layerStatesArray,
      logos: _obj2.default.assign({}, this.logos_),
      pixelRatio: this.pixelRatio_,
      pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
      postRenderFunctions: [],
      size: size,
      skippedFeatureUids: this.skippedFeatureUids_,
      tileQueue: this.tileQueue_,
      time: time,
      usedTiles: {},
      viewState: viewState,
      viewHints: viewHints,
      wantedTiles: {}
    };
  }

  if (frameState) {
    frameState.extent = _extent2.default.getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);
  }

  this.frameState_ = frameState;
  this.renderer_.renderFrame(frameState);

  if (frameState) {
    if (frameState.animate) {
      this.render();
    }
    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

    var idle = !frameState.viewHints[_viewhint2.default.ANIMATING] && !frameState.viewHints[_viewhint2.default.INTERACTING] && !_extent2.default.equals(frameState.extent, this.previousExtent_);

    if (idle) {
      this.dispatchEvent(new _mapevent2.default(_mapeventtype2.default.MOVEEND, this, frameState));
      _extent2.default.clone(frameState.extent, this.previousExtent_);
    }
  }

  this.dispatchEvent(new _mapevent2.default(_mapeventtype2.default.POSTRENDER, this, frameState));

  setTimeout(this.handlePostRender.bind(this), 0);
};

/**
 * Sets the layergroup of this map.
 * @param {ol.layer.Group} layerGroup A layer group containing the layers in
 *     this map.
 * @observable
 * @api
 */
_ol_Map_.prototype.setLayerGroup = function (layerGroup) {
  this.set(_mapproperty2.default.LAYERGROUP, layerGroup);
};

/**
 * Set the size of this map.
 * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.
 * @observable
 * @api
 */
_ol_Map_.prototype.setSize = function (size) {
  this.set(_mapproperty2.default.SIZE, size);
};

/**
 * Set the target element to render this map into.
 * @param {Element|string|undefined} target The Element or id of the Element
 *     that the map is rendered in.
 * @observable
 * @api
 */
_ol_Map_.prototype.setTarget = function (target) {
  this.set(_mapproperty2.default.TARGET, target);
};

/**
 * Set the view for this map.
 * @param {ol.View} view The view that controls this map.
 * @observable
 * @api
 */
_ol_Map_.prototype.setView = function (view) {
  this.set(_mapproperty2.default.VIEW, view);
};

/**
 * @param {ol.Feature} feature Feature.
 */
_ol_Map_.prototype.skipFeature = function (feature) {
  var featureUid = _index2.default.getUid(feature).toString();
  this.skippedFeatureUids_[featureUid] = true;
  this.render();
};

/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * @api
 */
_ol_Map_.prototype.updateSize = function () {
  var targetElement = this.getTargetElement();

  if (!targetElement) {
    this.setSize(undefined);
  } else {
    var computedStyle = getComputedStyle(targetElement);
    this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
  }
};

/**
 * @param {ol.Feature} feature Feature.
 */
_ol_Map_.prototype.unskipFeature = function (feature) {
  var featureUid = _index2.default.getUid(feature).toString();
  delete this.skippedFeatureUids_[featureUid];
  this.render();
};

/**
 * @param {olx.MapOptions} options Map options.
 * @return {ol.MapOptionsInternal} Internal map options.
 */
_ol_Map_.createOptionsInternal = function (options) {

  /**
   * @type {Element|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }

  /**
   * @type {Object.<string, *>}
   */
  var values = {};

  var logos = {};
  if (options.logo === undefined || typeof options.logo === 'boolean' && options.logo) {
    logos[_index2.default.OL_LOGO_URL] = _index2.default.OL_URL;
  } else {
    var logo = options.logo;
    if (typeof logo === 'string') {
      logos[logo] = '';
    } else if (logo instanceof HTMLElement) {
      logos[_index2.default.getUid(logo).toString()] = logo;
    } else if (logo) {
      _asserts2.default.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.
      _asserts2.default.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.
      logos[logo.src] = logo.href;
    }
  }

  var layerGroup = options.layers instanceof _group2.default ? options.layers : new _group2.default({ layers: options.layers });
  values[_mapproperty2.default.LAYERGROUP] = layerGroup;

  values[_mapproperty2.default.TARGET] = options.target;

  values[_mapproperty2.default.VIEW] = options.view !== undefined ? options.view : new _view2.default();

  /**
   * @type {function(new: ol.renderer.Map, Element, ol.Map)}
   */
  var rendererConstructor = _map2.default;

  /**
   * @type {Array.<ol.renderer.Type>}
   */
  var rendererTypes;
  if (options.renderer !== undefined) {
    if (Array.isArray(options.renderer)) {
      rendererTypes = options.renderer;
    } else if (typeof options.renderer === 'string') {
      rendererTypes = [options.renderer];
    } else {
      _asserts2.default.assert(false, 46); // Incorrect format for `renderer` option
    }
    if (rendererTypes.indexOf( /** @type {ol.renderer.Type} */'dom') >= 0) {
      rendererTypes = rendererTypes.concat(_index2.default.DEFAULT_RENDERER_TYPES);
    }
  } else {
    rendererTypes = _index2.default.DEFAULT_RENDERER_TYPES;
  }

  var i, ii;
  for (i = 0, ii = rendererTypes.length; i < ii; ++i) {
    /** @type {ol.renderer.Type} */
    var rendererType = rendererTypes[i];
    if (_index2.default.ENABLE_CANVAS && rendererType == _type2.default.CANVAS) {
      if (_has2.default.CANVAS) {
        rendererConstructor = _map4.default;
        break;
      }
    } else if (false && rendererType == _type2.default.WEBGL) {
      if (_has2.default.WEBGL) {
        rendererConstructor = _map6.default;
        break;
      }
    }
  }

  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new _collection2.default(options.controls.slice());
    } else {
      _asserts2.default.assert(options.controls instanceof _collection2.default, 47); // Expected `controls` to be an array or an `ol.Collection`
      controls = options.controls;
    }
  } else {
    controls = _control2.default.defaults();
  }

  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new _collection2.default(options.interactions.slice());
    } else {
      _asserts2.default.assert(options.interactions instanceof _collection2.default, 48); // Expected `interactions` to be an array or an `ol.Collection`
      interactions = options.interactions;
    }
  } else {
    interactions = _interaction2.default.defaults();
  }

  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new _collection2.default(options.overlays.slice());
    } else {
      _asserts2.default.assert(options.overlays instanceof _collection2.default, 49); // Expected `overlays` to be an array or an `ol.Collection`
      overlays = options.overlays;
    }
  } else {
    overlays = new _collection2.default();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    logos: logos,
    overlays: overlays,
    rendererConstructor: rendererConstructor,
    values: values
  };
};
exports.default = _ol_Map_;


},{"./asserts":44,"./collection":47,"./collectioneventtype":48,"./control":52,"./dom":60,"./events":62,"./events/event":64,"./events/eventtype":66,"./extent":68,"./functions":78,"./has":107,"./index":110,"./interaction":111,"./layer/group":127,"./mapbrowserevent":137,"./mapbrowsereventhandler":138,"./mapbrowsereventtype":139,"./mapevent":141,"./mapeventtype":142,"./mapproperty":143,"./obj":146,"./object":147,"./objecteventtype":148,"./renderer/canvas/map":198,"./renderer/map":203,"./renderer/type":204,"./renderer/webgl/map":208,"./size":217,"./structs/priorityqueue":235,"./tilequeue":250,"./transform":254,"./view":257,"./viewhint":258}],137:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _mapevent = require('./mapevent');

var _mapevent2 = _interopRequireDefault(_mapevent);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link ol.Map} for which events trigger a map browser event.
 *
 * @constructor
 * @extends {ol.MapEvent}
 * @implements {oli.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {Event} browserEvent Browser event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapBrowserEvent_ = function (type, map, browserEvent, opt_dragging, opt_frameState) {

  _mapevent2.default.call(this, type, map, opt_frameState);

  /**
   * The original browser event.
   * @const
   * @type {Event}
   * @api
   */
  this.originalEvent = browserEvent;

  /**
   * The map pixel relative to the viewport corresponding to the original browser event.
   * @type {ol.Pixel}
   * @api
   */
  this.pixel = map.getEventPixel(browserEvent);

  /**
   * The coordinate in view projection corresponding to the original browser event.
   * @type {ol.Coordinate}
   * @api
   */
  this.coordinate = map.getCoordinateFromPixel(this.pixel);

  /**
   * Indicates if the map is currently being dragged. Only set for
   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
   *
   * @type {boolean}
   * @api
   */
  this.dragging = opt_dragging !== undefined ? opt_dragging : false;
};

_index2.default.inherits(_ol_MapBrowserEvent_, _mapevent2.default);

/**
 * Prevents the default browser action.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault
 * @override
 * @api
 */
_ol_MapBrowserEvent_.prototype.preventDefault = function () {
  _mapevent2.default.prototype.preventDefault.call(this);
  this.originalEvent.preventDefault();
};

/**
 * Prevents further propagation of the current event.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation
 * @override
 * @api
 */
_ol_MapBrowserEvent_.prototype.stopPropagation = function () {
  _mapevent2.default.prototype.stopPropagation.call(this);
  this.originalEvent.stopPropagation();
};
exports.default = _ol_MapBrowserEvent_;


},{"./index":110,"./mapevent":141}],138:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _mapbrowsereventtype = require('./mapbrowsereventtype');

var _mapbrowsereventtype2 = _interopRequireDefault(_mapbrowsereventtype);

var _mapbrowserpointerevent = require('./mapbrowserpointerevent');

var _mapbrowserpointerevent2 = _interopRequireDefault(_mapbrowserpointerevent);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require('./events/eventtarget');

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require('./pointer/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _pointereventhandler = require('./pointer/pointereventhandler');

var _pointereventhandler2 = _interopRequireDefault(_pointereventhandler);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @param {ol.Map} map The map with the viewport to listen to events on.
 * @constructor
 * @extends {ol.events.EventTarget}
 */
var _ol_MapBrowserEventHandler_ = function (map) {

  _eventtarget2.default.call(this);

  /**
   * This is the element that we will listen to the real events on.
   * @type {ol.Map}
   * @private
   */
  this.map_ = map;

  /**
   * @type {number}
   * @private
   */
  this.clickTimeoutId_ = 0;

  /**
   * @type {boolean}
   * @private
   */
  this.dragging_ = false;

  /**
   * @type {!Array.<ol.EventsKey>}
   * @private
   */
  this.dragListenerKeys_ = [];

  /**
   * The most recent "down" type event (or null if none have occurred).
   * Set on pointerdown.
   * @type {ol.pointer.PointerEvent}
   * @private
   */
  this.down_ = null;

  var element = this.map_.getViewport();

  /**
   * @type {number}
   * @private
   */
  this.activePointers_ = 0;

  /**
   * @type {!Object.<number, boolean>}
   * @private
   */
  this.trackedTouches_ = {};

  /**
   * Event handler which generates pointer events for
   * the viewport element.
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */
  this.pointerEventHandler_ = new _pointereventhandler2.default(element);

  /**
   * Event handler which generates pointer events for
   * the document (used when dragging).
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */
  this.documentPointerEventHandler_ = null;

  /**
   * @type {?ol.EventsKey}
   * @private
   */
  this.pointerdownListenerKey_ = _events2.default.listen(this.pointerEventHandler_, _eventtype2.default.POINTERDOWN, this.handlePointerDown_, this);

  /**
   * @type {?ol.EventsKey}
   * @private
   */
  this.relayedListenerKey_ = _events2.default.listen(this.pointerEventHandler_, _eventtype2.default.POINTERMOVE, this.relayEvent_, this);
};

_index2.default.inherits(_ol_MapBrowserEventHandler_, _eventtarget2.default);

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.emulateClick_ = function (pointerEvent) {
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.CLICK, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  if (this.clickTimeoutId_ !== 0) {
    // double-click
    clearTimeout(this.clickTimeoutId_);
    this.clickTimeoutId_ = 0;
    newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.DBLCLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
  } else {
    // click
    this.clickTimeoutId_ = setTimeout(function () {
      this.clickTimeoutId_ = 0;
      var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.SINGLECLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    }.bind(this), 250);
  }
};

/**
 * Keeps track on how many pointers are currently active.
 *
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function (pointerEvent) {
  var event = pointerEvent;

  if (event.type == _mapbrowsereventtype2.default.POINTERUP || event.type == _mapbrowsereventtype2.default.POINTERCANCEL) {
    delete this.trackedTouches_[event.pointerId];
  } else if (event.type == _mapbrowsereventtype2.default.POINTERDOWN) {
    this.trackedTouches_[event.pointerId] = true;
  }
  this.activePointers_ = Object.keys(this.trackedTouches_).length;
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERUP, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  // We emulate click events on left mouse button click, touch contact, and pen
  // contact. isMouseActionButton returns true in these cases (evt.button is set
  // to 0).
  // See http://www.w3.org/TR/pointerevents/#button-states
  if (!this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
    this.emulateClick_(this.down_);
  }

  if (this.activePointers_ === 0) {
    this.dragListenerKeys_.forEach(_events2.default.unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.dragging_ = false;
    this.down_ = null;
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} If the left mouse button was pressed.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function (pointerEvent) {
  return pointerEvent.button === 0;
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERDOWN, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  this.down_ = pointerEvent;

  if (this.dragListenerKeys_.length === 0) {
    /* Set up a pointer event handler on the `document`,
     * which is required when the pointer is moved outside
     * the viewport when dragging.
     */
    this.documentPointerEventHandler_ = new _pointereventhandler2.default(document);

    this.dragListenerKeys_.push(_events2.default.listen(this.documentPointerEventHandler_, _mapbrowsereventtype2.default.POINTERMOVE, this.handlePointerMove_, this), _events2.default.listen(this.documentPointerEventHandler_, _mapbrowsereventtype2.default.POINTERUP, this.handlePointerUp_, this),
    /* Note that the listener for `pointercancel is set up on
     * `pointerEventHandler_` and not `documentPointerEventHandler_` like
     * the `pointerup` and `pointermove` listeners.
     *
     * The reason for this is the following: `TouchSource.vacuumTouches_()`
     * issues `pointercancel` events, when there was no `touchend` for a
     * `touchstart`. Now, let's say a first `touchstart` is registered on
     * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
     * But `documentPointerEventHandler_` doesn't know about the first
     * `touchstart`. If there is no `touchend` for the `touchstart`, we can
     * only receive a `touchcancel` from `pointerEventHandler_`, because it is
     * only registered there.
     */
    _events2.default.listen(this.pointerEventHandler_, _mapbrowsereventtype2.default.POINTERCANCEL, this.handlePointerUp_, this));
  }
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function (pointerEvent) {
  // Fix IE10 on windows Surface : When you tap the tablet, it triggers
  // multiple pointermove events between pointerdown and pointerup with
  // the exact same coordinates of the pointerdown event. To avoid a
  // 'false' touchmove event to be dispatched , we test if the pointer
  // effectively moved.
  if (this.isMoving_(pointerEvent)) {
    this.dragging_ = true;
    var newEvent = new _mapbrowserpointerevent2.default(_mapbrowsereventtype2.default.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
    this.dispatchEvent(newEvent);
  }

  // Some native android browser triggers mousemove events during small period
  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
  // https://code.google.com/p/android/issues/detail?id=19827
  // ex: Galaxy Tab P3110 + Android 4.1.1
  pointerEvent.preventDefault();
};

/**
 * Wrap and relay a pointer event.  Note that this requires that the type
 * string for the MapBrowserPointerEvent matches the PointerEvent type.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.relayEvent_ = function (pointerEvent) {
  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
  this.dispatchEvent(new _mapbrowserpointerevent2.default(pointerEvent.type, this.map_, pointerEvent, dragging));
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} Is moving.
 * @private
 */
_ol_MapBrowserEventHandler_.prototype.isMoving_ = function (pointerEvent) {
  return pointerEvent.clientX != this.down_.clientX || pointerEvent.clientY != this.down_.clientY;
};

/**
 * @inheritDoc
 */
_ol_MapBrowserEventHandler_.prototype.disposeInternal = function () {
  if (this.relayedListenerKey_) {
    _events2.default.unlistenByKey(this.relayedListenerKey_);
    this.relayedListenerKey_ = null;
  }
  if (this.pointerdownListenerKey_) {
    _events2.default.unlistenByKey(this.pointerdownListenerKey_);
    this.pointerdownListenerKey_ = null;
  }

  this.dragListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.dragListenerKeys_.length = 0;

  if (this.documentPointerEventHandler_) {
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
  if (this.pointerEventHandler_) {
    this.pointerEventHandler_.dispose();
    this.pointerEventHandler_ = null;
  }
  _eventtarget2.default.prototype.disposeInternal.call(this);
};
exports.default = _ol_MapBrowserEventHandler_;


},{"./events":62,"./events/eventtarget":65,"./index":110,"./mapbrowsereventtype":139,"./mapbrowserpointerevent":140,"./pointer/eventtype":151,"./pointer/pointereventhandler":156}],139:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_MapBrowserEventType_ = {

  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event ol.MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event ol.MapBrowserEvent#click
   * @api
   */
  CLICK: _eventtype2.default.CLICK,

  /**
   * A true double click, with no dragging.
   * @event ol.MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: _eventtype2.default.DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event ol.MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event ol.MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};

exports.default = _ol_MapBrowserEventType_;


},{"./events/eventtype":66}],140:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _mapbrowserevent = require('./mapbrowserevent');

var _mapbrowserevent2 = _interopRequireDefault(_mapbrowserevent);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapBrowserPointerEvent_ = function (type, map, pointerEvent, opt_dragging, opt_frameState) {

  _mapbrowserevent2.default.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

  /**
   * @const
   * @type {ol.pointer.PointerEvent}
   */
  this.pointerEvent = pointerEvent;
};

_index2.default.inherits(_ol_MapBrowserPointerEvent_, _mapbrowserevent2.default);
exports.default = _ol_MapBrowserPointerEvent_;


},{"./index":110,"./mapbrowserevent":137}],141:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _event = require('./events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link ol.Map} for which events trigger a map event.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.MapEvent}
 * @param {string} type Event type.
 * @param {ol.Map} map Map.
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var _ol_MapEvent_ = function (type, map, opt_frameState) {

  _event2.default.call(this, type);

  /**
   * The map where the event occurred.
   * @type {ol.Map}
   * @api
   */
  this.map = map;

  /**
   * The frame state at the time of the event.
   * @type {?olx.FrameState}
   * @api
   */
  this.frameState = opt_frameState !== undefined ? opt_frameState : null;
};

_index2.default.inherits(_ol_MapEvent_, _event2.default);
exports.default = _ol_MapEvent_;


},{"./events/event":64,"./index":110}],142:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_MapEventType_ = {

  /**
   * Triggered after a map frame is rendered.
   * @event ol.MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered after the map is moved.
   * @event ol.MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'

};

exports.default = _ol_MapEventType_;


},{}],143:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_MapProperty_ = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};

exports.default = _ol_MapProperty_;


},{}],144:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_math_ = {};

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
_ol_math_.clamp = function (value, min, max) {
  return Math.min(Math.max(value, min), max);
};

/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
_ol_math_.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it
    cosh = Math.cosh;
  } else {
    //  else, use the reference implementation of MDN:
    cosh = function (x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();

/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
_ol_math_.roundUpToPowerOfTwo = function (x) {
  _asserts2.default.assert(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return _ol_math_.squaredDistance(x, y, x1, y1);
};

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredDistance = function (x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
_ol_math_.solveLinearSystem = function (mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
};

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
_ol_math_.toDegrees = function (angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
_ol_math_.toRadians = function (angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
_ol_math_.modulo = function (a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
_ol_math_.lerp = function (a, b, x) {
  return a + x * (b - a);
};
exports.default = _ol_math_;


},{"./asserts":44}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_net_ = {};

/**
 * Simple JSONP helper. Supports error callbacks and a custom callback param.
 * The error callback will be called when no JSONP is executed after 10 seconds.
 *
 * @param {string} url Request url. A 'callback' query parameter will be
 *     appended.
 * @param {Function} callback Callback on success.
 * @param {function()=} opt_errback Callback on error.
 * @param {string=} opt_callbackParam Custom query parameter for the JSONP
 *     callback. Default is 'callback'.
 */
_ol_net_.jsonp = function (url, callback, opt_errback, opt_callbackParam) {
  var script = document.createElement('script');
  var key = 'olc_' + _index2.default.getUid(callback);
  function cleanup() {
    delete window[key];
    script.parentNode.removeChild(script);
  }
  script.async = true;
  script.src = url + (url.indexOf('?') == -1 ? '?' : '&') + (opt_callbackParam || 'callback') + '=' + key;
  var timer = setTimeout(function () {
    cleanup();
    if (opt_errback) {
      opt_errback();
    }
  }, 10000);
  window[key] = function (data) {
    clearTimeout(timer);
    cleanup();
    callback(data);
  };
  document.getElementsByTagName('head')[0].appendChild(script);
};
exports.default = _ol_net_;


},{"./index":110}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_obj_ = {};

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
_ol_obj_.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  var arguments$1 = arguments;

  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments$1[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
_ol_obj_.clear = function (object) {
  for (var property in object) {
    delete object[property];
  }
};

/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
_ol_obj_.getValues = function (object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
};

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
_ol_obj_.isEmpty = function (object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
};
exports.default = _ol_obj_;


},{}],147:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _objecteventtype = require('./objecteventtype');

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _observable = require('./observable');

var _observable2 = _interopRequireDefault(_observable);

var _event = require('./events/event');

var _event2 = _interopRequireDefault(_event);

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link ol.Object#getProperties object.getProperties()}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {ol.Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires ol.Object.Event
 * @api
 */
var _ol_Object_ = function (opt_values) {
  _observable2.default.call(this);

  // Call ol.getUid to ensure that the order of objects' ids is the same as
  // the order in which they were created.  This also helps to ensure that
  // object properties are always added in the same order, which helps many
  // JavaScript engines generate faster code.
  _index2.default.getUid(this);

  /**
   * @private
   * @type {!Object.<string, *>}
   */
  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

_index2.default.inherits(_ol_Object_, _observable2.default);

/**
 * @private
 * @type {Object.<string, string>}
 */
_ol_Object_.changeEventTypeCache_ = {};

/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
_ol_Object_.getChangeEventType = function (key) {
  return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key) ? _ol_Object_.changeEventTypeCache_[key] : _ol_Object_.changeEventTypeCache_[key] = 'change:' + key;
};

/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */
_ol_Object_.prototype.get = function (key) {
  var value;
  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }
  return value;
};

/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */
_ol_Object_.prototype.getKeys = function () {
  return Object.keys(this.values_);
};

/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */
_ol_Object_.prototype.getProperties = function () {
  return _obj2.default.assign({}, this.values_);
};

/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */
_ol_Object_.prototype.notify = function (key, oldValue) {
  var eventType;
  eventType = _ol_Object_.getChangeEventType(key);
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
  eventType = _objecteventtype2.default.PROPERTYCHANGE;
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
};

/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
_ol_Object_.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;
    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
_ol_Object_.prototype.setProperties = function (values, opt_silent) {
  var this$1 = this;

  var key;
  for (key in values) {
    this$1.set(key, values[key], opt_silent);
  }
};

/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */
_ol_Object_.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];
    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * @classdesc
 * Events emitted by {@link ol.Object} instances are instances of this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {ol.events.Event}
 * @implements {oli.Object.Event}
 * @constructor
 */
_ol_Object_.Event = function (type, key, oldValue) {
  _event2.default.call(this, type);

  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */
  this.key = key;

  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */
  this.oldValue = oldValue;
};
_index2.default.inherits(_ol_Object_.Event, _event2.default);
exports.default = _ol_Object_;


},{"./events/event":64,"./index":110,"./obj":146,"./objecteventtype":148,"./observable":149}],148:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_ObjectEventType_ = {
  /**
   * Triggered when a property is changed.
   * @event ol.Object.Event#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};

exports.default = _ol_ObjectEventType_;


},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require('./events/eventtarget');

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link ol.Observable#changed}.
 *
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @api
 */
var _ol_Observable_ = function () {

  _eventtarget2.default.call(this);

  /**
   * @private
   * @type {number}
   */
  this.revision_ = 0;
};

_index2.default.inherits(_ol_Observable_, _eventtarget2.default);

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
_ol_Observable_.unByKey = function (key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      _events2.default.unlistenByKey(key[i]);
    }
  } else {
    _events2.default.unlistenByKey( /** @type {ol.EventsKey} */key);
  }
};

/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */
_ol_Observable_.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(_eventtype2.default.CHANGE);
};

/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event object.
 * @function
 * @api
 */
_ol_Observable_.prototype.dispatchEvent;

/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */
_ol_Observable_.prototype.getRevision = function () {
  return this.revision_;
};

/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
_ol_Observable_.prototype.on = function (type, listener, opt_this) {
  var this$1 = this;

  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = _events2.default.listen(this$1, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return _events2.default.listen(this, /** @type {string} */type, listener, opt_this);
  }
};

/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
_ol_Observable_.prototype.once = function (type, listener, opt_this) {
  var this$1 = this;

  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = _events2.default.listenOnce(this$1, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return _events2.default.listenOnce(this, /** @type {string} */type, listener, opt_this);
  }
};

/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object which was used as `this` by the
 * `listener`.
 * @api
 */
_ol_Observable_.prototype.un = function (type, listener, opt_this) {
  var this$1 = this;

  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      _events2.default.unlisten(this$1, type[i], listener, opt_this);
    }
    return;
  } else {
    _events2.default.unlisten(this, /** @type {string} */type, listener, opt_this);
  }
};
exports.default = _ol_Observable_;


},{"./events":62,"./events/eventtarget":65,"./events/eventtype":66,"./index":110}],150:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @param {!Object.<string, function(Event)>} mapping Event
 *     mapping.
 * @constructor
 */
var _ol_pointer_EventSource_ = function (dispatcher, mapping) {
  /**
   * @type {ol.pointer.PointerEventHandler}
   */
  this.dispatcher = dispatcher;

  /**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */
  this.mapping_ = mapping;
};

/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */
_ol_pointer_EventSource_.prototype.getEvents = function () {
  return Object.keys(this.mapping_);
};

/**
 * Returns a mapping between the supported event types and
 * the handlers that should handle an event.
 * @return {Object.<string, function(Event)>}
 *         Event/Handler mapping
 */
_ol_pointer_EventSource_.prototype.getMapping = function () {
  return this.mapping_;
};

/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */
_ol_pointer_EventSource_.prototype.getHandlerForEvent = function (eventType) {
  return this.mapping_[eventType];
};
exports.default = _ol_pointer_EventSource_;


},{}],151:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_pointer_EventType_ = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};

exports.default = _ol_pointer_EventType_;


},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _eventsource = require('../pointer/eventsource');

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_MouseSource_ = function (dispatcher) {
  var mapping = {
    'mousedown': this.mousedown,
    'mousemove': this.mousemove,
    'mouseup': this.mouseup,
    'mouseover': this.mouseover,
    'mouseout': this.mouseout
  };
  _eventsource2.default.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {Array.<ol.Pixel>}
   */
  this.lastTouches = [];
};

_index2.default.inherits(_ol_pointer_MouseSource_, _eventsource2.default);

/**
 * @const
 * @type {number}
 */
_ol_pointer_MouseSource_.POINTER_ID = 1;

/**
 * @const
 * @type {string}
 */
_ol_pointer_MouseSource_.POINTER_TYPE = 'mouse';

/**
 * Radius around touchend that swallows mouse events.
 *
 * @const
 * @type {number}
 */
_ol_pointer_MouseSource_.DEDUP_DIST = 25;

/**
 * Detect if a mouse event was simulated from a touch by
 * checking if previously there was a touch event at the
 * same position.
 *
 * FIXME - Known problem with the native Android browser on
 * Samsung GT-I9100 (Android 4.1.2):
 * In case the page is scrolled, this function does not work
 * correctly when a canvas is used (WebGL or canvas renderer).
 * Mouse listeners on canvas elements (for this browser), create
 * two mouse events: One 'good' and one 'bad' one (on other browsers or
 * when a div is used, there is only one event). For the 'bad' one,
 * clientX/clientY and also pageX/pageY are wrong when the page
 * is scrolled. Because of that, this function can not detect if
 * the events were simulated from a touch event. As result, a
 * pointer event at a wrong position is dispatched, which confuses
 * the map interactions.
 * It is unclear, how one can get the correct position for the event
 * or detect that the positions are invalid.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {boolean} True, if the event was generated by a touch.
 */
_ol_pointer_MouseSource_.prototype.isEventSimulatedFromTouch_ = function (inEvent) {
  var lts = this.lastTouches;
  var x = inEvent.clientX,
      y = inEvent.clientY;
  for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
    // simulated mouse events will be swallowed near a primary touchend
    var dx = Math.abs(x - t[0]),
        dy = Math.abs(y - t[1]);
    if (dx <= _ol_pointer_MouseSource_.DEDUP_DIST && dy <= _ol_pointer_MouseSource_.DEDUP_DIST) {
      return true;
    }
  }
  return false;
};

/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */
_ol_pointer_MouseSource_.prepareEvent = function (inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);

  // forward mouse preventDefault
  var pd = e.preventDefault;
  e.preventDefault = function () {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = _ol_pointer_MouseSource_.POINTER_ID;
  e.isPrimary = true;
  e.pointerType = _ol_pointer_MouseSource_.POINTER_TYPE;

  return e;
};

/**
 * Handler for `mousedown`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.mousedown = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (_ol_pointer_MouseSource_.POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
};

/**
 * Handler for `mousemove`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.mousemove = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
};

/**
 * Handler for `mouseup`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.mouseup = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
};

/**
 * Handler for `mouseover`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.mouseover = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
};

/**
 * Handler for `mouseout`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.mouseout = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
};

/**
 * Dispatches a `pointercancel` event.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MouseSource_.prototype.cancel = function (inEvent) {
  var e = _ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
  this.dispatcher.cancel(e, inEvent);
  this.cleanupMouse();
};

/**
 * Remove the mouse from the list of active pointers.
 */
_ol_pointer_MouseSource_.prototype.cleanupMouse = function () {
  delete this.pointerMap[_ol_pointer_MouseSource_.POINTER_ID.toString()];
};
exports.default = _ol_pointer_MouseSource_;


},{"../index":110,"../pointer/eventsource":150}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _eventsource = require('../pointer/eventsource');

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_MsSource_ = function (dispatcher) {
  var mapping = {
    'MSPointerDown': this.msPointerDown,
    'MSPointerMove': this.msPointerMove,
    'MSPointerUp': this.msPointerUp,
    'MSPointerOut': this.msPointerOut,
    'MSPointerOver': this.msPointerOver,
    'MSPointerCancel': this.msPointerCancel,
    'MSGotPointerCapture': this.msGotPointerCapture,
    'MSLostPointerCapture': this.msLostPointerCapture
  };
  _eventsource2.default.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {Array.<string>}
   */
  this.POINTER_TYPES = ['', 'unavailable', 'touch', 'pen', 'mouse'];
};

_index2.default.inherits(_ol_pointer_MsSource_, _eventsource2.default);

/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {Object} The copied event.
 */
_ol_pointer_MsSource_.prototype.prepareEvent_ = function (inEvent) {
  var e = inEvent;
  if (typeof inEvent.pointerType === 'number') {
    e = this.dispatcher.cloneEvent(inEvent, inEvent);
    e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
  }

  return e;
};

/**
 * Remove this pointer from the list of active pointers.
 * @param {number} pointerId Pointer identifier.
 */
_ol_pointer_MsSource_.prototype.cleanup = function (pointerId) {
  delete this.pointerMap[pointerId.toString()];
};

/**
 * Handler for `msPointerDown`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerDown = function (inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
};

/**
 * Handler for `msPointerMove`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerMove = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
};

/**
 * Handler for `msPointerUp`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerUp = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
};

/**
 * Handler for `msPointerOut`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerOut = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
};

/**
 * Handler for `msPointerOver`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerOver = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
};

/**
 * Handler for `msPointerCancel`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msPointerCancel = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
};

/**
 * Handler for `msLostPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msLostPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};

/**
 * Handler for `msGotPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_MsSource_.prototype.msGotPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
exports.default = _ol_pointer_MsSource_;


},{"../index":110,"../pointer/eventsource":150}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _eventsource = require('../pointer/eventsource');

var _eventsource2 = _interopRequireDefault(_eventsource);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_NativeSource_ = function (dispatcher) {
  var mapping = {
    'pointerdown': this.pointerDown,
    'pointermove': this.pointerMove,
    'pointerup': this.pointerUp,
    'pointerout': this.pointerOut,
    'pointerover': this.pointerOver,
    'pointercancel': this.pointerCancel,
    'gotpointercapture': this.gotPointerCapture,
    'lostpointercapture': this.lostPointerCapture
  };
  _eventsource2.default.call(this, dispatcher, mapping);
};

_index2.default.inherits(_ol_pointer_NativeSource_, _eventsource2.default);

/**
 * Handler for `pointerdown`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerDown = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointermove`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerMove = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerup`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerUp = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerout`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerOut = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerover`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerOver = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointercancel`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.pointerCancel = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `lostpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.lostPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `gotpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_NativeSource_.prototype.gotPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
exports.default = _ol_pointer_NativeSource_;


},{"../index":110,"../pointer/eventsource":150}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * A class for pointer events.
 *
 * This class is used as an abstraction for mouse events,
 * touch events and even native pointer events.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @param {string} type The type of the event to create.
 * @param {Event} originalEvent The event.
 * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of
 *    initial event properties.
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_PointerEvent_ = function (type, originalEvent, opt_eventDict) {
  _event2.default.call(this, type);

  /**
   * @const
   * @type {Event}
   */
  this.originalEvent = originalEvent;

  var eventDict = opt_eventDict ? opt_eventDict : {};

  /**
   * @type {number}
   */
  this.buttons = this.getButtons_(eventDict);

  /**
   * @type {number}
   */
  this.pressure = this.getPressure_(eventDict, this.buttons);

  // MouseEvent related properties

  /**
   * @type {boolean}
   */
  this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

  /**
   * @type {boolean}
   */
  this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

  /**
   * @type {Object}
   */
  this.view = 'view' in eventDict ? eventDict['view'] : null;

  /**
   * @type {number}
   */
  this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

  /**
   * @type {number}
   */
  this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

  /**
   * @type {number}
   */
  this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

  /**
   * @type {number}
   */
  this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

  /**
   * @type {number}
   */
  this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

  /**
   * @type {boolean}
   */
  this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

  /**
   * @type {boolean}
   */
  this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

  /**
   * @type {boolean}
   */
  this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

  /**
   * @type {boolean}
   */
  this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

  /**
   * @type {number}
   */
  this.button = 'button' in eventDict ? eventDict['button'] : 0;

  /**
   * @type {Node}
   */
  this.relatedTarget = 'relatedTarget' in eventDict ? eventDict['relatedTarget'] : null;

  // PointerEvent related properties

  /**
   * @const
   * @type {number}
   */
  this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

  /**
   * @type {number}
   */
  this.width = 'width' in eventDict ? eventDict['width'] : 0;

  /**
   * @type {number}
   */
  this.height = 'height' in eventDict ? eventDict['height'] : 0;

  /**
   * @type {number}
   */
  this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

  /**
   * @type {number}
   */
  this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

  /**
   * @type {string}
   */
  this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

  /**
   * @type {number}
   */
  this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

  /**
   * @type {boolean}
   */
  this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

  // keep the semantics of preventDefault
  if (originalEvent.preventDefault) {
    this.preventDefault = function () {
      originalEvent.preventDefault();
    };
  }
};

_index2.default.inherits(_ol_pointer_PointerEvent_, _event2.default);

/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */
_ol_pointer_PointerEvent_.prototype.getButtons_ = function (eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;
  if (eventDict.buttons || _ol_pointer_PointerEvent_.HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1:
        buttons = 1;break;
      case 2:
        buttons = 4;break;
      case 3:
        buttons = 2;break;
      default:
        buttons = 0;
    }
  }
  return buttons;
};

/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */
_ol_pointer_PointerEvent_.prototype.getPressure_ = function (eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;
  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }
  return pressure;
};

/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */
_ol_pointer_PointerEvent_.HAS_BUTTONS = false;

/**
 * Checks if the `buttons` property is supported.
 */
(function () {
  try {
    var ev = new MouseEvent('click', { buttons: 1 });
    _ol_pointer_PointerEvent_.HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
    // pass
  }
})();
exports.default = _ol_pointer_PointerEvent_;


},{"../events/event":64,"../index":110}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtarget = require('../events/eventtarget');

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _has = require('../has');

var _has2 = _interopRequireDefault(_has);

var _eventtype = require('../pointer/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _mousesource = require('../pointer/mousesource');

var _mousesource2 = _interopRequireDefault(_mousesource);

var _mssource = require('../pointer/mssource');

var _mssource2 = _interopRequireDefault(_mssource);

var _nativesource = require('../pointer/nativesource');

var _nativesource2 = _interopRequireDefault(_nativesource);

var _pointerevent = require('../pointer/pointerevent');

var _pointerevent2 = _interopRequireDefault(_pointerevent);

var _touchsource = require('../pointer/touchsource');

var _touchsource2 = _interopRequireDefault(_touchsource);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.events.EventTarget}
 * @param {Element|HTMLDocument} element Viewport element.
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_PointerEventHandler_ = function (element) {
  _eventtarget2.default.call(this);

  /**
   * @const
   * @private
   * @type {Element|HTMLDocument}
   */
  this.element_ = element;

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = {};

  /**
   * @type {Object.<string, function(Event)>}
   * @private
   */
  this.eventMap_ = {};

  /**
   * @type {Array.<ol.pointer.EventSource>}
   * @private
   */
  this.eventSourceList_ = [];

  this.registerSources();
};

_index2.default.inherits(_ol_pointer_PointerEventHandler_, _eventtarget2.default);

/**
 * Set up the event sources (mouse, touch and native pointers)
 * that generate pointer events.
 */
_ol_pointer_PointerEventHandler_.prototype.registerSources = function () {
  if (_has2.default.POINTER) {
    this.registerSource('native', new _nativesource2.default(this));
  } else if (_has2.default.MSPOINTER) {
    this.registerSource('ms', new _mssource2.default(this));
  } else {
    var mouseSource = new _mousesource2.default(this);
    this.registerSource('mouse', mouseSource);

    if (_has2.default.TOUCH) {
      this.registerSource('touch', new _touchsource2.default(this, mouseSource));
    }
  }

  // register events on the viewport element
  this.register_();
};

/**
 * Add a new event source that will generate pointer events.
 *
 * @param {string} name A name for the event source
 * @param {ol.pointer.EventSource} source The source event.
 */
_ol_pointer_PointerEventHandler_.prototype.registerSource = function (name, source) {
  var s = source;
  var newEvents = s.getEvents();

  if (newEvents) {
    newEvents.forEach(function (e) {
      var handler = s.getHandlerForEvent(e);

      if (handler) {
        this.eventMap_[e] = handler.bind(s);
      }
    }, this);
    this.eventSourceList_.push(s);
  }
};

/**
 * Set up the events for all registered event sources.
 * @private
 */
_ol_pointer_PointerEventHandler_.prototype.register_ = function () {
  var this$1 = this;

  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this$1.eventSourceList_[i];
    this$1.addEvents_(eventSource.getEvents());
  }
};

/**
 * Remove all registered events.
 * @private
 */
_ol_pointer_PointerEventHandler_.prototype.unregister_ = function () {
  var this$1 = this;

  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this$1.eventSourceList_[i];
    this$1.removeEvents_(eventSource.getEvents());
  }
};

/**
 * Calls the right handler for a new event.
 * @private
 * @param {Event} inEvent Browser event.
 */
_ol_pointer_PointerEventHandler_.prototype.eventHandler_ = function (inEvent) {
  var type = inEvent.type;
  var handler = this.eventMap_[type];
  if (handler) {
    handler(inEvent);
  }
};

/**
 * Setup listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */
_ol_pointer_PointerEventHandler_.prototype.addEvents_ = function (events) {
  events.forEach(function (eventName) {
    _events2.default.listen(this.element_, eventName, this.eventHandler_, this);
  }, this);
};

/**
 * Unregister listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */
_ol_pointer_PointerEventHandler_.prototype.removeEvents_ = function (events) {
  events.forEach(function (e) {
    _events2.default.unlisten(this.element_, e, this.eventHandler_, this);
  }, this);
};

/**
 * Returns a snapshot of inEvent, with writable properties.
 *
 * @param {Event} event Browser event.
 * @param {Event|Touch} inEvent An event that contains
 *    properties to copy.
 * @return {Object} An object containing shallow copies of
 *    `inEvent`'s properties.
 */
_ol_pointer_PointerEventHandler_.prototype.cloneEvent = function (event, inEvent) {
  var eventCopy = {},
      p;
  for (var i = 0, ii = _ol_pointer_PointerEventHandler_.CLONE_PROPS.length; i < ii; i++) {
    p = _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][0];
    eventCopy[p] = event[p] || inEvent[p] || _ol_pointer_PointerEventHandler_.CLONE_PROPS[i][1];
  }

  return eventCopy;
};

// EVENTS


/**
 * Triggers a 'pointerdown' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.down = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERDOWN, data, event);
};

/**
 * Triggers a 'pointermove' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.move = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERMOVE, data, event);
};

/**
 * Triggers a 'pointerup' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.up = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERUP, data, event);
};

/**
 * Triggers a 'pointerenter' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.enter = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_eventtype2.default.POINTERENTER, data, event);
};

/**
 * Triggers a 'pointerleave' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.leave = function (data, event) {
  data.bubbles = false;
  this.fireEvent(_eventtype2.default.POINTERLEAVE, data, event);
};

/**
 * Triggers a 'pointerover' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.over = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_eventtype2.default.POINTEROVER, data, event);
};

/**
 * Triggers a 'pointerout' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.out = function (data, event) {
  data.bubbles = true;
  this.fireEvent(_eventtype2.default.POINTEROUT, data, event);
};

/**
 * Triggers a 'pointercancel' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.cancel = function (data, event) {
  this.fireEvent(_eventtype2.default.POINTERCANCEL, data, event);
};

/**
 * Triggers a combination of 'pointerout' and 'pointerleave' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.leaveOut = function (data, event) {
  this.out(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.leave(data, event);
  }
};

/**
 * Triggers a combination of 'pointerover' and 'pointerevents' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.enterOver = function (data, event) {
  this.over(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.enter(data, event);
  }
};

/**
 * @private
 * @param {Element} container The container element.
 * @param {Element} contained The contained element.
 * @return {boolean} Returns true if the container element
 *   contains the other element.
 */
_ol_pointer_PointerEventHandler_.prototype.contains_ = function (container, contained) {
  if (!container || !contained) {
    return false;
  }
  return container.contains(contained);
};

// EVENT CREATION AND TRACKING
/**
 * Creates a new Event of type `inType`, based on the information in
 * `data`.
 *
 * @param {string} inType A string representing the type of event to create.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.
 */
_ol_pointer_PointerEventHandler_.prototype.makeEvent = function (inType, data, event) {
  return new _pointerevent2.default(inType, event, data);
};

/**
 * Make and dispatch an event in one call.
 * @param {string} inType A string representing the type of event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
_ol_pointer_PointerEventHandler_.prototype.fireEvent = function (inType, data, event) {
  var e = this.makeEvent(inType, data, event);
  this.dispatchEvent(e);
};

/**
 * Creates a pointer event from a native pointer event
 * and dispatches this event.
 * @param {Event} event A platform event with a target.
 */
_ol_pointer_PointerEventHandler_.prototype.fireNativeEvent = function (event) {
  var e = this.makeEvent(event.type, event, event);
  this.dispatchEvent(e);
};

/**
 * Wrap a native mouse event into a pointer event.
 * This proxy method is required for the legacy IE support.
 * @param {string} eventType The pointer event type.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} The wrapped event.
 */
_ol_pointer_PointerEventHandler_.prototype.wrapMouseEvent = function (eventType, event) {
  var pointerEvent = this.makeEvent(eventType, _mousesource2.default.prepareEvent(event, this), event);
  return pointerEvent;
};

/**
 * @inheritDoc
 */
_ol_pointer_PointerEventHandler_.prototype.disposeInternal = function () {
  this.unregister_();
  _eventtarget2.default.prototype.disposeInternal.call(this);
};

/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */
_ol_pointer_PointerEventHandler_.CLONE_PROPS = [
// MouseEvent
['bubbles', false], ['cancelable', false], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', false], ['altKey', false], ['shiftKey', false], ['metaKey', false], ['button', 0], ['relatedTarget', null],
// DOM Level 3
['buttons', 0],
// PointerEvent
['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', false],
// event instance
['type', ''], ['target', null], ['currentTarget', null], ['which', 0]];
exports.default = _ol_pointer_PointerEventHandler_;


},{"../events":62,"../events/eventtarget":65,"../has":107,"../index":110,"../pointer/eventtype":151,"../pointer/mousesource":152,"../pointer/mssource":153,"../pointer/nativesource":154,"../pointer/pointerevent":155,"../pointer/touchsource":157}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _eventsource = require('../pointer/eventsource');

var _eventsource2 = _interopRequireDefault(_eventsource);

var _mousesource = require('../pointer/mousesource');

var _mousesource2 = _interopRequireDefault(_mousesource);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.
 * @param {ol.pointer.MouseSource} mouseSource Mouse source.
 * @extends {ol.pointer.EventSource}
 */
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var _ol_pointer_TouchSource_ = function (dispatcher, mouseSource) {
  var mapping = {
    'touchstart': this.touchstart,
    'touchmove': this.touchmove,
    'touchend': this.touchend,
    'touchcancel': this.touchcancel
  };
  _eventsource2.default.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {ol.pointer.MouseSource}
   */
  this.mouseSource = mouseSource;

  /**
   * @private
   * @type {number|undefined}
   */
  this.firstTouchId_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.clickCount_ = 0;

  /**
   * @private
   * @type {number|undefined}
   */
  this.resetId_ = undefined;
};

_index2.default.inherits(_ol_pointer_TouchSource_, _eventsource2.default);

/**
 * Mouse event timeout: This should be long enough to
 * ignore compat mouse events made by touch.
 * @const
 * @type {number}
 */
_ol_pointer_TouchSource_.DEDUP_TIMEOUT = 2500;

/**
 * @const
 * @type {number}
 */
_ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT = 200;

/**
 * @const
 * @type {string}
 */
_ol_pointer_TouchSource_.POINTER_TYPE = 'touch';

/**
 * @private
 * @param {Touch} inTouch The in touch.
 * @return {boolean} True, if this is the primary touch.
 */
_ol_pointer_TouchSource_.prototype.isPrimaryTouch_ = function (inTouch) {
  return this.firstTouchId_ === inTouch.identifier;
};

/**
 * Set primary touch if there are no pointers, or the only pointer is the mouse.
 * @param {Touch} inTouch The in touch.
 * @private
 */
_ol_pointer_TouchSource_.prototype.setPrimaryTouch_ = function (inTouch) {
  var count = Object.keys(this.pointerMap).length;
  if (count === 0 || count === 1 && _mousesource2.default.POINTER_ID.toString() in this.pointerMap) {
    this.firstTouchId_ = inTouch.identifier;
    this.cancelResetClickCount_();
  }
};

/**
 * @private
 * @param {Object} inPointer The in pointer object.
 */
_ol_pointer_TouchSource_.prototype.removePrimaryPointer_ = function (inPointer) {
  if (inPointer.isPrimary) {
    this.firstTouchId_ = undefined;
    this.resetClickCount_();
  }
};

/**
 * @private
 */
_ol_pointer_TouchSource_.prototype.resetClickCount_ = function () {
  this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), _ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT);
};

/**
 * @private
 */
_ol_pointer_TouchSource_.prototype.resetClickCountHandler_ = function () {
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};

/**
 * @private
 */
_ol_pointer_TouchSource_.prototype.cancelResetClickCount_ = function () {
  if (this.resetId_ !== undefined) {
    clearTimeout(this.resetId_);
  }
};

/**
 * @private
 * @param {Event} browserEvent Browser event
 * @param {Touch} inTouch Touch event
 * @return {Object} A pointer object.
 */
_ol_pointer_TouchSource_.prototype.touchToPointer_ = function (browserEvent, inTouch) {
  var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
  // Spec specifies that pointerId 1 is reserved for Mouse.
  // Touch identifiers can start at 0.
  // Add 2 to the touch identifier for compatibility.
  e.pointerId = inTouch.identifier + 2;
  // TODO: check if this is necessary?
  //e.target = findTarget(e);
  e.bubbles = true;
  e.cancelable = true;
  e.detail = this.clickCount_;
  e.button = 0;
  e.buttons = 1;
  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
  e.isPrimary = this.isPrimaryTouch_(inTouch);
  e.pointerType = _ol_pointer_TouchSource_.POINTER_TYPE;

  // make sure that the properties that are different for
  // each `Touch` object are not copied from the BrowserEvent object
  e.clientX = inTouch.clientX;
  e.clientY = inTouch.clientY;
  e.screenX = inTouch.screenX;
  e.screenY = inTouch.screenY;

  return e;
};

/**
 * @private
 * @param {Event} inEvent Touch event
 * @param {function(Event, Object)} inFunction In function.
 */
_ol_pointer_TouchSource_.prototype.processTouches_ = function (inEvent, inFunction) {
  var this$1 = this;

  var touches = Array.prototype.slice.call(inEvent.changedTouches);
  var count = touches.length;
  function preventDefault() {
    inEvent.preventDefault();
  }
  var i, pointer;
  for (i = 0; i < count; ++i) {
    pointer = this$1.touchToPointer_(inEvent, touches[i]);
    // forward touch preventDefaults
    pointer.preventDefault = preventDefault;
    inFunction.call(this$1, inEvent, pointer);
  }
};

/**
 * @private
 * @param {TouchList} touchList The touch list.
 * @param {number} searchId Search identifier.
 * @return {boolean} True, if the `Touch` with the given id is in the list.
 */
_ol_pointer_TouchSource_.prototype.findTouch_ = function (touchList, searchId) {
  var l = touchList.length;
  var touch;
  for (var i = 0; i < l; i++) {
    touch = touchList[i];
    if (touch.identifier === searchId) {
      return true;
    }
  }
  return false;
};

/**
 * In some instances, a touchstart can happen without a touchend. This
 * leaves the pointermap in a broken state.
 * Therefore, on every touchstart, we remove the touches that did not fire a
 * touchend event.
 * To keep state globally consistent, we fire a pointercancel for
 * this "abandoned" touch
 *
 * @private
 * @param {Event} inEvent The in event.
 */
_ol_pointer_TouchSource_.prototype.vacuumTouches_ = function (inEvent) {
  var this$1 = this;

  var touchList = inEvent.touches;
  // pointerMap.getCount() should be < touchList.length here,
  // as the touchstart has not been processed yet.
  var keys = Object.keys(this.pointerMap);
  var count = keys.length;
  if (count >= touchList.length) {
    var d = [];
    var i, key, value;
    for (i = 0; i < count; ++i) {
      key = keys[i];
      value = this$1.pointerMap[key];
      // Never remove pointerId == 1, which is mouse.
      // Touch identifiers are 2 smaller than their pointerId, which is the
      // index in pointermap.
      if (key != _mousesource2.default.POINTER_ID && !this$1.findTouch_(touchList, key - 2)) {
        d.push(value.out);
      }
    }
    for (i = 0; i < d.length; ++i) {
      this$1.cancelOut_(inEvent, d[i]);
    }
  }
};

/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_TouchSource_.prototype.touchstart = function (inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer object.
 */
_ol_pointer_TouchSource_.prototype.overDown_ = function (browserEvent, inPointer) {
  this.pointerMap[inPointer.pointerId] = {
    target: inPointer.target,
    out: inPointer,
    outTarget: inPointer.target
  };
  this.dispatcher.over(inPointer, browserEvent);
  this.dispatcher.enter(inPointer, browserEvent);
  this.dispatcher.down(inPointer, browserEvent);
};

/**
 * Handler for `touchmove`.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_TouchSource_.prototype.touchmove = function (inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */
_ol_pointer_TouchSource_.prototype.moveOverOut_ = function (browserEvent, inPointer) {
  var event = inPointer;
  var pointer = this.pointerMap[event.pointerId];
  // a finger drifted off the screen, ignore it
  if (!pointer) {
    return;
  }
  var outEvent = pointer.out;
  var outTarget = pointer.outTarget;
  this.dispatcher.move(event, browserEvent);
  if (outEvent && outTarget !== event.target) {
    outEvent.relatedTarget = event.target;
    event.relatedTarget = outTarget;
    // recover from retargeting by shadow
    outEvent.target = outTarget;
    if (event.target) {
      this.dispatcher.leaveOut(outEvent, browserEvent);
      this.dispatcher.enterOver(event, browserEvent);
    } else {
      // clean up case when finger leaves the screen
      event.target = outTarget;
      event.relatedTarget = null;
      this.cancelOut_(browserEvent, event);
    }
  }
  pointer.out = event;
  pointer.outTarget = event.target;
};

/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The event.
 */
_ol_pointer_TouchSource_.prototype.touchend = function (inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
};

/**
 * @private
 * @param {Event} browserEvent An event.
 * @param {Object} inPointer The inPointer object.
 */
_ol_pointer_TouchSource_.prototype.upOut_ = function (browserEvent, inPointer) {
  this.dispatcher.up(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};

/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The in event.
 */
_ol_pointer_TouchSource_.prototype.touchcancel = function (inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */
_ol_pointer_TouchSource_.prototype.cancelOut_ = function (browserEvent, inPointer) {
  this.dispatcher.cancel(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};

/**
 * @private
 * @param {Object} inPointer The inPointer object.
 */
_ol_pointer_TouchSource_.prototype.cleanUpPointer_ = function (inPointer) {
  delete this.pointerMap[inPointer.pointerId];
  this.removePrimaryPointer_(inPointer);
};

/**
 * Prevent synth mouse events from creating pointer events.
 *
 * @private
 * @param {Event} inEvent The in event.
 */
_ol_pointer_TouchSource_.prototype.dedupSynthMouse_ = function (inEvent) {
  var lts = this.mouseSource.lastTouches;
  var t = inEvent.changedTouches[0];
  // only the primary finger will synth mouse events
  if (this.isPrimaryTouch_(t)) {
    // remember x/y of last touch
    var lt = [t.clientX, t.clientY];
    lts.push(lt);

    setTimeout(function () {
      // remove touch after timeout
      _array2.default.remove(lts, lt);
    }, _ol_pointer_TouchSource_.DEDUP_TIMEOUT);
  }
};
exports.default = _ol_pointer_TouchSource_;


},{"../array":42,"../index":110,"../pointer/eventsource":150,"../pointer/mousesource":152}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('./extent');

var _extent2 = _interopRequireDefault(_extent);

var _epsg = require('./proj/epsg3857');

var _epsg2 = _interopRequireDefault(_epsg);

var _epsg3 = require('./proj/epsg4326');

var _epsg4 = _interopRequireDefault(_epsg3);

var _projection = require('./proj/projection');

var _projection2 = _interopRequireDefault(_projection);

var _units = require('./proj/units');

var _units2 = _interopRequireDefault(_units);

var _proj = require('./proj/proj4');

var _proj2 = _interopRequireDefault(_proj);

var _projections = require('./proj/projections');

var _projections2 = _interopRequireDefault(_projections);

var _transforms = require('./proj/transforms');

var _transforms2 = _interopRequireDefault(_transforms);

var _normal = require('./sphere/normal');

var _normal2 = _interopRequireDefault(_normal);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_proj_ = {};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */
_ol_proj_.METERS_PER_UNIT = _units2.default.METERS_PER_UNIT;

if (_index2.default.ENABLE_PROJ4JS) {
  /**
   * Register proj4. If not explicitly registered, it will be assumed that
   * proj4js will be loaded in the global namespace. For example in a
   * browserify ES6 environment you could use:
   *
   *     import ol from 'openlayers';
   *     import proj4 from 'proj4';
   *     ol.proj.setProj4(proj4);
   *
   * @param {Proj4} proj4 Proj4.
   * @api
   */
  _ol_proj_.setProj4 = function (proj4) {
    _proj2.default.set(proj4);
  };
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * @param {ol.proj.Projection} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {ol.Coordinate} point Point to find adjusted resolution at.
 * @return {number} Point resolution at point in projection units.
 * @api
 */
_ol_proj_.getPointResolution = function (projection, resolution, point) {
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == _units2.default.DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = _normal2.default.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = _normal2.default.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
};

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<ol.proj.Projection>} projections Projections.
 * @api
 */
_ol_proj_.addEquivalentProjections = function (projections) {
  _ol_proj_.addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        _transforms2.default.add(source, destination, _ol_proj_.cloneTransform);
      }
    });
  });
};

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<ol.proj.Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<ol.proj.Projection>} projections2 Projections with equal
 *     meaning.
 * @param {ol.TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {ol.TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      _transforms2.default.add(projection1, projection2, forwardTransform);
      _transforms2.default.add(projection2, projection1, inverseTransform);
    });
  });
};

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {ol.proj.Projection} projection Projection instance.
 * @api
 */
_ol_proj_.addProjection = function (projection) {
  _projections2.default.add(projection.getCode(), projection);
  _transforms2.default.add(projection, projection, _ol_proj_.cloneTransform);
};

/**
 * @param {Array.<ol.proj.Projection>} projections Projections.
 */
_ol_proj_.addProjections = function (projections) {
  var addedProjections = [];
  projections.forEach(function (projection) {
    addedProjections.push(_ol_proj_.addProjection(projection));
  });
};

/**
 * Clear all cached projections and transforms.
 */
_ol_proj_.clearAllProjections = function () {
  _projections2.default.clear();
  _transforms2.default.clear();
};

/**
 * @param {ol.proj.Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {ol.proj.Projection} Projection.
 */
_ol_proj_.createProjection = function (projection, defaultCode) {
  if (!projection) {
    return _ol_proj_.get(defaultCode);
  } else if (typeof projection === 'string') {
    return _ol_proj_.get(projection);
  } else {
    return (/** @type {ol.proj.Projection} */projection
    );
  }
};

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ol.ProjectionLike} source Source projection.
 * @param {ol.ProjectionLike} destination Destination projection.
 * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @api
 */
_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {
  var sourceProj = _ol_proj_.get(source);
  var destProj = _ol_proj_.get(destination);
  _transforms2.default.add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));
  _transforms2.default.add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));
};

/**
 * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate
 *     transform.
 * @return {ol.TransformFunction} Transform function.
 */
_ol_proj_.createTransformFromCoordinateTransform = function (transform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      var point, i, j;
      for (i = 0; i < length; i += dimension) {
        point = transform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    }
  );
};

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ol.ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate projected to the target projection.
 * @api
 */
_ol_proj_.fromLonLat = function (coordinate, opt_projection) {
  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
};

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {ol.Coordinate} coordinate Projected coordinate.
 * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
_ol_proj_.toLonLat = function (coordinate, opt_projection) {
  return _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
};

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ol.ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {ol.proj.Projection} Projection object, or null if not in list.
 * @api
 */
_ol_proj_.get = function (projectionLike) {
  var projection = null;
  if (projectionLike instanceof _projection2.default) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = _projections2.default.get(code);
    if (_index2.default.ENABLE_PROJ4JS) {
      var proj4js = _proj2.default.get();
      if (!projection && typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {
        projection = new _projection2.default({ code: code });
        _ol_proj_.addProjection(projection);
      }
    }
  }
  return projection;
};

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {ol.proj.Projection} projection1 Projection 1.
 * @param {ol.proj.Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
_ol_proj_.equivalent = function (projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);
    return transformFn === _ol_proj_.cloneTransform && equalUnits;
  }
};

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ol.ProjectionLike} source Source.
 * @param {ol.ProjectionLike} destination Destination.
 * @return {ol.TransformFunction} Transform function.
 * @api
 */
_ol_proj_.getTransform = function (source, destination) {
  var sourceProjection = _ol_proj_.get(source);
  var destinationProjection = _ol_proj_.get(destination);
  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
};

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {ol.proj.Projection} sourceProjection Source Projection object.
 * @param {ol.proj.Projection} destinationProjection Destination Projection
 *     object.
 * @return {ol.TransformFunction} Transform function.
 */
_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transform = _transforms2.default.get(sourceCode, destinationCode);
  if (_index2.default.ENABLE_PROJ4JS && !transform) {
    var proj4js = _proj2.default.get();
    if (typeof proj4js == 'function') {
      var sourceDef = proj4js.defs(sourceCode);
      var destinationDef = proj4js.defs(destinationCode);

      if (sourceDef !== undefined && destinationDef !== undefined) {
        if (sourceDef === destinationDef) {
          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);
        } else {
          var proj4Transform = proj4js(destinationCode, sourceCode);
          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);
        }
        transform = _transforms2.default.get(sourceCode, destinationCode);
      }
    }
  }
  if (!transform) {
    transform = _ol_proj_.identityTransform;
  }
  return transform;
};

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */
_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
};

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
};

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_proj_.transform = function (coordinate, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);
  return transformFn(coordinate, undefined, coordinate.length);
};

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {ol.Extent} extent The extent to transform.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Extent} The transformed extent.
 * @api
 */
_ol_proj_.transformExtent = function (extent, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);
  return _extent2.default.applyTransform(extent, transformFn);
};

/**
 * Transforms the given point to the destination projection.
 *
 * @param {ol.Coordinate} point Point.
 * @param {ol.proj.Projection} sourceProjection Source projection.
 * @param {ol.proj.Projection} destinationProjection Destination projection.
 * @return {ol.Coordinate} Point.
 */
_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {
  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFn(point);
};

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `ol.proj.clearAllProjections()` is called (e.g. in tests).
 */
_ol_proj_.addCommon = function () {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  _ol_proj_.addEquivalentProjections(_epsg2.default.PROJECTIONS);
  _ol_proj_.addEquivalentProjections(_epsg4.default.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  _ol_proj_.addEquivalentTransforms(_epsg4.default.PROJECTIONS, _epsg2.default.PROJECTIONS, _epsg2.default.fromEPSG4326, _epsg2.default.toEPSG4326);
};

_ol_proj_.addCommon();
exports.default = _ol_proj_;


},{"./extent":68,"./index":110,"./proj/epsg3857":159,"./proj/epsg4326":160,"./proj/proj4":161,"./proj/projection":162,"./proj/projections":163,"./proj/transforms":164,"./proj/units":165,"./sphere/normal":230}],159:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

var _projection = require('../proj/projection');

var _projection2 = _interopRequireDefault(_projection);

var _units = require('../proj/units');

var _units2 = _interopRequireDefault(_units);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_proj_EPSG3857_ = {};

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @private
 */
_ol_proj_EPSG3857_.Projection_ = function (code) {
  _projection2.default.call(this, {
    code: code,
    units: _units2.default.METERS,
    extent: _ol_proj_EPSG3857_.EXTENT,
    global: true,
    worldExtent: _ol_proj_EPSG3857_.WORLD_EXTENT,
    getPointResolution: function (resolution, point) {
      return resolution / _math2.default.cosh(point[1] / _ol_proj_EPSG3857_.RADIUS);
    }
  });
};
_index2.default.inherits(_ol_proj_EPSG3857_.Projection_, _projection2.default);

/**
 * @const
 * @type {number}
 */
_ol_proj_EPSG3857_.RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
_ol_proj_EPSG3857_.HALF_SIZE = Math.PI * _ol_proj_EPSG3857_.RADIUS;

/**
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG3857_.EXTENT = [-_ol_proj_EPSG3857_.HALF_SIZE, -_ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE];

/**
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG3857_.WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Lists several projection codes with the same meaning as EPSG:3857.
 *
 * @type {Array.<string>}
 */
_ol_proj_EPSG3857_.CODES = ['EPSG:3857', 'EPSG:102100', 'EPSG:102113', 'EPSG:900913', 'urn:ogc:def:crs:EPSG:6.18:3:3857', 'urn:ogc:def:crs:EPSG::3857', 'http://www.opengis.net/gml/srs/epsg.xml#3857'];

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */
_ol_proj_EPSG3857_.PROJECTIONS = _ol_proj_EPSG3857_.CODES.map(function (code) {
  return new _ol_proj_EPSG3857_.Projection_(code);
});

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
_ol_proj_EPSG3857_.fromEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = _ol_proj_EPSG3857_.HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = _ol_proj_EPSG3857_.RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
};

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
_ol_proj_EPSG3857_.toEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / _ol_proj_EPSG3857_.HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / _ol_proj_EPSG3857_.RADIUS)) / Math.PI - 90;
  }
  return output;
};
exports.default = _ol_proj_EPSG3857_;


},{"../index":110,"../math":144,"../proj/projection":162,"../proj/units":165}],160:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _projection = require('../proj/projection');

var _projection2 = _interopRequireDefault(_projection);

var _units = require('../proj/units');

var _units2 = _interopRequireDefault(_units);

var _wgs = require('../sphere/wgs84');

var _wgs2 = _interopRequireDefault(_wgs);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_proj_EPSG4326_ = {};

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 * @private
 */
_ol_proj_EPSG4326_.Projection_ = function (code, opt_axisOrientation) {
  _projection2.default.call(this, {
    code: code,
    units: _units2.default.DEGREES,
    extent: _ol_proj_EPSG4326_.EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: _ol_proj_EPSG4326_.METERS_PER_UNIT,
    worldExtent: _ol_proj_EPSG4326_.EXTENT
  });
};
_index2.default.inherits(_ol_proj_EPSG4326_.Projection_, _projection2.default);

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG4326_.EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
_ol_proj_EPSG4326_.METERS_PER_UNIT = Math.PI * _wgs2.default.radius / 180;

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */
_ol_proj_EPSG4326_.PROJECTIONS = [new _ol_proj_EPSG4326_.Projection_('CRS:84'), new _ol_proj_EPSG4326_.Projection_('EPSG:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'), new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')];
exports.default = _ol_proj_EPSG4326_;


},{"../index":110,"../proj/projection":162,"../proj/units":165,"../sphere/wgs84":231}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_proj_proj4_ = {};

/**
 * @private
 * @type {Proj4}
 */
_ol_proj_proj4_.cache_ = null;

/**
 * Store the proj4 function.
 * @param {Proj4} proj4 The proj4 function.
 */
_ol_proj_proj4_.set = function (proj4) {
  _ol_proj_proj4_.cache_ = proj4;
};

/**
 * Get proj4.
 * @return {Proj4} The proj4 function set above or available globally.
 */
_ol_proj_proj4_.get = function () {
  return _ol_proj_proj4_.cache_ || window['proj4'];
};
exports.default = _ol_proj_proj4_;


},{}],162:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _units = require('../proj/units');

var _units2 = _interopRequireDefault(_units);

var _proj = require('../proj/proj4');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link ol.proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link ol.proj.setProj4}.
 *
 * @constructor
 * @param {olx.ProjectionOptions} options Projection options.
 * @struct
 * @api
 */
var _ol_proj_Projection_ = function (options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * @private
   * @type {ol.proj.Units}
   */
  this.units_ = /** @type {ol.proj.Units} */options.units;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
  * @private
  * @type {function(number, ol.Coordinate):number|undefined}
  */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;

  var code = options.code;
  if (_index2.default.ENABLE_PROJ4JS) {
    var proj4js = _proj2.default.get();
    if (typeof proj4js == 'function') {
      var def = proj4js.defs(code);
      if (def !== undefined) {
        if (def.axis !== undefined && options.axisOrientation === undefined) {
          this.axisOrientation_ = def.axis;
        }
        if (options.metersPerUnit === undefined) {
          this.metersPerUnit_ = def.to_meter;
        }
        if (options.units === undefined) {
          this.units_ = def.units;
        }
      }
    }
  }
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
_ol_proj_Projection_.prototype.canWrapX = function () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
_ol_proj_Projection_.prototype.getCode = function () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_proj_Projection_.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {ol.proj.Units} Units.
 * @api
 */
_ol_proj_Projection_.prototype.getUnits = function () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
_ol_proj_Projection_.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || _units2.default.METERS_PER_UNIT[this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_proj_Projection_.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 */
_ol_proj_Projection_.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
_ol_proj_Projection_.prototype.isGlobal = function () {
  return this.global_;
};

/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/
_ol_proj_Projection_.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {ol.tilegrid.TileGrid} The default tile grid.
 */
_ol_proj_Projection_.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};

/**
 * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.
 */
_ol_proj_Projection_.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {ol.Extent} extent Extent.
 * @api
 */
_ol_proj_Projection_.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {ol.Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */
_ol_proj_Projection_.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function for this projection.
 * @param {function(number, ol.Coordinate):number} func Function
 * @api
 */
_ol_proj_Projection_.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, ol.Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
_ol_proj_Projection_.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};
exports.default = _ol_proj_Projection_;


},{"../index":110,"../proj/proj4":161,"../proj/units":165}],163:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_proj_projections_ = {};

/**
 * @private
 * @type {Object.<string, ol.proj.Projection>}
 */
_ol_proj_projections_.cache_ = {};

/**
 * Clear the projections cache.
 */
_ol_proj_projections_.clear = function () {
  _ol_proj_projections_.cache_ = {};
};

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {ol.proj.Projection} The projection (if cached).
 */
_ol_proj_projections_.get = function (code) {
  var projections = _ol_proj_projections_.cache_;
  return projections[code] || null;
};

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {ol.proj.Projection} projection The projection to cache.
 */
_ol_proj_projections_.add = function (code, projection) {
  var projections = _ol_proj_projections_.cache_;
  projections[code] = projection;
};
exports.default = _ol_proj_projections_;


},{}],164:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_proj_transforms_ = {};

/**
 * @private
 * @type {Object.<string, Object.<string, ol.TransformFunction>>}
 */
_ol_proj_transforms_.cache_ = {};

/**
 * Clear the transform cache.
 */
_ol_proj_transforms_.clear = function () {
  _ol_proj_transforms_.cache_ = {};
};

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {ol.proj.Projection} source Source.
 * @param {ol.proj.Projection} destination Destination.
 * @param {ol.TransformFunction} transformFn Transform.
 */
_ol_proj_transforms_.add = function (source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
};

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {ol.proj.Projection} source Source projection.
 * @param {ol.proj.Projection} destination Destination projection.
 * @return {ol.TransformFunction} transformFn The unregistered transform.
 */
_ol_proj_transforms_.remove = function (source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (_obj2.default.isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
};

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {ol.TransformFunction|undefined} The transform function (if found).
 */
_ol_proj_transforms_.get = function (sourceCode, destinationCode) {
  var transform;
  var transforms = _ol_proj_transforms_.cache_;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
};
exports.default = _ol_proj_transforms_;


},{"../obj":146}],165:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _normal = require('../sphere/normal');

var _normal2 = _interopRequireDefault(_normal);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var _ol_proj_Units_ = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */
_ol_proj_Units_.METERS_PER_UNIT = {};
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES] = 2 * Math.PI * _normal2.default.radius / 360;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET] = 0.3048;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS] = 1;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET] = 1200 / 3937;
exports.default = _ol_proj_Units_;


},{"../sphere/normal":230}],166:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _disposable = require('../disposable');

var _disposable2 = _interopRequireDefault(_disposable);

var _polygon = require('../geom/polygon');

var _polygon2 = _interopRequireDefault(_polygon);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.Disposable}
 * @param {string} className CSS class name.
 */
var _ol_render_Box_ = function (className) {

  /**
   * @type {ol.geom.Polygon}
   * @private
   */
  this.geometry_ = null;

  /**
   * @type {HTMLDivElement}
   * @private
   */
  this.element_ = /** @type {HTMLDivElement} */document.createElement('div');
  this.element_.style.position = 'absolute';
  this.element_.className = 'ol-box ' + className;

  /**
   * @private
   * @type {ol.Map}
   */
  this.map_ = null;

  /**
   * @private
   * @type {ol.Pixel}
   */
  this.startPixel_ = null;

  /**
   * @private
   * @type {ol.Pixel}
   */
  this.endPixel_ = null;
}; // FIXME add rotation

_index2.default.inherits(_ol_render_Box_, _disposable2.default);

/**
 * @inheritDoc
 */
_ol_render_Box_.prototype.disposeInternal = function () {
  this.setMap(null);
};

/**
 * @private
 */
_ol_render_Box_.prototype.render_ = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var px = 'px';
  var style = this.element_.style;
  style.left = Math.min(startPixel[0], endPixel[0]) + px;
  style.top = Math.min(startPixel[1], endPixel[1]) + px;
  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
};

/**
 * @param {ol.Map} map Map.
 */
_ol_render_Box_.prototype.setMap = function (map) {
  if (this.map_) {
    this.map_.getOverlayContainer().removeChild(this.element_);
    var style = this.element_.style;
    style.left = style.top = style.width = style.height = 'inherit';
  }
  this.map_ = map;
  if (this.map_) {
    this.map_.getOverlayContainer().appendChild(this.element_);
  }
};

/**
 * @param {ol.Pixel} startPixel Start pixel.
 * @param {ol.Pixel} endPixel End pixel.
 */
_ol_render_Box_.prototype.setPixels = function (startPixel, endPixel) {
  this.startPixel_ = startPixel;
  this.endPixel_ = endPixel;
  this.createOrUpdateGeometry();
  this.render_();
};

/**
 * Creates or updates the cached geometry.
 */
_ol_render_Box_.prototype.createOrUpdateGeometry = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
  var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
  // close the polygon
  coordinates[4] = coordinates[0].slice();
  if (!this.geometry_) {
    this.geometry_ = new _polygon2.default([coordinates]);
  } else {
    this.geometry_.setCoordinates([coordinates]);
  }
};

/**
 * @return {ol.geom.Polygon} Geometry.
 */
_ol_render_Box_.prototype.getGeometry = function () {
  return this.geometry_;
};
exports.default = _ol_render_Box_;


},{"../disposable":59,"../geom/polygon":105,"../index":110}],167:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_render_canvas_ = {};

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultFont = '10px sans-serif';

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineCap = 'round';

/**
 * @const
 * @type {Array.<number>}
 */
_ol_render_canvas_.defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineDashOffset = 0;

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultMiterLimit = 10;

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextAlign = 'center';

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextBaseline = 'middle';

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineWidth = 1;

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
_ol_render_canvas_.rotateAtOffset = function (context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};
exports.default = _ol_render_canvas_;


},{}],168:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _instruction = require('../canvas/instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require('../canvas/replay');

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_ImageReplay_ = function (tolerance, maxExtent, resolution, overlaps) {
  _replay2.default.call(this, tolerance, maxExtent, resolution, overlaps);

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.hitDetectionImage_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.image_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.anchorX_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.anchorY_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.height_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.opacity_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.originX_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.originY_ = undefined;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.rotateWithView_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.rotation_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.scale_ = undefined;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.snapToPixel_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = undefined;
};

_index2.default.inherits(_ol_render_canvas_ImageReplay_, _replay2.default);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */
_ol_render_canvas_ImageReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(pointGeometry, feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.image_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(pointGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(multiPointGeometry, feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.image_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([_instruction2.default.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(multiPointGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ImageReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  // FIXME this doesn't really protect us against further calls to draw*Geometry
  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.height_ = undefined;
  this.scale_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ImageReplay_.prototype.setImageStyle = function (imageStyle) {
  var anchor = imageStyle.getAnchor();
  var size = imageStyle.getSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var image = imageStyle.getImage(1);
  var origin = imageStyle.getOrigin();
  this.anchorX_ = anchor[0];
  this.anchorY_ = anchor[1];
  this.hitDetectionImage_ = hitDetectionImage;
  this.image_ = image;
  this.height_ = size[1];
  this.opacity_ = imageStyle.getOpacity();
  this.originX_ = origin[0];
  this.originY_ = origin[1];
  this.rotateWithView_ = imageStyle.getRotateWithView();
  this.rotation_ = imageStyle.getRotation();
  this.scale_ = imageStyle.getScale();
  this.snapToPixel_ = imageStyle.getSnapToPixel();
  this.width_ = size[0];
};
exports.default = _ol_render_canvas_ImageReplay_;


},{"../../index":110,"../canvas/instruction":170,"../canvas/replay":173}],169:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _colorlike = require('../../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require('../../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _simplegeometry = require('../../geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _has = require('../../has');

var _has2 = _interopRequireDefault(_has);

var _vectorcontext = require('../vectorcontext');

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _canvas = require('../canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _transform3 = require('../../transform');

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * A concrete subclass of {@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 *
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @struct
 */
var _ol_render_canvas_Immediate_ = function (context, pixelRatio, extent, transform, viewRotation) {
  _vectorcontext2.default.call(this);

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = context;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = extent;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = transform;

  /**
   * @private
   * @type {number}
   */
  this.viewRotation_ = viewRotation;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.contextFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.contextStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.contextTextState_ = null;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.fillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.strokeState_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.image_ = null;

  /**
   * @private
   * @type {number}
   */
  this.imageAnchorX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageAnchorY_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageHeight_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOpacity_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOriginX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOriginY_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.imageRotateWithView_ = false;

  /**
   * @private
   * @type {number}
   */
  this.imageRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageScale_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.imageSnapToPixel_ = false;

  /**
   * @private
   * @type {number}
   */
  this.imageWidth_ = 0;

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number}
   */
  this.textOffsetX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textOffsetY_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.textRotateWithView_ = false;

  /**
   * @private
   * @type {number}
   */
  this.textRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textScale_ = 0;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.textFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.textStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.textState_ = null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.pixelCoordinates_ = [];

  /**
   * @private
   * @type {ol.Transform}
   */
  this.tmpLocalTransform_ = _transform4.default.create();
}; // FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol.geom.flat.transform.transform2D?

_index2.default.inherits(_ol_render_canvas_Immediate_, _vectorcontext2.default);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */
_ol_render_canvas_Immediate_.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
  var this$1 = this;

  if (!this.image_) {
    return;
  }
  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var localTransform = this.tmpLocalTransform_;
  var alpha = context.globalAlpha;
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha * this.imageOpacity_;
  }
  var rotation = this.imageRotation_;
  if (this.imageRotateWithView_) {
    rotation += this.viewRotation_;
  }
  var i, ii;
  for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
    var x = pixelCoordinates[i] - this$1.imageAnchorX_;
    var y = pixelCoordinates[i + 1] - this$1.imageAnchorY_;
    if (this$1.imageSnapToPixel_) {
      x = Math.round(x);
      y = Math.round(y);
    }
    if (rotation !== 0 || this$1.imageScale_ != 1) {
      var centerX = x + this$1.imageAnchorX_;
      var centerY = y + this$1.imageAnchorY_;
      _transform4.default.compose(localTransform, centerX, centerY, this$1.imageScale_, this$1.imageScale_, rotation, -centerX, -centerY);
      context.setTransform.apply(context, localTransform);
    }
    context.drawImage(this$1.image_, this$1.imageOriginX_, this$1.imageOriginY_, this$1.imageWidth_, this$1.imageHeight_, x, y, this$1.imageWidth_, this$1.imageHeight_);
  }
  if (rotation !== 0 || this.imageScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha;
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */
_ol_render_canvas_Immediate_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  var this$1 = this;

  if (!this.textState_ || this.text_ === '') {
    return;
  }
  if (this.textFillState_) {
    this.setContextFillState_(this.textFillState_);
  }
  if (this.textStrokeState_) {
    this.setContextStrokeState_(this.textStrokeState_);
  }
  this.setContextTextState_(this.textState_);
  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var rotation = this.textRotation_;
  if (this.textRotateWithView_) {
    rotation += this.viewRotation_;
  }
  for (; offset < end; offset += stride) {
    var x = pixelCoordinates[offset] + this$1.textOffsetX_;
    var y = pixelCoordinates[offset + 1] + this$1.textOffsetY_;
    if (rotation !== 0 || this$1.textScale_ != 1) {
      var localTransform = _transform4.default.compose(this$1.tmpLocalTransform_, x, y, this$1.textScale_, this$1.textScale_, rotation, -x, -y);
      context.setTransform.apply(context, localTransform);
    }
    if (this$1.textStrokeState_) {
      context.strokeText(this$1.text_, x, y);
    }
    if (this$1.textFillState_) {
      context.fillText(this$1.text_, x, y);
    }
  }
  if (rotation !== 0 || this.textScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @private
 * @return {number} end End.
 */
_ol_render_canvas_Immediate_.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
  var context = this.context_;
  var pixelCoordinates = _transform2.default.transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
  var length = pixelCoordinates.length;
  if (close) {
    length -= 2;
  }
  for (var i = 2; i < length; i += 2) {
    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
  }
  if (close) {
    context.closePath();
  }
  return end;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
_ol_render_canvas_Immediate_.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
  var this$1 = this;

  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
  }
  return offset;
};

/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 *
 * @param {ol.geom.Circle} geometry Circle geometry.
 * @override
 * @api
 */
_ol_render_canvas_Immediate_.prototype.drawCircle = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.fillState_ || this.strokeState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var pixelCoordinates = _simplegeometry2.default.transform2D(geometry, this.transform_, this.pixelCoordinates_);
    var dx = pixelCoordinates[2] - pixelCoordinates[0];
    var dy = pixelCoordinates[3] - pixelCoordinates[1];
    var radius = Math.sqrt(dx * dx + dy * dy);
    var context = this.context_;
    context.beginPath();
    context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    this.drawText_(geometry.getCenter(), 0, 2, 2);
  }
};

/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */
_ol_render_canvas_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};

/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */
_ol_render_canvas_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();
  switch (type) {
    case _geometrytype2.default.POINT:
      this.drawPoint( /** @type {ol.geom.Point} */geometry);
      break;
    case _geometrytype2.default.LINE_STRING:
      this.drawLineString( /** @type {ol.geom.LineString} */geometry);
      break;
    case _geometrytype2.default.POLYGON:
      this.drawPolygon( /** @type {ol.geom.Polygon} */geometry);
      break;
    case _geometrytype2.default.MULTI_POINT:
      this.drawMultiPoint( /** @type {ol.geom.MultiPoint} */geometry);
      break;
    case _geometrytype2.default.MULTI_LINE_STRING:
      this.drawMultiLineString( /** @type {ol.geom.MultiLineString} */geometry);
      break;
    case _geometrytype2.default.MULTI_POLYGON:
      this.drawMultiPolygon( /** @type {ol.geom.MultiPolygon} */geometry);
      break;
    case _geometrytype2.default.GEOMETRY_COLLECTION:
      this.drawGeometryCollection( /** @type {ol.geom.GeometryCollection} */geometry);
      break;
    case _geometrytype2.default.CIRCLE:
      this.drawCircle( /** @type {ol.geom.Circle} */geometry);
      break;
    default:
  }
};

/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {@link ol.layer.Vector} instead.
 *
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @override
 * @api
 */
_ol_render_canvas_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry || !_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  this.setStyle(style);
  this.drawGeometry(geometry);
};

/**
 * Render a GeometryCollection to the canvas.  Rendering is immediate and
 * uses the current styles appropriate for each geometry in the collection.
 *
 * @param {ol.geom.GeometryCollection} geometry Geometry collection.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawGeometryCollection = function (geometry) {
  var this$1 = this;

  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this$1.drawGeometry(geometries[i]);
  }
};

/**
 * Render a Point geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};

/**
 * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
 * uses the current style.
 *
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawMultiPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};

/**
 * Render a LineString into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawLineString = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    context.beginPath();
    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
    context.stroke();
  }
  if (this.text_ !== '') {
    var flatMidpoint = geometry.getFlatMidpoint();
    this.drawText_(flatMidpoint, 0, 2, 2);
  }
};

/**
 * Render a MultiLineString geometry into the canvas.  Rendering is immediate
 * and uses the current style.
 *
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString
 *     geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawMultiLineString = function (geometry) {
  var this$1 = this;

  var geometryExtent = geometry.getExtent();
  if (!_extent2.default.intersects(this.extent_, geometryExtent)) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    var offset = 0;
    var ends = geometry.getEnds();
    var stride = geometry.getStride();
    context.beginPath();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      offset = this$1.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
    }
    context.stroke();
  }
  if (this.text_ !== '') {
    var flatMidpoints = geometry.getFlatMidpoints();
    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
  }
};

/**
 * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawPolygon = function (geometry) {
  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    context.beginPath();
    this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    var flatInteriorPoint = geometry.getFlatInteriorPoint();
    this.drawText_(flatInteriorPoint, 0, 2, 2);
  }
};

/**
 * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
 * uses the current style.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.drawMultiPolygon = function (geometry) {
  var this$1 = this;

  if (!_extent2.default.intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    var flatCoordinates = geometry.getOrientedFlatCoordinates();
    var offset = 0;
    var endss = geometry.getEndss();
    var stride = geometry.getStride();
    var i, ii;
    context.beginPath();
    for (i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      offset = this$1.drawRings_(flatCoordinates, offset, ends, stride);
    }
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    var flatInteriorPoints = geometry.getFlatInteriorPoints();
    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
  }
};

/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */
_ol_render_canvas_Immediate_.prototype.setContextFillState_ = function (fillState) {
  var context = this.context_;
  var contextFillState = this.contextFillState_;
  if (!contextFillState) {
    context.fillStyle = fillState.fillStyle;
    this.contextFillState_ = {
      fillStyle: fillState.fillStyle
    };
  } else {
    if (contextFillState.fillStyle != fillState.fillStyle) {
      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
    }
  }
};

/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */
_ol_render_canvas_Immediate_.prototype.setContextStrokeState_ = function (strokeState) {
  var context = this.context_;
  var contextStrokeState = this.contextStrokeState_;
  if (!contextStrokeState) {
    context.lineCap = strokeState.lineCap;
    if (_has2.default.CANVAS_LINE_DASH) {
      context.setLineDash(strokeState.lineDash);
    }
    context.lineJoin = strokeState.lineJoin;
    context.lineWidth = strokeState.lineWidth;
    context.miterLimit = strokeState.miterLimit;
    context.strokeStyle = strokeState.strokeStyle;
    this.contextStrokeState_ = {
      lineCap: strokeState.lineCap,
      lineDash: strokeState.lineDash,
      lineJoin: strokeState.lineJoin,
      lineWidth: strokeState.lineWidth,
      miterLimit: strokeState.miterLimit,
      strokeStyle: strokeState.strokeStyle
    };
  } else {
    if (contextStrokeState.lineCap != strokeState.lineCap) {
      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
    }
    if (_has2.default.CANVAS_LINE_DASH) {
      if (!_array2.default.equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }
    }
    if (contextStrokeState.lineJoin != strokeState.lineJoin) {
      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
    }
    if (contextStrokeState.lineWidth != strokeState.lineWidth) {
      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
    }
    if (contextStrokeState.miterLimit != strokeState.miterLimit) {
      contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;
    }
    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
      contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;
    }
  }
};

/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */
_ol_render_canvas_Immediate_.prototype.setContextTextState_ = function (textState) {
  var context = this.context_;
  var contextTextState = this.contextTextState_;
  if (!contextTextState) {
    context.font = textState.font;
    context.textAlign = textState.textAlign;
    context.textBaseline = textState.textBaseline;
    this.contextTextState_ = {
      font: textState.font,
      textAlign: textState.textAlign,
      textBaseline: textState.textBaseline
    };
  } else {
    if (contextTextState.font != textState.font) {
      contextTextState.font = context.font = textState.font;
    }
    if (contextTextState.textAlign != textState.textAlign) {
      contextTextState.textAlign = context.textAlign = textState.textAlign;
    }
    if (contextTextState.textBaseline != textState.textBaseline) {
      contextTextState.textBaseline = context.textBaseline = textState.textBaseline;
    }
  }
};

/**
 * Set the fill and stroke style for subsequent draw operations.  To clear
 * either fill or stroke styles, pass null for the appropriate parameter.
 *
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  if (!fillStyle) {
    this.fillState_ = null;
  } else {
    var fillStyleColor = fillStyle.getColor();
    this.fillState_ = {
      fillStyle: _colorlike2.default.asColorLike(fillStyleColor ? fillStyleColor : _canvas2.default.defaultFillStyle)
    };
  }
  if (!strokeStyle) {
    this.strokeState_ = null;
  } else {
    var strokeStyleColor = strokeStyle.getColor();
    var strokeStyleLineCap = strokeStyle.getLineCap();
    var strokeStyleLineDash = strokeStyle.getLineDash();
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    var strokeStyleWidth = strokeStyle.getWidth();
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    this.strokeState_ = {
      lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas2.default.defaultLineCap,
      lineDash: strokeStyleLineDash ? strokeStyleLineDash : _canvas2.default.defaultLineDash,
      lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset,
      lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas2.default.defaultLineJoin,
      lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas2.default.defaultLineWidth),
      miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas2.default.defaultMiterLimit,
      strokeStyle: _colorlike2.default.asColorLike(strokeStyleColor ? strokeStyleColor : _canvas2.default.defaultStrokeStyle)
    };
  }
};

/**
 * Set the image style for subsequent draw operations.  Pass null to remove
 * the image style.
 *
 * @param {ol.style.Image} imageStyle Image style.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.setImageStyle = function (imageStyle) {
  if (!imageStyle) {
    this.image_ = null;
  } else {
    var imageAnchor = imageStyle.getAnchor();
    // FIXME pixel ratio
    var imageImage = imageStyle.getImage(1);
    var imageOrigin = imageStyle.getOrigin();
    var imageSize = imageStyle.getSize();
    this.imageAnchorX_ = imageAnchor[0];
    this.imageAnchorY_ = imageAnchor[1];
    this.imageHeight_ = imageSize[1];
    this.image_ = imageImage;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScale();
    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
    this.imageWidth_ = imageSize[0];
  }
};

/**
 * Set the text style for subsequent draw operations.  Pass null to
 * remove the text style.
 *
 * @param {ol.style.Text} textStyle Text style.
 * @override
 */
_ol_render_canvas_Immediate_.prototype.setTextStyle = function (textStyle) {
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      this.textFillState_ = {
        fillStyle: _colorlike2.default.asColorLike(textFillStyleColor ? textFillStyleColor : _canvas2.default.defaultFillStyle)
      };
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      this.textStrokeState_ = {
        lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas2.default.defaultLineCap,
        lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : _canvas2.default.defaultLineDash,
        lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset,
        lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas2.default.defaultLineJoin,
        lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas2.default.defaultLineWidth,
        miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas2.default.defaultMiterLimit,
        strokeStyle: _colorlike2.default.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _canvas2.default.defaultStrokeStyle)
      };
    }
    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    this.textState_ = {
      font: textFont !== undefined ? textFont : _canvas2.default.defaultFont,
      textAlign: textTextAlign !== undefined ? textTextAlign : _canvas2.default.defaultTextAlign,
      textBaseline: textTextBaseline !== undefined ? textTextBaseline : _canvas2.default.defaultTextBaseline
    };
    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
  }
};
exports.default = _ol_render_canvas_Immediate_;


},{"../../array":42,"../../colorlike":50,"../../extent":68,"../../geom/flat/transform":94,"../../geom/geometrytype":98,"../../geom/simplegeometry":106,"../../has":107,"../../index":110,"../../transform":254,"../canvas":167,"../vectorcontext":182}],170:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 */
var _ol_render_canvas_Instruction_ = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  DRAW_IMAGE: 4,
  DRAW_TEXT: 5,
  END_GEOMETRY: 6,
  FILL: 7,
  MOVE_TO_LINE_TO: 8,
  SET_FILL_STYLE: 9,
  SET_STROKE_STYLE: 10,
  SET_TEXT_STYLE: 11,
  STROKE: 12
};

exports.default = _ol_render_canvas_Instruction_;


},{}],171:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _colorlike = require('../../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _canvas = require('../canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require('../canvas/instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require('../canvas/replay');

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_LineStringReplay_ = function (tolerance, maxExtent, resolution, overlaps) {

  _replay2.default.call(this, tolerance, maxExtent, resolution, overlaps);

  /**
   * @private
   * @type {ol.Extent}
   */
  this.bufferedMaxExtent_ = null;

  /**
   * @private
   * @type {{currentStrokeStyle: (ol.ColorLike|undefined),
   *         currentLineCap: (string|undefined),
   *         currentLineDash: Array.<number>,
   *         currentLineDashOffset: (number|undefined),
   *         currentLineJoin: (string|undefined),
   *         currentLineWidth: (number|undefined),
   *         currentMiterLimit: (number|undefined),
   *         lastStroke: number,
   *         strokeStyle: (ol.ColorLike|undefined),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined)}|null}
   */
  this.state_ = {
    currentStrokeStyle: undefined,
    currentLineCap: undefined,
    currentLineDash: null,
    currentLineDashOffset: undefined,
    currentLineJoin: undefined,
    currentLineWidth: undefined,
    currentMiterLimit: undefined,
    lastStroke: 0,
    strokeStyle: undefined,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: undefined,
    miterLimit: undefined
  };
};

_index2.default.inherits(_ol_render_canvas_LineStringReplay_, _replay2.default);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */
_ol_render_canvas_LineStringReplay_.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var moveToLineToInstruction = [_instruction2.default.MOVE_TO_LINE_TO, myBegin, myEnd];
  this.instructions.push(moveToLineToInstruction);
  this.hitDetectionInstructions.push(moveToLineToInstruction);
  return end;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_LineStringReplay_.prototype.getBufferedMaxExtent = function () {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = _extent2.default.clone(this.maxExtent);
    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;
      _extent2.default.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }
  return this.bufferedMaxExtent_;
};

/**
 * @private
 */
_ol_render_canvas_LineStringReplay_.prototype.setStrokeStyle_ = function () {
  var state = this.state_;
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;
  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || !_array2.default.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
    if (state.lastStroke != this.coordinates.length) {
      this.instructions.push([_instruction2.default.STROKE]);
      state.lastStroke = this.coordinates.length;
    }
    this.instructions.push([_instruction2.default.SET_STROKE_STYLE, strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash, lineDashOffset, true, 1], [_instruction2.default.BEGIN_PATH]);
    state.currentStrokeStyle = strokeStyle;
    state.currentLineCap = lineCap;
    state.currentLineDash = lineDash;
    state.currentLineDashOffset = lineDashOffset;
    state.currentLineJoin = lineJoin;
    state.currentLineWidth = lineWidth;
    state.currentMiterLimit = miterLimit;
  }
};

/**
 * @inheritDoc
 */
_ol_render_canvas_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var state = this.state_;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.setStrokeStyle_();
  this.beginGeometry(lineStringGeometry, feature);
  this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset, true, 1], [_instruction2.default.BEGIN_PATH]);
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.hitDetectionInstructions.push([_instruction2.default.STROKE]);
  this.endGeometry(lineStringGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var this$1 = this;

  var state = this.state_;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.setStrokeStyle_();
  this.beginGeometry(multiLineStringGeometry, feature);
  this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset, true, 1], [_instruction2.default.BEGIN_PATH]);
  var ends = multiLineStringGeometry.getEnds();
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this$1.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
  }
  this.hitDetectionInstructions.push([_instruction2.default.STROKE]);
  this.endGeometry(multiLineStringGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_LineStringReplay_.prototype.finish = function () {
  var state = this.state_;
  if (state.lastStroke != this.coordinates.length) {
    this.instructions.push([_instruction2.default.STROKE]);
  }
  this.reverseHitDetectionInstructions();
  this.state_ = null;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_LineStringReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleColor = strokeStyle.getColor();
  this.state_.strokeStyle = _colorlike2.default.asColorLike(strokeStyleColor ? strokeStyleColor : _canvas2.default.defaultStrokeStyle);
  var strokeStyleLineCap = strokeStyle.getLineCap();
  this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas2.default.defaultLineCap;
  var strokeStyleLineDash = strokeStyle.getLineDash();
  this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _canvas2.default.defaultLineDash;
  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
  this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset;
  var strokeStyleLineJoin = strokeStyle.getLineJoin();
  this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas2.default.defaultLineJoin;
  var strokeStyleWidth = strokeStyle.getWidth();
  this.state_.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas2.default.defaultLineWidth;
  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
  this.state_.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas2.default.defaultMiterLimit;

  if (this.state_.lineWidth > this.maxLineWidth) {
    this.maxLineWidth = this.state_.lineWidth;
    // invalidate the buffered max extent cache
    this.bufferedMaxExtent_ = null;
  }
};
exports.default = _ol_render_canvas_LineStringReplay_;


},{"../../array":42,"../../colorlike":50,"../../extent":68,"../../index":110,"../canvas":167,"../canvas/instruction":170,"../canvas/replay":173}],172:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _color = require('../../color');

var _color2 = _interopRequireDefault(_color);

var _colorlike = require('../../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _simplify = require('../../geom/flat/simplify');

var _simplify2 = _interopRequireDefault(_simplify);

var _canvas = require('../canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require('../canvas/instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require('../canvas/replay');

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_PolygonReplay_ = function (tolerance, maxExtent, resolution, overlaps) {

  _replay2.default.call(this, tolerance, maxExtent, resolution, overlaps);

  /**
   * @private
   * @type {ol.Extent}
   */
  this.bufferedMaxExtent_ = null;

  /**
   * @private
   * @type {{currentFillStyle: (ol.ColorLike|undefined),
   *         currentStrokeStyle: (ol.ColorLike|undefined),
   *         currentLineCap: (string|undefined),
   *         currentLineDash: Array.<number>,
   *         currentLineDashOffset: (number|undefined),
   *         currentLineJoin: (string|undefined),
   *         currentLineWidth: (number|undefined),
   *         currentMiterLimit: (number|undefined),
   *         fillStyle: (ol.ColorLike|undefined),
   *         strokeStyle: (ol.ColorLike|undefined),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined)}|null}
   */
  this.state_ = {
    currentFillStyle: undefined,
    currentStrokeStyle: undefined,
    currentLineCap: undefined,
    currentLineDash: null,
    currentLineDashOffset: undefined,
    currentLineJoin: undefined,
    currentLineWidth: undefined,
    currentMiterLimit: undefined,
    fillStyle: undefined,
    strokeStyle: undefined,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: undefined,
    miterLimit: undefined
  };
};

_index2.default.inherits(_ol_render_canvas_PolygonReplay_, _replay2.default);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
_ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
  var this$1 = this;

  var state = this.state_;
  var fill = state.fillStyle !== undefined;
  var stroke = state.strokeStyle != undefined;
  var numEnds = ends.length;
  var beginPathInstruction = [_instruction2.default.BEGIN_PATH];
  this.instructions.push(beginPathInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction);
  for (var i = 0; i < numEnds; ++i) {
    var end = ends[i];
    var myBegin = this$1.coordinates.length;
    var myEnd = this$1.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
    var moveToLineToInstruction = [_instruction2.default.MOVE_TO_LINE_TO, myBegin, myEnd];
    this$1.instructions.push(moveToLineToInstruction);
    this$1.hitDetectionInstructions.push(moveToLineToInstruction);
    if (stroke) {
      // Performance optimization: only call closePath() when we have a stroke.
      // Otherwise the ring is closed already (see appendFlatCoordinates above).
      var closePathInstruction = [_instruction2.default.CLOSE_PATH];
      this$1.instructions.push(closePathInstruction);
      this$1.hitDetectionInstructions.push(closePathInstruction);
    }
    offset = end;
  }
  var fillInstruction = [_instruction2.default.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (fill) {
    this.instructions.push(fillInstruction);
  }
  if (stroke) {
    var strokeInstruction = [_instruction2.default.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  return offset;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var state = this.state_;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(circleGeometry);
  this.beginGeometry(circleGeometry, feature);
  // always fill the circle for hit detection
  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset, true, 1]);
  }
  var flatCoordinates = circleGeometry.getFlatCoordinates();
  var stride = circleGeometry.getStride();
  var myBegin = this.coordinates.length;
  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
  var beginPathInstruction = [_instruction2.default.BEGIN_PATH];
  var circleInstruction = [_instruction2.default.CIRCLE, myBegin];
  this.instructions.push(beginPathInstruction, circleInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
  var fillInstruction = [_instruction2.default.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (state.fillStyle !== undefined) {
    this.instructions.push(fillInstruction);
  }
  if (state.strokeStyle !== undefined) {
    var strokeInstruction = [_instruction2.default.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  this.endGeometry(circleGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var state = this.state_;
  this.setFillStrokeStyles_(polygonGeometry);
  this.beginGeometry(polygonGeometry, feature);
  // always fill the polygon for hit detection
  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset, true, 1]);
  }
  var ends = polygonGeometry.getEnds();
  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
  var stride = polygonGeometry.getStride();
  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
  this.endGeometry(polygonGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var this$1 = this;

  var state = this.state_;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(multiPolygonGeometry);
  this.beginGeometry(multiPolygonGeometry, feature);
  // always fill the multi-polygon for hit detection
  this.hitDetectionInstructions.push([_instruction2.default.SET_FILL_STYLE, _color2.default.asString(_canvas2.default.defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([_instruction2.default.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset, true, 1]);
  }
  var endss = multiPolygonGeometry.getEndss();
  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
  var stride = multiPolygonGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = this$1.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
  }
  this.endGeometry(multiPolygonGeometry, feature);
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  this.state_ = null;
  // We want to preserve topology when drawing polygons.  Polygons are
  // simplified using quantization and point elimination. However, we might
  // have received a mix of quantized and non-quantized geometries, so ensure
  // that all are quantized by quantizing all coordinates in the batch.
  var tolerance = this.tolerance;
  if (tolerance !== 0) {
    var coordinates = this.coordinates;
    var i, ii;
    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      coordinates[i] = _simplify2.default.snap(coordinates[i], tolerance);
    }
  }
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.getBufferedMaxExtent = function () {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = _extent2.default.clone(this.maxExtent);
    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;
      _extent2.default.buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }
  return this.bufferedMaxExtent_;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var state = this.state_;
  if (fillStyle) {
    var fillStyleColor = fillStyle.getColor();
    state.fillStyle = _colorlike2.default.asColorLike(fillStyleColor ? fillStyleColor : _canvas2.default.defaultFillStyle);
  } else {
    state.fillStyle = undefined;
  }
  if (strokeStyle) {
    var strokeStyleColor = strokeStyle.getColor();
    state.strokeStyle = _colorlike2.default.asColorLike(strokeStyleColor ? strokeStyleColor : _canvas2.default.defaultStrokeStyle);
    var strokeStyleLineCap = strokeStyle.getLineCap();
    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _canvas2.default.defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : _canvas2.default.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _canvas2.default.defaultLineJoin;
    var strokeStyleWidth = strokeStyle.getWidth();
    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _canvas2.default.defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _canvas2.default.defaultMiterLimit;

    if (state.lineWidth > this.maxLineWidth) {
      this.maxLineWidth = state.lineWidth;
      // invalidate the buffered max extent cache
      this.bufferedMaxExtent_ = null;
    }
  } else {
    state.strokeStyle = undefined;
    state.lineCap = undefined;
    state.lineDash = null;
    state.lineDashOffset = undefined;
    state.lineJoin = undefined;
    state.lineWidth = undefined;
    state.miterLimit = undefined;
  }
};

/**
 * @private
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */
_ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function (geometry) {
  var state = this.state_;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;
  if (fillStyle !== undefined && (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle)) {
    var fillInstruction = [_instruction2.default.SET_FILL_STYLE, fillStyle];
    if (typeof fillStyle !== 'string') {
      var fillExtent = geometry.getExtent();
      fillInstruction.push([fillExtent[0], fillExtent[3]]);
    }
    this.instructions.push(fillInstruction);
    state.currentFillStyle = state.fillStyle;
  }
  if (strokeStyle !== undefined) {
    if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || !_array2.default.equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
      this.instructions.push([_instruction2.default.SET_STROKE_STYLE, strokeStyle, lineWidth, lineCap, lineJoin, miterLimit, lineDash, lineDashOffset, true, 1]);
      state.currentStrokeStyle = strokeStyle;
      state.currentLineCap = lineCap;
      state.currentLineDash = lineDash;
      state.currentLineDashOffset = lineDashOffset;
      state.currentLineJoin = lineJoin;
      state.currentLineWidth = lineWidth;
      state.currentMiterLimit = miterLimit;
    }
  }
};
exports.default = _ol_render_canvas_PolygonReplay_;


},{"../../array":42,"../../color":49,"../../colorlike":50,"../../extent":68,"../../geom/flat/simplify":92,"../../index":110,"../canvas":167,"../canvas/instruction":170,"../canvas/replay":173}],173:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _relationship = require('../../extent/relationship');

var _relationship2 = _interopRequireDefault(_relationship);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _has = require('../../has');

var _has2 = _interopRequireDefault(_has);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _vectorcontext = require('../vectorcontext');

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _instruction = require('../canvas/instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _transform3 = require('../../transform');

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_Replay_ = function (tolerance, maxExtent, resolution, overlaps) {
  _vectorcontext2.default.call(this);

  /**
   * @protected
   * @type {number}
   */
  this.tolerance = tolerance;

  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */
  this.maxExtent = maxExtent;

  /**
   * @protected
   * @type {boolean}
   */
  this.overlaps = overlaps;

  /**
   * @protected
   * @type {number}
   */
  this.maxLineWidth = 0;

  /**
   * @protected
   * @const
   * @type {number}
   */
  this.resolution = resolution;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.fillOrigin_;

  /**
   * @private
   * @type {Array.<*>}
   */
  this.beginGeometryInstruction1_ = null;

  /**
   * @private
   * @type {Array.<*>}
   */
  this.beginGeometryInstruction2_ = null;

  /**
   * @protected
   * @type {Array.<*>}
   */
  this.instructions = [];

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.coordinates = [];

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.renderedTransform_ = _transform4.default.create();

  /**
   * @protected
   * @type {Array.<*>}
   */
  this.hitDetectionInstructions = [];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.pixelCoordinates_ = null;

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.tmpLocalTransform_ = _transform4.default.create();

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.resetTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_render_canvas_Replay_, _vectorcontext2.default);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} closed Last input coordinate equals first.
 * @param {boolean} skipFirst Skip first coordinate.
 * @protected
 * @return {number} My end.
 */
_ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
  var this$1 = this;


  var myEnd = this.coordinates.length;
  var extent = this.getBufferedMaxExtent();
  if (skipFirst) {
    offset += stride;
  }
  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var nextCoord = [NaN, NaN];
  var skipped = true;

  var i, lastRel, nextRel;
  for (i = offset + stride; i < end; i += stride) {
    nextCoord[0] = flatCoordinates[i];
    nextCoord[1] = flatCoordinates[i + 1];
    nextRel = _extent2.default.coordinateRelationship(extent, nextCoord);
    if (nextRel !== lastRel) {
      if (skipped) {
        this$1.coordinates[myEnd++] = lastCoord[0];
        this$1.coordinates[myEnd++] = lastCoord[1];
      }
      this$1.coordinates[myEnd++] = nextCoord[0];
      this$1.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else if (nextRel === _relationship2.default.INTERSECTING) {
      this$1.coordinates[myEnd++] = nextCoord[0];
      this$1.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else {
      skipped = true;
    }
    lastCoord[0] = nextCoord[0];
    lastCoord[1] = nextCoord[1];
    lastRel = nextRel;
  }

  // Last coordinate equals first or only one point to append:
  if (closed && skipped || i === offset + stride) {
    this.coordinates[myEnd++] = lastCoord[0];
    this.coordinates[myEnd++] = lastCoord[1];
  }
  return myEnd;
};

/**
 * @protected
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_canvas_Replay_.prototype.beginGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_ = [_instruction2.default.BEGIN_GEOMETRY, feature, 0];
  this.instructions.push(this.beginGeometryInstruction1_);
  this.beginGeometryInstruction2_ = [_instruction2.default.BEGIN_GEOMETRY, feature, 0];
  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */
_ol_render_canvas_Replay_.prototype.fill_ = function (context, rotation) {
  if (this.fillOrigin_) {
    var origin = _transform4.default.apply(this.renderedTransform_, this.fillOrigin_.slice());
    context.translate(origin[0], origin[1]);
    context.rotate(rotation);
  }
  context.fill();
  if (this.fillOrigin_) {
    context.setTransform.apply(context, this.resetTransform_);
  }
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined}
 *     featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
_ol_render_canvas_Replay_.prototype.replay_ = function (context, pixelRatio, transform, viewRotation, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {
  var this$1 = this;

  /** @type {Array.<number>} */
  var pixelCoordinates;
  if (this.pixelCoordinates_ && _array2.default.equals(transform, this.renderedTransform_)) {
    pixelCoordinates = this.pixelCoordinates_;
  } else {
    if (!this.pixelCoordinates_) {
      this.pixelCoordinates_ = [];
    }
    pixelCoordinates = _transform2.default.transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
    _transform4.default.setFromArray(this.renderedTransform_, transform);
  }
  var skipFeatures = !_obj2.default.isEmpty(skippedFeaturesHash);
  var i = 0; // instruction index
  var ii = instructions.length; // end of instructions
  var d = 0; // data index
  var dd; // end of per-instruction data
  var localTransform = this.tmpLocalTransform_;
  var resetTransform = this.resetTransform_;
  var prevX, prevY, roundX, roundY;
  var pendingFill = 0;
  var pendingStroke = 0;
  // When the batch size gets too big, performance decreases. 200 is a good
  // balance between batch size and number of fill/stroke instructions.
  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
  while (i < ii) {
    var instruction = instructions[i];
    var type = /** @type {ol.render.canvas.Instruction} */instruction[0];
    var feature, fill, stroke, text, x, y;
    switch (type) {
      case _instruction2.default.BEGIN_GEOMETRY:
        feature = /** @type {ol.Feature|ol.render.Feature} */instruction[1];
        if (skipFeatures && skippedFeaturesHash[_index2.default.getUid(feature).toString()] || !feature.getGeometry()) {
          i = /** @type {number} */instruction[2];
        } else if (opt_hitExtent !== undefined && !_extent2.default.intersects(opt_hitExtent, feature.getGeometry().getExtent())) {
          i = /** @type {number} */instruction[2] + 1;
        } else {
          ++i;
        }
        break;
      case _instruction2.default.BEGIN_PATH:
        if (pendingFill > batchSize) {
          this$1.fill_(context, viewRotation);
          pendingFill = 0;
        }
        if (pendingStroke > batchSize) {
          context.stroke();
          pendingStroke = 0;
        }
        if (!pendingFill && !pendingStroke) {
          context.beginPath();
          prevX = prevY = NaN;
        }
        ++i;
        break;
      case _instruction2.default.CIRCLE:
        d = /** @type {number} */instruction[1];
        var x1 = pixelCoordinates[d];
        var y1 = pixelCoordinates[d + 1];
        var x2 = pixelCoordinates[d + 2];
        var y2 = pixelCoordinates[d + 3];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var r = Math.sqrt(dx * dx + dy * dy);
        context.moveTo(x1 + r, y1);
        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
        ++i;
        break;
      case _instruction2.default.CLOSE_PATH:
        context.closePath();
        ++i;
        break;
      case _instruction2.default.DRAW_IMAGE:
        d = /** @type {number} */instruction[1];
        dd = /** @type {number} */instruction[2];
        var image = /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
        instruction[3];
        // Remaining arguments in DRAW_IMAGE are in alphabetical order
        var anchorX = /** @type {number} */instruction[4] * pixelRatio;
        var anchorY = /** @type {number} */instruction[5] * pixelRatio;
        var height = /** @type {number} */instruction[6];
        var opacity = /** @type {number} */instruction[7];
        var originX = /** @type {number} */instruction[8];
        var originY = /** @type {number} */instruction[9];
        var rotateWithView = /** @type {boolean} */instruction[10];
        var rotation = /** @type {number} */instruction[11];
        var scale = /** @type {number} */instruction[12];
        var snapToPixel = /** @type {boolean} */instruction[13];
        var width = /** @type {number} */instruction[14];
        if (rotateWithView) {
          rotation += viewRotation;
        }
        for (; d < dd; d += 2) {
          x = pixelCoordinates[d] - anchorX;
          y = pixelCoordinates[d + 1] - anchorY;
          if (snapToPixel) {
            x = Math.round(x);
            y = Math.round(y);
          }
          if (scale != 1 || rotation !== 0) {
            var centerX = x + anchorX;
            var centerY = y + anchorY;
            _transform4.default.compose(localTransform, centerX, centerY, scale, scale, rotation, -centerX, -centerY);
            context.setTransform.apply(context, localTransform);
          }
          var alpha = context.globalAlpha;
          if (opacity != 1) {
            context.globalAlpha = alpha * opacity;
          }

          var w = width + originX > image.width ? image.width - originX : width;
          var h = height + originY > image.height ? image.height - originY : height;

          context.drawImage(image, originX, originY, w, h, x, y, w * pixelRatio, h * pixelRatio);

          if (opacity != 1) {
            context.globalAlpha = alpha;
          }
          if (scale != 1 || rotation !== 0) {
            context.setTransform.apply(context, resetTransform);
          }
        }
        ++i;
        break;
      case _instruction2.default.DRAW_TEXT:
        d = /** @type {number} */instruction[1];
        dd = /** @type {number} */instruction[2];
        text = /** @type {string} */instruction[3];
        var offsetX = /** @type {number} */instruction[4] * pixelRatio;
        var offsetY = /** @type {number} */instruction[5] * pixelRatio;
        rotation = /** @type {number} */instruction[6];
        scale = /** @type {number} */instruction[7] * pixelRatio;
        fill = /** @type {boolean} */instruction[8];
        stroke = /** @type {boolean} */instruction[9];
        rotateWithView = /** @type {boolean} */instruction[10];
        if (rotateWithView) {
          rotation += viewRotation;
        }
        for (; d < dd; d += 2) {
          x = pixelCoordinates[d] + offsetX;
          y = pixelCoordinates[d + 1] + offsetY;
          if (scale != 1 || rotation !== 0) {
            _transform4.default.compose(localTransform, x, y, scale, scale, rotation, -x, -y);
            context.setTransform.apply(context, localTransform);
          }

          // Support multiple lines separated by \n
          var lines = text.split('\n');
          var numLines = lines.length;
          var fontSize, lineY;
          if (numLines > 1) {
            // Estimate line height using width of capital M, and add padding
            fontSize = Math.round(context.measureText('M').width * 1.5);
            lineY = y - (numLines - 1) / 2 * fontSize;
          } else {
            // No need to calculate line height/offset for a single line
            fontSize = 0;
            lineY = y;
          }

          for (var lineIndex = 0; lineIndex < numLines; lineIndex++) {
            var line = lines[lineIndex];
            if (stroke) {
              context.strokeText(line, x, lineY);
            }
            if (fill) {
              context.fillText(line, x, lineY);
            }

            // Move next line down by fontSize px
            lineY = lineY + fontSize;
          }

          if (scale != 1 || rotation !== 0) {
            context.setTransform.apply(context, resetTransform);
          }
        }
        ++i;
        break;
      case _instruction2.default.END_GEOMETRY:
        if (featureCallback !== undefined) {
          feature =
          /** @type {ol.Feature|ol.render.Feature} */instruction[1];
          var result = featureCallback(feature);
          if (result) {
            return result;
          }
        }
        ++i;
        break;
      case _instruction2.default.FILL:
        if (batchSize) {
          pendingFill++;
        } else {
          this$1.fill_(context, viewRotation);
        }
        ++i;
        break;
      case _instruction2.default.MOVE_TO_LINE_TO:
        d = /** @type {number} */instruction[1];
        dd = /** @type {number} */instruction[2];
        x = pixelCoordinates[d];
        y = pixelCoordinates[d + 1];
        roundX = x + 0.5 | 0;
        roundY = y + 0.5 | 0;
        if (roundX !== prevX || roundY !== prevY) {
          context.moveTo(x, y);
          prevX = roundX;
          prevY = roundY;
        }
        for (d += 2; d < dd; d += 2) {
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;
          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
            context.lineTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
        }
        ++i;
        break;
      case _instruction2.default.SET_FILL_STYLE:
        this$1.fillOrigin_ = instruction[2];

        if (pendingFill) {
          this$1.fill_(context, viewRotation);
          pendingFill = 0;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
        }

        context.fillStyle = /** @type {ol.ColorLike} */instruction[1];
        ++i;
        break;
      case _instruction2.default.SET_STROKE_STYLE:
        var usePixelRatio = instruction[8] !== undefined ? instruction[8] : true;
        var renderedPixelRatio = instruction[9];

        var lineWidth = /** @type {number} */instruction[2];
        if (pendingStroke) {
          context.stroke();
          pendingStroke = 0;
        }
        context.strokeStyle = /** @type {ol.ColorLike} */instruction[1];
        context.lineWidth = usePixelRatio ? lineWidth * pixelRatio : lineWidth;
        context.lineCap = /** @type {string} */instruction[3];
        context.lineJoin = /** @type {string} */instruction[4];
        context.miterLimit = /** @type {number} */instruction[5];
        if (_has2.default.CANVAS_LINE_DASH) {
          var lineDash = /** @type {Array.<number>} */instruction[6];
          var lineDashOffset = /** @type {number} */instruction[7];
          if (usePixelRatio && pixelRatio !== renderedPixelRatio) {
            lineDash = lineDash.map(function (dash) {
              return dash * pixelRatio / renderedPixelRatio;
            });
            lineDashOffset *= pixelRatio / renderedPixelRatio;
            instruction[6] = lineDash;
            instruction[7] = lineDashOffset;
            instruction[9] = pixelRatio;
          }
          context.lineDashOffset = lineDashOffset;
          context.setLineDash(lineDash);
        }
        ++i;
        break;
      case _instruction2.default.SET_TEXT_STYLE:
        context.font = /** @type {string} */instruction[1];
        context.textAlign = /** @type {string} */instruction[2];
        context.textBaseline = /** @type {string} */instruction[3];
        ++i;
        break;
      case _instruction2.default.STROKE:
        if (batchSize) {
          pendingStroke++;
        } else {
          context.stroke();
        }
        ++i;
        break;
      default:
        ++i; // consume the instruction anyway, to avoid an infinite loop
        break;
    }
  }
  if (pendingFill) {
    this.fill_(context, viewRotation);
  }
  if (pendingStroke) {
    context.stroke();
  }
  return undefined;
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 */
_ol_render_canvas_Replay_.prototype.replay = function (context, pixelRatio, transform, viewRotation, skippedFeaturesHash) {
  var instructions = this.instructions;
  this.replay_(context, pixelRatio, transform, viewRotation, skippedFeaturesHash, instructions, undefined, undefined);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
_ol_render_canvas_Replay_.prototype.replayHitDetection = function (context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {
  var instructions = this.hitDetectionInstructions;
  return this.replay_(context, 1, transform, viewRotation, skippedFeaturesHash, instructions, opt_featureCallback, opt_hitExtent);
};

/**
 * Reverse the hit detection instructions.
 */
_ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function () {
  var this$1 = this;

  var hitDetectionInstructions = this.hitDetectionInstructions;
  // step 1 - reverse array
  hitDetectionInstructions.reverse();
  // step 2 - reverse instructions within geometry blocks
  var i;
  var n = hitDetectionInstructions.length;
  var instruction;
  var type;
  var begin = -1;
  for (i = 0; i < n; ++i) {
    instruction = hitDetectionInstructions[i];
    type = /** @type {ol.render.canvas.Instruction} */instruction[0];
    if (type == _instruction2.default.END_GEOMETRY) {
      begin = i;
    } else if (type == _instruction2.default.BEGIN_GEOMETRY) {
      instruction[2] = i;
      _array2.default.reverseSubArray(this$1.hitDetectionInstructions, begin, i);
      begin = -1;
    }
  }
};

/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_canvas_Replay_.prototype.endGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_[2] = this.instructions.length;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
  this.beginGeometryInstruction2_ = null;
  var endGeometryInstruction = [_instruction2.default.END_GEOMETRY, feature];
  this.instructions.push(endGeometryInstruction);
  this.hitDetectionInstructions.push(endGeometryInstruction);
};

/**
 * FIXME empty description for jsdoc
 */
_ol_render_canvas_Replay_.prototype.finish = _index2.default.nullFunction;

/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */
_ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function () {
  return this.maxExtent;
};
exports.default = _ol_render_canvas_Replay_;


},{"../../array":42,"../../extent":68,"../../extent/relationship":70,"../../geom/flat/transform":94,"../../has":107,"../../index":110,"../../obj":146,"../../transform":254,"../canvas/instruction":170,"../vectorcontext":182}],174:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _replaygroup = require('../replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _imagereplay = require('../canvas/imagereplay');

var _imagereplay2 = _interopRequireDefault(_imagereplay);

var _linestringreplay = require('../canvas/linestringreplay');

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _polygonreplay = require('../canvas/polygonreplay');

var _polygonreplay2 = _interopRequireDefault(_polygonreplay);

var _textreplay = require('../canvas/textreplay');

var _textreplay2 = _interopRequireDefault(_textreplay);

var _replay = require('../replay');

var _replay2 = _interopRequireDefault(_replay);

var _transform3 = require('../../transform');

var _transform4 = _interopRequireDefault(_transform3);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay group can have overlapping geometries.
 * @param {number=} opt_renderBuffer Optional rendering buffer.
 * @struct
 */
var _ol_render_canvas_ReplayGroup_ = function (tolerance, maxExtent, resolution, overlaps, opt_renderBuffer) {
  _replaygroup2.default.call(this);

  /**
   * @private
   * @type {number}
   */
  this.tolerance_ = tolerance;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.maxExtent_ = maxExtent;

  /**
   * @private
   * @type {boolean}
   */
  this.overlaps_ = overlaps;

  /**
   * @private
   * @type {number}
   */
  this.resolution_ = resolution;

  /**
   * @private
   * @type {number|undefined}
   */
  this.renderBuffer_ = opt_renderBuffer;

  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}
   */
  this.replaysByZIndex_ = {};

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.hitDetectionContext_ = _dom2.default.createCanvasContext2D(1, 1);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.hitDetectionTransform_ = _transform4.default.create();
};

_index2.default.inherits(_ol_render_canvas_ReplayGroup_, _replaygroup2.default);

/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 * @private
 */
_ol_render_canvas_ReplayGroup_.circleArrayCache_ = {
  0: [[true]]
};

/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @private
 */
_ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_ = function (array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
};

/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 * @private
 */
_ol_render_canvas_ReplayGroup_.getCircleArray_ = function (radius) {
  if (_ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] !== undefined) {
    return _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);
    _ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  _ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] = arr;
  return arr;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_render_canvas_ReplayGroup_.prototype.finish = function () {
  var this$1 = this;

  var zKey;
  for (zKey in this$1.replaysByZIndex_) {
    var replays = this$1.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      replays[replayKey].finish();
    }
  }
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
_ol_render_canvas_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback) {

  hitTolerance = Math.round(hitTolerance);
  var contextSize = hitTolerance * 2 + 1;
  var transform = _transform4.default.compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
  var context = this.hitDetectionContext_;

  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
    context.canvas.width = contextSize;
    context.canvas.height = contextSize;
  } else {
    context.clearRect(0, 0, contextSize, contextSize);
  }

  /**
   * @type {ol.Extent}
   */
  var hitExtent;
  if (this.renderBuffer_ !== undefined) {
    hitExtent = _extent2.default.createEmpty();
    _extent2.default.extendCoordinate(hitExtent, coordinate);
    _extent2.default.buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
  }

  var mask = _ol_render_canvas_ReplayGroup_.getCircleArray_(hitTolerance);

  return this.replayHitDetection_(context, transform, rotation, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
    for (var i = 0; i < contextSize; i++) {
      for (var j = 0; j < contextSize; j++) {
        if (mask[i][j]) {
          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
            var result = callback(feature);
            if (result) {
              return result;
            } else {
              context.clearRect(0, 0, contextSize, contextSize);
              return undefined;
            }
          }
        }
      }
    }
  }, hitExtent);
};

/**
 * @param {ol.Transform} transform Transform.
 * @return {Array.<number>} Clip coordinates.
 */
_ol_render_canvas_ReplayGroup_.prototype.getClipCoords = function (transform) {
  var maxExtent = this.maxExtent_;
  var minX = maxExtent[0];
  var minY = maxExtent[1];
  var maxX = maxExtent[2];
  var maxY = maxExtent[3];
  var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
  _transform2.default.transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
  return flatClipCoords;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];
  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }
  var replay = replays[replayType];
  if (replay === undefined) {
    var Constructor = _ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.overlaps_);
    replays[replayType] = replay;
  }
  return replay;
};

/**
 * @inheritDoc
 */
_ol_render_canvas_ReplayGroup_.prototype.isEmpty = function () {
  return _obj2.default.isEmpty(this.replaysByZIndex_);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types
 *     to replay. Default is {@link ol.render.replay.ORDER}
 */
_ol_render_canvas_ReplayGroup_.prototype.replay = function (context, pixelRatio, transform, viewRotation, skippedFeaturesHash, opt_replayTypes) {
  var this$1 = this;


  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(_array2.default.numberSafeCompareFunction);

  // setup clipping so that the parts of over-simplified geometries are not
  // visible outside the current extent when panning
  var flatClipCoords = this.getClipCoords(transform);
  context.save();
  context.beginPath();
  context.moveTo(flatClipCoords[0], flatClipCoords[1]);
  context.lineTo(flatClipCoords[2], flatClipCoords[3]);
  context.lineTo(flatClipCoords[4], flatClipCoords[5]);
  context.lineTo(flatClipCoords[6], flatClipCoords[7]);
  context.clip();

  var replayTypes = opt_replayTypes ? opt_replayTypes : _replay2.default.ORDER;
  var i, ii, j, jj, replays, replay;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this$1.replaysByZIndex_[zs[i].toString()];
    for (j = 0, jj = replayTypes.length; j < jj; ++j) {
      replay = replays[replayTypes[j]];
      if (replay !== undefined) {
        replay.replay(context, pixelRatio, transform, viewRotation, skippedFeaturesHash);
      }
    }
  }

  context.restore();
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
_ol_render_canvas_ReplayGroup_.prototype.replayHitDetection_ = function (context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var this$1 = this;

  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(function (a, b) {
    return b - a;
  });

  var i, ii, j, replays, replay, result;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this$1.replaysByZIndex_[zs[i].toString()];
    for (j = _replay2.default.ORDER.length - 1; j >= 0; --j) {
      replay = replays[_replay2.default.ORDER[j]];
      if (replay !== undefined) {
        result = replay.replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent);
        if (result) {
          return result;
        }
      }
    }
  }
  return undefined;
};

/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.canvas.Replay, number, ol.Extent,
 *                number, boolean)>}
 */
_ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': _polygonreplay2.default,
  'Image': _imagereplay2.default,
  'LineString': _linestringreplay2.default,
  'Polygon': _polygonreplay2.default,
  'Text': _textreplay2.default
};
exports.default = _ol_render_canvas_ReplayGroup_;


},{"../../array":42,"../../dom":60,"../../extent":68,"../../geom/flat/transform":94,"../../index":110,"../../obj":146,"../../transform":254,"../canvas/imagereplay":168,"../canvas/linestringreplay":171,"../canvas/polygonreplay":172,"../canvas/textreplay":175,"../replay":179,"../replaygroup":180}],175:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _colorlike = require('../../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _canvas = require('../canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _instruction = require('../canvas/instruction');

var _instruction2 = _interopRequireDefault(_instruction);

var _replay = require('../canvas/replay');

var _replay2 = _interopRequireDefault(_replay);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @struct
 */
var _ol_render_canvas_TextReplay_ = function (tolerance, maxExtent, resolution, overlaps) {

  _replay2.default.call(this, tolerance, maxExtent, resolution, overlaps);

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.replayFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.replayStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.replayTextState_ = null;

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number}
   */
  this.textOffsetX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textOffsetY_ = 0;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.textRotateWithView_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.textRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textScale_ = 0;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.textFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.textStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.textState_ = null;
};

_index2.default.inherits(_ol_render_canvas_TextReplay_, _replay2.default);

/**
 * @inheritDoc
 */
_ol_render_canvas_TextReplay_.prototype.drawText = function (flatCoordinates, offset, end, stride, geometry, feature) {
  if (this.text_ === '' || !this.textState_ || !this.textFillState_ && !this.textStrokeState_) {
    return;
  }
  if (this.textFillState_) {
    this.setReplayFillState_(this.textFillState_);
  }
  if (this.textStrokeState_) {
    this.setReplayStrokeState_(this.textStrokeState_);
  }
  this.setReplayTextState_(this.textState_);
  this.beginGeometry(geometry, feature);
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var fill = !!this.textFillState_;
  var stroke = !!this.textStrokeState_;
  var drawTextInstruction = [_instruction2.default.DRAW_TEXT, myBegin, myEnd, this.text_, this.textOffsetX_, this.textOffsetY_, this.textRotation_, this.textScale_, fill, stroke, this.textRotateWithView_];
  this.instructions.push(drawTextInstruction);
  this.hitDetectionInstructions.push(drawTextInstruction);
  this.endGeometry(geometry, feature);
};

/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */
_ol_render_canvas_TextReplay_.prototype.setReplayFillState_ = function (fillState) {
  var replayFillState = this.replayFillState_;
  if (replayFillState && replayFillState.fillStyle == fillState.fillStyle) {
    return;
  }
  var setFillStyleInstruction = [_instruction2.default.SET_FILL_STYLE, fillState.fillStyle];
  this.instructions.push(setFillStyleInstruction);
  this.hitDetectionInstructions.push(setFillStyleInstruction);
  if (!replayFillState) {
    this.replayFillState_ = {
      fillStyle: fillState.fillStyle
    };
  } else {
    replayFillState.fillStyle = fillState.fillStyle;
  }
};

/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */
_ol_render_canvas_TextReplay_.prototype.setReplayStrokeState_ = function (strokeState) {
  var replayStrokeState = this.replayStrokeState_;
  if (replayStrokeState && replayStrokeState.lineCap == strokeState.lineCap && replayStrokeState.lineDash == strokeState.lineDash && replayStrokeState.lineDashOffset == strokeState.lineDashOffset && replayStrokeState.lineJoin == strokeState.lineJoin && replayStrokeState.lineWidth == strokeState.lineWidth && replayStrokeState.miterLimit == strokeState.miterLimit && replayStrokeState.strokeStyle == strokeState.strokeStyle) {
    return;
  }
  var setStrokeStyleInstruction = [_instruction2.default.SET_STROKE_STYLE, strokeState.strokeStyle, strokeState.lineWidth, strokeState.lineCap, strokeState.lineJoin, strokeState.miterLimit, strokeState.lineDash, strokeState.lineDashOffset, false, 1];
  this.instructions.push(setStrokeStyleInstruction);
  this.hitDetectionInstructions.push(setStrokeStyleInstruction);
  if (!replayStrokeState) {
    this.replayStrokeState_ = {
      lineCap: strokeState.lineCap,
      lineDash: strokeState.lineDash,
      lineDashOffset: strokeState.lineDashOffset,
      lineJoin: strokeState.lineJoin,
      lineWidth: strokeState.lineWidth,
      miterLimit: strokeState.miterLimit,
      strokeStyle: strokeState.strokeStyle
    };
  } else {
    replayStrokeState.lineCap = strokeState.lineCap;
    replayStrokeState.lineDash = strokeState.lineDash;
    replayStrokeState.lineDashOffset = strokeState.lineDashOffset;
    replayStrokeState.lineJoin = strokeState.lineJoin;
    replayStrokeState.lineWidth = strokeState.lineWidth;
    replayStrokeState.miterLimit = strokeState.miterLimit;
    replayStrokeState.strokeStyle = strokeState.strokeStyle;
  }
};

/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */
_ol_render_canvas_TextReplay_.prototype.setReplayTextState_ = function (textState) {
  var replayTextState = this.replayTextState_;
  if (replayTextState && replayTextState.font == textState.font && replayTextState.textAlign == textState.textAlign && replayTextState.textBaseline == textState.textBaseline) {
    return;
  }
  var setTextStyleInstruction = [_instruction2.default.SET_TEXT_STYLE, textState.font, textState.textAlign, textState.textBaseline];
  this.instructions.push(setTextStyleInstruction);
  this.hitDetectionInstructions.push(setTextStyleInstruction);
  if (!replayTextState) {
    this.replayTextState_ = {
      font: textState.font,
      textAlign: textState.textAlign,
      textBaseline: textState.textBaseline
    };
  } else {
    replayTextState.font = textState.font;
    replayTextState.textAlign = textState.textAlign;
    replayTextState.textBaseline = textState.textBaseline;
  }
};

/**
 * @inheritDoc
 */
_ol_render_canvas_TextReplay_.prototype.setTextStyle = function (textStyle) {
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      var fillStyle = _colorlike2.default.asColorLike(textFillStyleColor ? textFillStyleColor : _canvas2.default.defaultFillStyle);
      if (!this.textFillState_) {
        this.textFillState_ = {
          fillStyle: fillStyle
        };
      } else {
        var textFillState = this.textFillState_;
        textFillState.fillStyle = fillStyle;
      }
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      var lineCap = textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : _canvas2.default.defaultLineCap;
      var lineDash = textStrokeStyleLineDash ? textStrokeStyleLineDash.slice() : _canvas2.default.defaultLineDash;
      var lineDashOffset = textStrokeStyleLineDashOffset !== undefined ? textStrokeStyleLineDashOffset : _canvas2.default.defaultLineDashOffset;
      var lineJoin = textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : _canvas2.default.defaultLineJoin;
      var lineWidth = textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : _canvas2.default.defaultLineWidth;
      var miterLimit = textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : _canvas2.default.defaultMiterLimit;
      var strokeStyle = _colorlike2.default.asColorLike(textStrokeStyleColor ? textStrokeStyleColor : _canvas2.default.defaultStrokeStyle);
      if (!this.textStrokeState_) {
        this.textStrokeState_ = {
          lineCap: lineCap,
          lineDash: lineDash,
          lineDashOffset: lineDashOffset,
          lineJoin: lineJoin,
          lineWidth: lineWidth,
          miterLimit: miterLimit,
          strokeStyle: strokeStyle
        };
      } else {
        var textStrokeState = this.textStrokeState_;
        textStrokeState.lineCap = lineCap;
        textStrokeState.lineDash = lineDash;
        textStrokeState.lineDashOffset = lineDashOffset;
        textStrokeState.lineJoin = lineJoin;
        textStrokeState.lineWidth = lineWidth;
        textStrokeState.miterLimit = miterLimit;
        textStrokeState.strokeStyle = strokeStyle;
      }
    }
    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    var font = textFont !== undefined ? textFont : _canvas2.default.defaultFont;
    var textAlign = textTextAlign !== undefined ? textTextAlign : _canvas2.default.defaultTextAlign;
    var textBaseline = textTextBaseline !== undefined ? textTextBaseline : _canvas2.default.defaultTextBaseline;
    if (!this.textState_) {
      this.textState_ = {
        font: font,
        textAlign: textAlign,
        textBaseline: textBaseline
      };
    } else {
      var textState = this.textState_;
      textState.font = font;
      textState.textAlign = textAlign;
      textState.textBaseline = textBaseline;
    }
    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = textScale !== undefined ? textScale : 1;
  }
};
exports.default = _ol_render_canvas_TextReplay_;


},{"../../colorlike":50,"../../index":110,"../canvas":167,"../canvas/instruction":170,"../canvas/replay":173}],176:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.render.Event}
 * @param {ol.render.EventType} type Type.
 * @param {ol.render.VectorContext=} opt_vectorContext Vector context.
 * @param {olx.FrameState=} opt_frameState Frame state.
 * @param {?CanvasRenderingContext2D=} opt_context Context.
 * @param {?ol.webgl.Context=} opt_glContext WebGL Context.
 */
var _ol_render_Event_ = function (type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

  _event2.default.call(this, type);

  /**
   * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
   * @type {ol.render.VectorContext|undefined}
   * @api
   */
  this.vectorContext = opt_vectorContext;

  /**
   * An object representing the current render frame state.
   * @type {olx.FrameState|undefined}
   * @api
   */
  this.frameState = opt_frameState;

  /**
   * Canvas context. Only available when a Canvas renderer is used, null
   * otherwise.
   * @type {CanvasRenderingContext2D|null|undefined}
   * @api
   */
  this.context = opt_context;

  /**
   * WebGL context. Only available when a WebGL renderer is used, null
   * otherwise.
   * @type {ol.webgl.Context|null|undefined}
   * @api
   */
  this.glContext = opt_glContext;
};

_index2.default.inherits(_ol_render_Event_, _event2.default);
exports.default = _ol_render_Event_;


},{"../events/event":64,"../index":110}],177:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_render_EventType_ = {
  /**
   * @event ol.render.Event#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event ol.render.Event#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event ol.render.Event#render
   * @api
   */
  RENDER: 'render'
};

exports.default = _ol_render_EventType_;


},{}],178:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Lightweight, read-only, {@link ol.Feature} and {@link ol.geom.Geometry} like
 * structure, optimized for rendering and styling. Geometry access through the
 * API is limited to getting the type and extent of the geometry.
 *
 * @constructor
 * @param {ol.geom.GeometryType} type Geometry type.
 * @param {Array.<number>} flatCoordinates Flat coordinates. These always need
 *     to be right-handed for polygons.
 * @param {Array.<number>|Array.<Array.<number>>} ends Ends or Endss.
 * @param {Object.<string, *>} properties Properties.
 */
var _ol_render_Feature_ = function (type, flatCoordinates, ends, properties) {
  /**
   * @private
   * @type {ol.Extent|undefined}
   */
  this.extent_;

  /**
   * @private
   * @type {ol.geom.GeometryType}
   */
  this.type_ = type;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.flatCoordinates_ = flatCoordinates;

  /**
   * @private
   * @type {Array.<number>|Array.<Array.<number>>}
   */
  this.ends_ = ends;

  /**
   * @private
   * @type {Object.<string, *>}
   */
  this.properties_ = properties;
};

/**
 * Get a feature property by its key.
 * @param {string} key Key
 * @return {*} Value for the requested key.
 * @api
 */
_ol_render_Feature_.prototype.get = function (key) {
  return this.properties_[key];
};

/**
 * @return {Array.<number>|Array.<Array.<number>>} Ends or endss.
 */
_ol_render_Feature_.prototype.getEnds = function () {
  return this.ends_;
};

/**
 * Get the extent of this feature's geometry.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_render_Feature_.prototype.getExtent = function () {
  if (!this.extent_) {
    this.extent_ = this.type_ === _geometrytype2.default.POINT ? _extent2.default.createOrUpdateFromCoordinate(this.flatCoordinates_) : _extent2.default.createOrUpdateFromFlatCoordinates(this.flatCoordinates_, 0, this.flatCoordinates_.length, 2);
  }
  return this.extent_;
};

/**
 * @return {Array.<number>} Flat coordinates.
 */
_ol_render_Feature_.prototype.getOrientedFlatCoordinates = function () {
  return this.flatCoordinates_;
};

/**
 * @return {Array.<number>} Flat coordinates.
 */
_ol_render_Feature_.prototype.getFlatCoordinates = _ol_render_Feature_.prototype.getOrientedFlatCoordinates;

/**
 * Get the feature for working with its geometry.
 * @return {ol.render.Feature} Feature.
 * @api
 */
_ol_render_Feature_.prototype.getGeometry = function () {
  return this;
};

/**
 * Get the feature properties.
 * @return {Object.<string, *>} Feature properties.
 * @api
 */
_ol_render_Feature_.prototype.getProperties = function () {
  return this.properties_;
};

/**
 * Get the feature for working with its geometry.
 * @return {ol.render.Feature} Feature.
 */
_ol_render_Feature_.prototype.getSimplifiedGeometry = _ol_render_Feature_.prototype.getGeometry;

/**
 * @return {number} Stride.
 */
_ol_render_Feature_.prototype.getStride = function () {
  return 2;
};

/**
 * @return {undefined}
 */
_ol_render_Feature_.prototype.getStyleFunction = _index2.default.nullFunction;

/**
 * Get the type of this feature's geometry.
 * @return {ol.geom.GeometryType} Geometry type.
 * @api
 */
_ol_render_Feature_.prototype.getType = function () {
  return this.type_;
};
exports.default = _ol_render_Feature_;


},{"../extent":68,"../geom/geometrytype":98,"../index":110}],179:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _replaytype = require('../render/replaytype');

var _replaytype2 = _interopRequireDefault(_replaytype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_replay_ = {};

/**
 * @const
 * @type {Array.<ol.render.ReplayType>}
 */
_ol_render_replay_.ORDER = [_replaytype2.default.POLYGON, _replaytype2.default.CIRCLE, _replaytype2.default.LINE_STRING, _replaytype2.default.IMAGE, _replaytype2.default.TEXT];
exports.default = _ol_render_replay_;


},{"../render/replaytype":181}],180:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Base class for replay groups.
 * @constructor
 * @abstract
 */
var _ol_render_ReplayGroup_ = function () {};

/**
 * @abstract
 * @param {number|undefined} zIndex Z index.
 * @param {ol.render.ReplayType} replayType Replay type.
 * @return {ol.render.VectorContext} Replay.
 */
_ol_render_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {};

/**
 * @abstract
 * @return {boolean} Is empty.
 */
_ol_render_ReplayGroup_.prototype.isEmpty = function () {};
exports.default = _ol_render_ReplayGroup_;


},{}],181:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_render_ReplayType_ = {
  CIRCLE: 'Circle',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};

exports.default = _ol_render_ReplayType_;


},{}],182:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @constructor
 * @abstract
 * @struct
 * @api
 */
var _ol_render_VectorContext_ = function () {};

/**
 * Render a geometry.
 *
 * @param {ol.geom.Geometry} geometry The geometry to render.
 */
_ol_render_VectorContext_.prototype.drawGeometry = function (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {ol.style.Style} style The rendering style.
 */
_ol_render_VectorContext_.prototype.setStyle = function (style) {};

/**
 * @param {ol.geom.Circle} circleGeometry Circle geometry.
 * @param {ol.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawCircle = function (circleGeometry, feature) {};

/**
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 */
_ol_render_VectorContext_.prototype.drawFeature = function (feature, style) {};

/**
 * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry
 *     collection.
 * @param {ol.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};

/**
 * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line
 *     string geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawLineString = function (lineStringGeometry, feature) {};

/**
 * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry
 *     MultiLineString geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};

/**
 * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};

/**
 * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};

/**
 * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawPoint = function (pointGeometry, feature) {};

/**
 * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawPolygon = function (polygonGeometry, feature) {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawText = function (flatCoordinates, offset, end, stride, geometry, feature) {};

/**
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 */
_ol_render_VectorContext_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};

/**
 * @param {ol.style.Image} imageStyle Image style.
 */
_ol_render_VectorContext_.prototype.setImageStyle = function (imageStyle) {};

/**
 * @param {ol.style.Text} textStyle Text style.
 */
_ol_render_VectorContext_.prototype.setTextStyle = function (textStyle) {};
exports.default = _ol_render_VectorContext_;


},{}],183:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_webgl_ = {};

if (false) {

  /**
   * @const
   * @type {ol.Color}
   */
  _ol_render_webgl_.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_.defaultLineCap = 'round';

  /**
   * @const
   * @type {Array.<number>}
   */
  _ol_render_webgl_.defaultLineDash = [];

  /**
   * @const
   * @type {number}
   */
  _ol_render_webgl_.defaultLineDashOffset = 0;

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_.defaultLineJoin = 'round';

  /**
   * @const
   * @type {number}
   */
  _ol_render_webgl_.defaultMiterLimit = 10;

  /**
   * @const
   * @type {ol.Color}
   */
  _ol_render_webgl_.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];

  /**
   * @const
   * @type {number}
   */
  _ol_render_webgl_.defaultLineWidth = 1;

  /**
   * Calculates the orientation of a triangle based on the determinant method.
   * @param {number} x1 First X coordinate.
   * @param {number} y1 First Y coordinate.
   * @param {number} x2 Second X coordinate.
   * @param {number} y2 Second Y coordinate.
   * @param {number} x3 Third X coordinate.
   * @param {number} y3 Third Y coordinate.
   * @return {boolean|undefined} Triangle is clockwise.
   */
  _ol_render_webgl_.triangleIsCounterClockwise = function (x1, y1, x2, y2, x3, y3) {
    var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
    return area <= _ol_render_webgl_.EPSILON && area >= -_ol_render_webgl_.EPSILON ? undefined : area > 0;
  };

  /**
   * @const
   * @type {number}
   */
  _ol_render_webgl_.EPSILON = Number.EPSILON || 2.220446049250313e-16;
}
exports.default = _ol_render_webgl_;


},{"../index":110}],184:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _color = require('../../color');

var _color2 = _interopRequireDefault(_color);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _defaultshader = require('../webgl/circlereplay/defaultshader');

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _replay = require('../webgl/replay');

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _webgl3 = require('../../webgl');

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.webgl.Replay}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_CircleReplay_ = function (tolerance, maxExtent) {
    _replay2.default.call(this, tolerance, maxExtent);

    /**
     * @private
     * @type {ol.render.webgl.circlereplay.defaultshader.Locations}
     */
    this.defaultLocations_ = null;

    /**
     * @private
     * @type {Array.<Array.<Array.<number>|number>>}
     */
    this.styles_ = [];

    /**
     * @private
     * @type {Array.<number>}
     */
    this.styleIndices_ = [];

    /**
     * @private
     * @type {number}
     */
    this.radius_ = 0;

    /**
     * @private
     * @type {{fillColor: (Array.<number>|null),
     *         strokeColor: (Array.<number>|null),
     *         lineDash: Array.<number>,
     *         lineDashOffset: (number|undefined),
     *         lineWidth: (number|undefined),
     *         changed: boolean}|null}
     */
    this.state_ = {
      fillColor: null,
      strokeColor: null,
      lineDash: null,
      lineDashOffset: undefined,
      lineWidth: undefined,
      changed: false
    };
  };

  _index2.default.inherits(_ol_render_webgl_CircleReplay_, _replay2.default);

  /**
   * @private
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  _ol_render_webgl_CircleReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var this$1 = this;

    var numVertices = this.vertices.length;
    var numIndices = this.indices.length;
    var n = numVertices / 4;
    var i, ii;
    for (i = offset, ii = end; i < ii; i += stride) {
      this$1.vertices[numVertices++] = flatCoordinates[i];
      this$1.vertices[numVertices++] = flatCoordinates[i + 1];
      this$1.vertices[numVertices++] = 0;
      this$1.vertices[numVertices++] = this$1.radius_;

      this$1.vertices[numVertices++] = flatCoordinates[i];
      this$1.vertices[numVertices++] = flatCoordinates[i + 1];
      this$1.vertices[numVertices++] = 1;
      this$1.vertices[numVertices++] = this$1.radius_;

      this$1.vertices[numVertices++] = flatCoordinates[i];
      this$1.vertices[numVertices++] = flatCoordinates[i + 1];
      this$1.vertices[numVertices++] = 2;
      this$1.vertices[numVertices++] = this$1.radius_;

      this$1.vertices[numVertices++] = flatCoordinates[i];
      this$1.vertices[numVertices++] = flatCoordinates[i + 1];
      this$1.vertices[numVertices++] = 3;
      this$1.vertices[numVertices++] = this$1.radius_;

      this$1.indices[numIndices++] = n;
      this$1.indices[numIndices++] = n + 1;
      this$1.indices[numIndices++] = n + 2;

      this$1.indices[numIndices++] = n + 2;
      this$1.indices[numIndices++] = n + 3;
      this$1.indices[numIndices++] = n;

      n += 4;
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.drawCircle = function (circleGeometry, feature) {
    var radius = circleGeometry.getRadius();
    var stride = circleGeometry.getStride();
    if (radius) {
      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }

      this.radius_ = radius;
      var flatCoordinates = circleGeometry.getFlatCoordinates();
      flatCoordinates = _transform2.default.translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);
      this.drawCoordinates_(flatCoordinates, 0, 2, stride);
    } else {
      if (this.state_.changed) {
        this.styles_.pop();
        if (this.styles_.length) {
          var lastState = this.styles_[this.styles_.length - 1];
          this.state_.fillColor = /** @type {Array.<number>} */lastState[0];
          this.state_.strokeColor = /** @type {Array.<number>} */lastState[1];
          this.state_.lineWidth = /** @type {number} */lastState[2];
          this.state_.changed = false;
        }
      }
    }
  };

  /**
   * @inheritDoc
   **/
  _ol_render_webgl_CircleReplay_.prototype.finish = function (context) {
    // create, bind, and populate the vertices buffer
    this.verticesBuffer = new _buffer2.default(this.vertices);

    // create, bind, and populate the indices buffer
    this.indicesBuffer = new _buffer2.default(this.indices);

    this.startIndices.push(this.indices.length);

    //Clean up, if there is nothing to draw
    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
      this.styles_ = [];
    }

    this.vertices = null;
    this.indices = null;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.getDeleteResourcesFunction = function (context) {
    // We only delete our stuff here. The shaders and the program may
    // be used by other CircleReplay instances (for other layers). And
    // they will be deleted when disposing of the ol.webgl.Context
    // object.
    var verticesBuffer = this.verticesBuffer;
    var indicesBuffer = this.indicesBuffer;
    return function () {
      context.deleteBuffer(verticesBuffer);
      context.deleteBuffer(indicesBuffer);
    };
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
    // get the program
    var fragmentShader, vertexShader;
    fragmentShader = _defaultshader2.default.fragment;
    vertexShader = _defaultshader2.default.vertex;
    var program = context.getProgram(fragmentShader, vertexShader);

    // get the locations
    var locations;
    if (!this.defaultLocations_) {
      locations = new _defaultshader2.default.Locations(gl, program);
      this.defaultLocations_ = locations;
    } else {
      locations = this.defaultLocations_;
    }

    context.useProgram(program);

    // enable the vertex attrib arrays
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 16, 0);

    gl.enableVertexAttribArray(locations.a_instruction);
    gl.vertexAttribPointer(locations.a_instruction, 1, _webgl4.default.FLOAT, false, 16, 8);

    gl.enableVertexAttribArray(locations.a_radius);
    gl.vertexAttribPointer(locations.a_radius, 1, _webgl4.default.FLOAT, false, 16, 12);

    // Enable renderer specific uniforms.
    gl.uniform2fv(locations.u_size, size);
    gl.uniform1f(locations.u_pixelRatio, pixelRatio);

    return locations;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.shutDownProgram = function (gl, locations) {
    gl.disableVertexAttribArray(locations.a_position);
    gl.disableVertexAttribArray(locations.a_instruction);
    gl.disableVertexAttribArray(locations.a_radius);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
    var this$1 = this;

    if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
    } else {
      //Draw by style groups to minimize drawElements() calls.
      var i, start, end, nextStyle;
      end = this.startIndices[this.startIndices.length - 1];
      for (i = this.styleIndices_.length - 1; i >= 0; --i) {
        start = this$1.styleIndices_[i];
        nextStyle = this$1.styles_[i];
        this$1.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
        this$1.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
        /** @type {number} */nextStyle[2]);
        this$1.drawElements(gl, context, start, end);
        end = start;
      }
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
    featureIndex = this.startIndices.length - 2;
    end = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
      this$1.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
      /** @type {number} */nextStyle[2]);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        start = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
        /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          this$1.drawElements(gl, context, start, end);

          var result = featureCallback(feature);

          if (result) {
            return result;
          }
        }
        featureIndex--;
        end = start;
      }
    }
    return undefined;
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object} skippedFeaturesHash Ids of features to skip.
   */
  _ol_render_webgl_CircleReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
    featureIndex = this.startIndices.length - 2;
    end = start = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
      this$1.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
      /** @type {number} */nextStyle[2]);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        featureStart = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid]) {
          if (start !== end) {
            this$1.drawElements(gl, context, start, end);
          }
          end = featureStart;
        }
        featureIndex--;
        start = featureStart;
      }
      if (start !== end) {
        this$1.drawElements(gl, context, start, end);
      }
      start = end = groupStart;
    }
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {Array.<number>} color Color.
   */
  _ol_render_webgl_CircleReplay_.prototype.setFillStyle_ = function (gl, color) {
    gl.uniform4fv(this.defaultLocations_.u_fillColor, color);
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {Array.<number>} color Color.
   * @param {number} lineWidth Line width.
   */
  _ol_render_webgl_CircleReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth) {
    gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);
    gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_CircleReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var strokeStyleColor, strokeStyleWidth;
    if (strokeStyle) {
      var strokeStyleLineDash = strokeStyle.getLineDash();
      this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl2.default.defaultLineDash;
      var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
      this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl2.default.defaultLineDashOffset;
      strokeStyleColor = strokeStyle.getColor();
      if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
        strokeStyleColor = _color2.default.asArray(strokeStyleColor).map(function (c, i) {
          return i != 3 ? c / 255 : c;
        }) || _webgl2.default.defaultStrokeStyle;
      } else {
        strokeStyleColor = _webgl2.default.defaultStrokeStyle;
      }
      strokeStyleWidth = strokeStyle.getWidth();
      strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl2.default.defaultLineWidth;
    } else {
      strokeStyleColor = [0, 0, 0, 0];
      strokeStyleWidth = 0;
    }
    var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
    if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
      fillStyleColor = _color2.default.asArray(fillStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || _webgl2.default.defaultFillStyle;
    } else {
      fillStyleColor = _webgl2.default.defaultFillStyle;
    }
    if (!this.state_.strokeColor || !_array2.default.equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !_array2.default.equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {
      this.state_.changed = true;
      this.state_.fillColor = fillStyleColor;
      this.state_.strokeColor = strokeStyleColor;
      this.state_.lineWidth = strokeStyleWidth;
      this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);
    }
  };
}
exports.default = _ol_render_webgl_CircleReplay_;


},{"../../array":42,"../../color":49,"../../extent":68,"../../geom/flat/transform":94,"../../index":110,"../../obj":146,"../../webgl":260,"../../webgl/buffer":261,"../webgl":183,"../webgl/circlereplay/defaultshader":185,"../webgl/replay":193}],185:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_webgl_circlereplay_defaultshader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_render_webgl_circlereplay_defaultshader_.Fragment = function () {
    _fragment2.default.call(this, _ol_render_webgl_circlereplay_defaultshader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_circlereplay_defaultshader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_circlereplay_defaultshader_.Fragment.DEBUG_SOURCE : _ol_render_webgl_circlereplay_defaultshader_.Fragment.OPTIMIZED_SOURCE;

  _ol_render_webgl_circlereplay_defaultshader_.fragment = new _ol_render_webgl_circlereplay_defaultshader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_render_webgl_circlereplay_defaultshader_.Vertex = function () {
    _vertex2.default.call(this, _ol_render_webgl_circlereplay_defaultshader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_circlereplay_defaultshader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Vertex.DEBUG_SOURCE = 'varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Vertex.OPTIMIZED_SOURCE = 'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;if(f==0.0){offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_circlereplay_defaultshader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_circlereplay_defaultshader_.Vertex.DEBUG_SOURCE : _ol_render_webgl_circlereplay_defaultshader_.Vertex.OPTIMIZED_SOURCE;

  _ol_render_webgl_circlereplay_defaultshader_.vertex = new _ol_render_webgl_circlereplay_defaultshader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_render_webgl_circlereplay_defaultshader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_fillColor = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_fillColor' : 'n');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_lineWidth = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_lineWidth' : 'k');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'm');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_pixelRatio = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_pixelRatio' : 'l');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_size = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_size' : 'p');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_strokeColor = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_strokeColor' : 'o');

    /**
     * @type {number}
     */
    this.a_instruction = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_instruction' : 'f');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'e');

    /**
     * @type {number}
     */
    this.a_radius = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_radius' : 'g');
  };
}
exports.default = _ol_render_webgl_circlereplay_defaultshader_;


},{"../../../index":110,"../../../webgl/fragment":264,"../../../webgl/vertex":266}],186:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _defaultshader = require('../webgl/imagereplay/defaultshader');

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _replay = require('../webgl/replay');

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require('../../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

var _context = require('../../webgl/context');

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.webgl.Replay}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_ImageReplay_ = function (tolerance, maxExtent) {
    _replay2.default.call(this, tolerance, maxExtent);

    /**
     * @type {number|undefined}
     * @private
     */
    this.anchorX_ = undefined;

    /**
     * @type {number|undefined}
     * @private
     */
    this.anchorY_ = undefined;

    /**
     * @type {Array.<number>}
     * @private
     */
    this.groupIndices_ = [];

    /**
     * @type {Array.<number>}
     * @private
     */
    this.hitDetectionGroupIndices_ = [];

    /**
     * @type {number|undefined}
     * @private
     */
    this.height_ = undefined;

    /**
     * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
     * @private
     */
    this.images_ = [];

    /**
     * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
     * @private
     */
    this.hitDetectionImages_ = [];

    /**
     * @type {number|undefined}
     * @private
     */
    this.imageHeight_ = undefined;

    /**
     * @type {number|undefined}
     * @private
     */
    this.imageWidth_ = undefined;

    /**
     * @private
     * @type {ol.render.webgl.imagereplay.defaultshader.Locations}
     */
    this.defaultLocations_ = null;

    /**
     * @private
     * @type {number|undefined}
     */
    this.opacity_ = undefined;

    /**
     * @type {number|undefined}
     * @private
     */
    this.originX_ = undefined;

    /**
     * @type {number|undefined}
     * @private
     */
    this.originY_ = undefined;

    /**
     * @private
     * @type {boolean|undefined}
     */
    this.rotateWithView_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.rotation_ = undefined;

    /**
     * @private
     * @type {number|undefined}
     */
    this.scale_ = undefined;

    /**
     * @type {Array.<WebGLTexture>}
     * @private
     */
    this.textures_ = [];

    /**
     * @type {Array.<WebGLTexture>}
     * @private
     */
    this.hitDetectionTextures_ = [];

    /**
     * @type {number|undefined}
     * @private
     */
    this.width_ = undefined;
  };

  _index2.default.inherits(_ol_render_webgl_ImageReplay_, _replay2.default);

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.getDeleteResourcesFunction = function (context) {
    var verticesBuffer = this.verticesBuffer;
    var indicesBuffer = this.indicesBuffer;
    var textures = this.textures_;
    var hitDetectionTextures = this.hitDetectionTextures_;
    var gl = context.getGL();
    return function () {
      if (!gl.isContextLost()) {
        var i, ii;
        for (i = 0, ii = textures.length; i < ii; ++i) {
          gl.deleteTexture(textures[i]);
        }
        for (i = 0, ii = hitDetectionTextures.length; i < ii; ++i) {
          gl.deleteTexture(hitDetectionTextures[i]);
        }
      }
      context.deleteBuffer(verticesBuffer);
      context.deleteBuffer(indicesBuffer);
    };
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} My end.
   * @private
   */
  _ol_render_webgl_ImageReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var this$1 = this;

    var anchorX = /** @type {number} */this.anchorX_;
    var anchorY = /** @type {number} */this.anchorY_;
    var height = /** @type {number} */this.height_;
    var imageHeight = /** @type {number} */this.imageHeight_;
    var imageWidth = /** @type {number} */this.imageWidth_;
    var opacity = /** @type {number} */this.opacity_;
    var originX = /** @type {number} */this.originX_;
    var originY = /** @type {number} */this.originY_;
    var rotateWithView = this.rotateWithView_ ? 1.0 : 0.0;
    // this.rotation_ is anti-clockwise, but rotation is clockwise
    var rotation = /** @type {number} */-this.rotation_;
    var scale = /** @type {number} */this.scale_;
    var width = /** @type {number} */this.width_;
    var cos = Math.cos(rotation);
    var sin = Math.sin(rotation);
    var numIndices = this.indices.length;
    var numVertices = this.vertices.length;
    var i, n, offsetX, offsetY, x, y;
    for (i = offset; i < end; i += stride) {
      x = flatCoordinates[i] - this$1.origin[0];
      y = flatCoordinates[i + 1] - this$1.origin[1];

      // There are 4 vertices per [x, y] point, one for each corner of the
      // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if
      // WebGL supported Geometry Shaders (which can emit new vertices), but that
      // is not currently the case.
      //
      // And each vertex includes 8 values: the x and y coordinates, the x and
      // y offsets used to calculate the position of the corner, the u and
      // v texture coordinates for the corner, the opacity, and whether the
      // the image should be rotated with the view (rotateWithView).

      n = numVertices / 8;

      // bottom-left corner
      offsetX = -scale * anchorX;
      offsetY = -scale * (height - anchorY);
      this$1.vertices[numVertices++] = x;
      this$1.vertices[numVertices++] = y;
      this$1.vertices[numVertices++] = offsetX * cos - offsetY * sin;
      this$1.vertices[numVertices++] = offsetX * sin + offsetY * cos;
      this$1.vertices[numVertices++] = originX / imageWidth;
      this$1.vertices[numVertices++] = (originY + height) / imageHeight;
      this$1.vertices[numVertices++] = opacity;
      this$1.vertices[numVertices++] = rotateWithView;

      // bottom-right corner
      offsetX = scale * (width - anchorX);
      offsetY = -scale * (height - anchorY);
      this$1.vertices[numVertices++] = x;
      this$1.vertices[numVertices++] = y;
      this$1.vertices[numVertices++] = offsetX * cos - offsetY * sin;
      this$1.vertices[numVertices++] = offsetX * sin + offsetY * cos;
      this$1.vertices[numVertices++] = (originX + width) / imageWidth;
      this$1.vertices[numVertices++] = (originY + height) / imageHeight;
      this$1.vertices[numVertices++] = opacity;
      this$1.vertices[numVertices++] = rotateWithView;

      // top-right corner
      offsetX = scale * (width - anchorX);
      offsetY = scale * anchorY;
      this$1.vertices[numVertices++] = x;
      this$1.vertices[numVertices++] = y;
      this$1.vertices[numVertices++] = offsetX * cos - offsetY * sin;
      this$1.vertices[numVertices++] = offsetX * sin + offsetY * cos;
      this$1.vertices[numVertices++] = (originX + width) / imageWidth;
      this$1.vertices[numVertices++] = originY / imageHeight;
      this$1.vertices[numVertices++] = opacity;
      this$1.vertices[numVertices++] = rotateWithView;

      // top-left corner
      offsetX = -scale * anchorX;
      offsetY = scale * anchorY;
      this$1.vertices[numVertices++] = x;
      this$1.vertices[numVertices++] = y;
      this$1.vertices[numVertices++] = offsetX * cos - offsetY * sin;
      this$1.vertices[numVertices++] = offsetX * sin + offsetY * cos;
      this$1.vertices[numVertices++] = originX / imageWidth;
      this$1.vertices[numVertices++] = originY / imageHeight;
      this$1.vertices[numVertices++] = opacity;
      this$1.vertices[numVertices++] = rotateWithView;

      this$1.indices[numIndices++] = n;
      this$1.indices[numIndices++] = n + 1;
      this$1.indices[numIndices++] = n + 2;
      this$1.indices[numIndices++] = n;
      this$1.indices[numIndices++] = n + 2;
      this$1.indices[numIndices++] = n + 3;
    }

    return numVertices;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    var flatCoordinates = multiPointGeometry.getFlatCoordinates();
    var stride = multiPointGeometry.getStride();
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    var flatCoordinates = pointGeometry.getFlatCoordinates();
    var stride = pointGeometry.getStride();
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.finish = function (context) {
    var gl = context.getGL();

    this.groupIndices_.push(this.indices.length);
    this.hitDetectionGroupIndices_.push(this.indices.length);

    // create, bind, and populate the vertices buffer
    this.verticesBuffer = new _buffer2.default(this.vertices);

    var indices = this.indices;

    // create, bind, and populate the indices buffer
    this.indicesBuffer = new _buffer2.default(indices);

    // create textures
    /** @type {Object.<string, WebGLTexture>} */
    var texturePerImage = {};

    this.createTextures_(this.textures_, this.images_, texturePerImage, gl);

    this.createTextures_(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);

    this.anchorX_ = undefined;
    this.anchorY_ = undefined;
    this.height_ = undefined;
    this.images_ = null;
    this.hitDetectionImages_ = null;
    this.imageHeight_ = undefined;
    this.imageWidth_ = undefined;
    this.indices = null;
    this.opacity_ = undefined;
    this.originX_ = undefined;
    this.originY_ = undefined;
    this.rotateWithView_ = undefined;
    this.rotation_ = undefined;
    this.scale_ = undefined;
    this.vertices = null;
    this.width_ = undefined;
  };

  /**
   * @private
   * @param {Array.<WebGLTexture>} textures Textures.
   * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images
   *    Images.
   * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.
   * @param {WebGLRenderingContext} gl Gl.
   */
  _ol_render_webgl_ImageReplay_.prototype.createTextures_ = function (textures, images, texturePerImage, gl) {
    var texture, image, uid, i;
    var ii = images.length;
    for (i = 0; i < ii; ++i) {
      image = images[i];

      uid = _index2.default.getUid(image).toString();
      if (uid in texturePerImage) {
        texture = texturePerImage[uid];
      } else {
        texture = _context2.default.createTexture(gl, image, _webgl2.default.CLAMP_TO_EDGE, _webgl2.default.CLAMP_TO_EDGE);
        texturePerImage[uid] = texture;
      }
      textures[i] = texture;
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
    // get the program
    var fragmentShader = _defaultshader2.default.fragment;
    var vertexShader = _defaultshader2.default.vertex;
    var program = context.getProgram(fragmentShader, vertexShader);

    // get the locations
    var locations;
    if (!this.defaultLocations_) {
      locations = new _defaultshader2.default.Locations(gl, program);
      this.defaultLocations_ = locations;
    } else {
      locations = this.defaultLocations_;
    }

    // use the program (FIXME: use the return value)
    context.useProgram(program);

    // enable the vertex attrib arrays
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl2.default.FLOAT, false, 32, 0);

    gl.enableVertexAttribArray(locations.a_offsets);
    gl.vertexAttribPointer(locations.a_offsets, 2, _webgl2.default.FLOAT, false, 32, 8);

    gl.enableVertexAttribArray(locations.a_texCoord);
    gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl2.default.FLOAT, false, 32, 16);

    gl.enableVertexAttribArray(locations.a_opacity);
    gl.vertexAttribPointer(locations.a_opacity, 1, _webgl2.default.FLOAT, false, 32, 24);

    gl.enableVertexAttribArray(locations.a_rotateWithView);
    gl.vertexAttribPointer(locations.a_rotateWithView, 1, _webgl2.default.FLOAT, false, 32, 28);

    return locations;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.shutDownProgram = function (gl, locations) {
    gl.disableVertexAttribArray(locations.a_position);
    gl.disableVertexAttribArray(locations.a_offsets);
    gl.disableVertexAttribArray(locations.a_texCoord);
    gl.disableVertexAttribArray(locations.a_opacity);
    gl.disableVertexAttribArray(locations.a_rotateWithView);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
    var this$1 = this;

    var textures = hitDetection ? this.hitDetectionTextures_ : this.textures_;
    var groupIndices = hitDetection ? this.hitDetectionGroupIndices_ : this.groupIndices_;

    if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
      this.drawReplaySkipping_(gl, context, skippedFeaturesHash, textures, groupIndices);
    } else {
      var i, ii, start;
      for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {
        gl.bindTexture(_webgl2.default.TEXTURE_2D, textures[i]);
        var end = groupIndices[i];
        this$1.drawElements(gl, context, start, end);
        start = end;
      }
    }
  };

  /**
   * Draw the replay while paying attention to skipped features.
   *
   * This functions creates groups of features that can be drawn to together,
   * so that the number of `drawElements` calls is minimized.
   *
   * For example given the following texture groups:
   *
   *    Group 1: A B C
   *    Group 2: D [E] F G
   *
   * If feature E should be skipped, the following `drawElements` calls will be
   * made:
   *
   *    drawElements with feature A, B and C
   *    drawElements with feature D
   *    drawElements with feature F and G
   *
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {Array.<WebGLTexture>} textures Textures.
   * @param {Array.<number>} groupIndices Texture group indices.
   */
  _ol_render_webgl_ImageReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash, textures, groupIndices) {
    var this$1 = this;

    var featureIndex = 0;

    var i, ii;
    for (i = 0, ii = textures.length; i < ii; ++i) {
      gl.bindTexture(_webgl2.default.TEXTURE_2D, textures[i]);
      var groupStart = i > 0 ? groupIndices[i - 1] : 0;
      var groupEnd = groupIndices[i];

      var start = groupStart;
      var end = groupStart;
      while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {
        var feature = this$1.startIndicesFeature[featureIndex];

        var featureUid = _index2.default.getUid(feature).toString();
        if (skippedFeaturesHash[featureUid] !== undefined) {
          // feature should be skipped
          if (start !== end) {
            // draw the features so far
            this$1.drawElements(gl, context, start, end);
          }
          // continue with the next feature
          start = featureIndex === this$1.startIndices.length - 1 ? groupEnd : this$1.startIndices[featureIndex + 1];
          end = start;
        } else {
          // the feature is not skipped, augment the end index
          end = featureIndex === this$1.startIndices.length - 1 ? groupEnd : this$1.startIndices[featureIndex + 1];
        }
        featureIndex++;
      }

      if (start !== end) {
        // draw the remaining features (in case there was no skipped feature
        // in this texture group, all features of a group are drawn together)
        this$1.drawElements(gl, context, start, end);
      }
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
    var this$1 = this;

    var i, groupStart, start, end, feature, featureUid;
    var featureIndex = this.startIndices.length - 1;
    for (i = this.hitDetectionTextures_.length - 1; i >= 0; --i) {
      gl.bindTexture(_webgl2.default.TEXTURE_2D, this$1.hitDetectionTextures_[i]);
      groupStart = i > 0 ? this$1.hitDetectionGroupIndices_[i - 1] : 0;
      end = this$1.hitDetectionGroupIndices_[i];

      // draw all features for this texture group
      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        start = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
        /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          this$1.drawElements(gl, context, start, end);

          var result = featureCallback(feature);
          if (result) {
            return result;
          }
        }

        end = start;
        featureIndex--;
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ImageReplay_.prototype.setImageStyle = function (imageStyle) {
    var anchor = imageStyle.getAnchor();
    var image = imageStyle.getImage(1);
    var imageSize = imageStyle.getImageSize();
    var hitDetectionImage = imageStyle.getHitDetectionImage(1);
    var opacity = imageStyle.getOpacity();
    var origin = imageStyle.getOrigin();
    var rotateWithView = imageStyle.getRotateWithView();
    var rotation = imageStyle.getRotation();
    var size = imageStyle.getSize();
    var scale = imageStyle.getScale();

    var currentImage;
    if (this.images_.length === 0) {
      this.images_.push(image);
    } else {
      currentImage = this.images_[this.images_.length - 1];
      if (_index2.default.getUid(currentImage) != _index2.default.getUid(image)) {
        this.groupIndices_.push(this.indices.length);
        this.images_.push(image);
      }
    }

    if (this.hitDetectionImages_.length === 0) {
      this.hitDetectionImages_.push(hitDetectionImage);
    } else {
      currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];
      if (_index2.default.getUid(currentImage) != _index2.default.getUid(hitDetectionImage)) {
        this.hitDetectionGroupIndices_.push(this.indices.length);
        this.hitDetectionImages_.push(hitDetectionImage);
      }
    }

    this.anchorX_ = anchor[0];
    this.anchorY_ = anchor[1];
    this.height_ = size[1];
    this.imageHeight_ = imageSize[1];
    this.imageWidth_ = imageSize[0];
    this.opacity_ = opacity;
    this.originX_ = origin[0];
    this.originY_ = origin[1];
    this.rotation_ = rotation;
    this.rotateWithView_ = rotateWithView;
    this.scale_ = scale;
    this.width_ = size[0];
  };
}
exports.default = _ol_render_webgl_ImageReplay_;


},{"../../extent":68,"../../index":110,"../../obj":146,"../../webgl":260,"../../webgl/buffer":261,"../../webgl/context":262,"../webgl/imagereplay/defaultshader":187,"../webgl/replay":193}],187:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_webgl_imagereplay_defaultshader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_render_webgl_imagereplay_defaultshader_.Fragment = function () {
    _fragment2.default.call(this, _ol_render_webgl_imagereplay_defaultshader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_imagereplay_defaultshader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_imagereplay_defaultshader_.Fragment.DEBUG_SOURCE : _ol_render_webgl_imagereplay_defaultshader_.Fragment.OPTIMIZED_SOURCE;

  _ol_render_webgl_imagereplay_defaultshader_.fragment = new _ol_render_webgl_imagereplay_defaultshader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_render_webgl_imagereplay_defaultshader_.Vertex = function () {
    _vertex2.default.call(this, _ol_render_webgl_imagereplay_defaultshader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_imagereplay_defaultshader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Vertex.DEBUG_SOURCE = 'varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Vertex.OPTIMIZED_SOURCE = 'varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_imagereplay_defaultshader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_imagereplay_defaultshader_.Vertex.DEBUG_SOURCE : _ol_render_webgl_imagereplay_defaultshader_.Vertex.OPTIMIZED_SOURCE;

  _ol_render_webgl_imagereplay_defaultshader_.vertex = new _ol_render_webgl_imagereplay_defaultshader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_render_webgl_imagereplay_defaultshader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_image = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_image' : 'l');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'k');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

    /**
     * @type {number}
     */
    this.a_offsets = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_offsets' : 'e');

    /**
     * @type {number}
     */
    this.a_opacity = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_opacity' : 'f');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'c');

    /**
     * @type {number}
     */
    this.a_rotateWithView = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_rotateWithView' : 'g');

    /**
     * @type {number}
     */
    this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'd');
  };
}
exports.default = _ol_render_webgl_imagereplay_defaultshader_;


},{"../../../index":110,"../../../webgl/fragment":264,"../../../webgl/vertex":266}],188:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require('../../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _replaytype = require('../replaytype');

var _replaytype2 = _interopRequireDefault(_replaytype);

var _vectorcontext = require('../vectorcontext');

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _replaygroup = require('../webgl/replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.VectorContext}
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {ol.Extent} extent Extent.
   * @param {number} pixelRatio Pixel ratio.
   * @struct
   */
  var _ol_render_webgl_Immediate_ = function (context, center, resolution, rotation, size, extent, pixelRatio) {
    _vectorcontext2.default.call(this);

    /**
     * @private
     */
    this.context_ = context;

    /**
     * @private
     */
    this.center_ = center;

    /**
     * @private
     */
    this.extent_ = extent;

    /**
     * @private
     */
    this.pixelRatio_ = pixelRatio;

    /**
     * @private
     */
    this.size_ = size;

    /**
     * @private
     */
    this.rotation_ = rotation;

    /**
     * @private
     */
    this.resolution_ = resolution;

    /**
     * @private
     * @type {ol.style.Image}
     */
    this.imageStyle_ = null;

    /**
     * @private
     * @type {ol.style.Fill}
     */
    this.fillStyle_ = null;

    /**
     * @private
     * @type {ol.style.Stroke}
     */
    this.strokeStyle_ = null;
  };

  _index2.default.inherits(_ol_render_webgl_Immediate_, _vectorcontext2.default);

  /**
   * Set the rendering style.  Note that since this is an immediate rendering API,
   * any `zIndex` on the provided style will be ignored.
   *
   * @param {ol.style.Style} style The rendering style.
   * @override
   * @api
   */
  _ol_render_webgl_Immediate_.prototype.setStyle = function (style) {
    this.setFillStrokeStyle(style.getFill(), style.getStroke());
    this.setImageStyle(style.getImage());
  };

  /**
   * Render a geometry into the canvas.  Call
   * {@link ol.render.webgl.Immediate#setStyle} first to set the rendering style.
   *
   * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
   * @override
   * @api
   */
  _ol_render_webgl_Immediate_.prototype.drawGeometry = function (geometry) {
    var type = geometry.getType();
    switch (type) {
      case _geometrytype2.default.POINT:
        this.drawPoint( /** @type {ol.geom.Point} */geometry, null);
        break;
      case _geometrytype2.default.LINE_STRING:
        this.drawLineString( /** @type {ol.geom.LineString} */geometry, null);
        break;
      case _geometrytype2.default.POLYGON:
        this.drawPolygon( /** @type {ol.geom.Polygon} */geometry, null);
        break;
      case _geometrytype2.default.MULTI_POINT:
        this.drawMultiPoint( /** @type {ol.geom.MultiPoint} */geometry, null);
        break;
      case _geometrytype2.default.MULTI_LINE_STRING:
        this.drawMultiLineString( /** @type {ol.geom.MultiLineString} */geometry, null);
        break;
      case _geometrytype2.default.MULTI_POLYGON:
        this.drawMultiPolygon( /** @type {ol.geom.MultiPolygon} */geometry, null);
        break;
      case _geometrytype2.default.GEOMETRY_COLLECTION:
        this.drawGeometryCollection( /** @type {ol.geom.GeometryCollection} */geometry, null);
        break;
      case _geometrytype2.default.CIRCLE:
        this.drawCircle( /** @type {ol.geom.Circle} */geometry, null);
        break;
      default:
      // pass
    }
  };

  /**
   * @inheritDoc
   * @api
   */
  _ol_render_webgl_Immediate_.prototype.drawFeature = function (feature, style) {
    var geometry = style.getGeometryFunction()(feature);
    if (!geometry || !_extent2.default.intersects(this.extent_, geometry.getExtent())) {
      return;
    }
    this.setStyle(style);
    this.drawGeometry(geometry);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawGeometryCollection = function (geometry, data) {
    var this$1 = this;

    var geometries = geometry.getGeometriesArray();
    var i, ii;
    for (i = 0, ii = geometries.length; i < ii; ++i) {
      this$1.drawGeometry(geometries[i]);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawPoint = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.ImageReplay} */replayGroup.getReplay(0, _replaytype2.default.IMAGE);
    replay.setImageStyle(this.imageStyle_);
    replay.drawPoint(geometry, data);
    replay.finish(context);
    // default colors
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawMultiPoint = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.ImageReplay} */replayGroup.getReplay(0, _replaytype2.default.IMAGE);
    replay.setImageStyle(this.imageStyle_);
    replay.drawMultiPoint(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawLineString = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.LineStringReplay} */replayGroup.getReplay(0, _replaytype2.default.LINE_STRING);
    replay.setFillStrokeStyle(null, this.strokeStyle_);
    replay.drawLineString(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawMultiLineString = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.LineStringReplay} */replayGroup.getReplay(0, _replaytype2.default.LINE_STRING);
    replay.setFillStrokeStyle(null, this.strokeStyle_);
    replay.drawMultiLineString(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawPolygon = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.PolygonReplay} */replayGroup.getReplay(0, _replaytype2.default.POLYGON);
    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
    replay.drawPolygon(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawMultiPolygon = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.PolygonReplay} */replayGroup.getReplay(0, _replaytype2.default.POLYGON);
    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
    replay.drawMultiPolygon(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.drawCircle = function (geometry, data) {
    var context = this.context_;
    var replayGroup = new _replaygroup2.default(1, this.extent_);
    var replay = /** @type {ol.render.webgl.CircleReplay} */replayGroup.getReplay(0, _replaytype2.default.CIRCLE);
    replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
    replay.drawCircle(geometry, data);
    replay.finish(context);
    var opacity = 1;
    var skippedFeatures = {};
    var featureCallback;
    var oneByOne = false;
    replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
    replay.getDeleteResourcesFunction(context)();
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.setImageStyle = function (imageStyle) {
    this.imageStyle_ = imageStyle;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    this.fillStyle_ = fillStyle;
    this.strokeStyle_ = strokeStyle;
  };
}
exports.default = _ol_render_webgl_Immediate_;


},{"../../extent":68,"../../geom/geometrytype":98,"../../index":110,"../replaytype":181,"../vectorcontext":182,"../webgl/replaygroup":194}],189:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _color = require('../../color');

var _color2 = _interopRequireDefault(_color);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _orient = require('../../geom/flat/orient');

var _orient2 = _interopRequireDefault(_orient);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _topology = require('../../geom/flat/topology');

var _topology2 = _interopRequireDefault(_topology);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _replay = require('../webgl/replay');

var _replay2 = _interopRequireDefault(_replay);

var _defaultshader = require('../webgl/linestringreplay/defaultshader');

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _webgl3 = require('../../webgl');

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.webgl.Replay}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_LineStringReplay_ = function (tolerance, maxExtent) {
    _replay2.default.call(this, tolerance, maxExtent);

    /**
     * @private
     * @type {ol.render.webgl.linestringreplay.defaultshader.Locations}
     */
    this.defaultLocations_ = null;

    /**
     * @private
     * @type {Array.<Array.<?>>}
     */
    this.styles_ = [];

    /**
     * @private
     * @type {Array.<number>}
     */
    this.styleIndices_ = [];

    /**
     * @private
     * @type {{strokeColor: (Array.<number>|null),
     *         lineCap: (string|undefined),
     *         lineDash: Array.<number>,
     *         lineDashOffset: (number|undefined),
     *         lineJoin: (string|undefined),
     *         lineWidth: (number|undefined),
     *         miterLimit: (number|undefined),
     *         changed: boolean}|null}
     */
    this.state_ = {
      strokeColor: null,
      lineCap: undefined,
      lineDash: null,
      lineDashOffset: undefined,
      lineJoin: undefined,
      lineWidth: undefined,
      miterLimit: undefined,
      changed: false
    };
  };

  _index2.default.inherits(_ol_render_webgl_LineStringReplay_, _replay2.default);

  /**
   * Draw one segment.
   * @private
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
    var this$1 = this;


    var i, ii;
    var numVertices = this.vertices.length;
    var numIndices = this.indices.length;
    //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from
    //ol.render.webgl.LineStringReplay.Instruction_, and a rounding factor (1 or 2). If the product is even,
    //we round it. If it is odd, we don't.
    var lineJoin = this.state_.lineJoin === 'bevel' ? 0 : this.state_.lineJoin === 'miter' ? 1 : 2;
    var lineCap = this.state_.lineCap === 'butt' ? 0 : this.state_.lineCap === 'square' ? 1 : 2;
    var closed = _topology2.default.lineStringIsClosed(flatCoordinates, offset, end, stride);
    var startCoords, sign, n;
    var lastIndex = numIndices;
    var lastSign = 1;
    //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.
    var p0, p1, p2;

    for (i = offset, ii = end; i < ii; i += stride) {

      n = numVertices / 7;

      p0 = p1;
      p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]];
      //First vertex.
      if (i === offset) {
        p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
        if (end - offset === stride * 2 && _array2.default.equals(p1, p2)) {
          break;
        }
        if (closed) {
          //A closed line! Complete the circle.
          p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];

          startCoords = p2;
        } else {
          //Add the first two/four vertices.

          if (lineCap) {
            numVertices = this$1.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);

            numVertices = this$1.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);

            this$1.indices[numIndices++] = n + 2;
            this$1.indices[numIndices++] = n;
            this$1.indices[numIndices++] = n + 1;

            this$1.indices[numIndices++] = n + 1;
            this$1.indices[numIndices++] = n + 3;
            this$1.indices[numIndices++] = n + 2;
          }

          numVertices = this$1.addVertices_([0, 0], p1, p2, lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);

          numVertices = this$1.addVertices_([0, 0], p1, p2, -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);

          lastIndex = numVertices / 7 - 1;

          continue;
        }
      } else if (i === end - stride) {
        //Last vertex.
        if (closed) {
          //Same as the first vertex.
          p2 = startCoords;
          break;
        } else {
          p0 = p0 || [0, 0];

          numVertices = this$1.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);

          numVertices = this$1.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);

          this$1.indices[numIndices++] = n;
          this$1.indices[numIndices++] = lastIndex - 1;
          this$1.indices[numIndices++] = lastIndex;

          this$1.indices[numIndices++] = lastIndex;
          this$1.indices[numIndices++] = n + 1;
          this$1.indices[numIndices++] = n;

          if (lineCap) {
            numVertices = this$1.addVertices_(p0, p1, [0, 0], lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);

            numVertices = this$1.addVertices_(p0, p1, [0, 0], -lastSign * _ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);

            this$1.indices[numIndices++] = n + 2;
            this$1.indices[numIndices++] = n;
            this$1.indices[numIndices++] = n + 1;

            this$1.indices[numIndices++] = n + 1;
            this$1.indices[numIndices++] = n + 3;
            this$1.indices[numIndices++] = n + 2;
          }

          break;
        }
      } else {
        p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
      }

      // We group CW and straight lines, thus the not so inituitive CCW checking function.
      sign = _webgl2.default.triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;

      numVertices = this$1.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);

      numVertices = this$1.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);

      numVertices = this$1.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

      if (i > offset) {
        this$1.indices[numIndices++] = n;
        this$1.indices[numIndices++] = lastIndex - 1;
        this$1.indices[numIndices++] = lastIndex;

        this$1.indices[numIndices++] = n + 2;
        this$1.indices[numIndices++] = n;
        this$1.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
      }

      this$1.indices[numIndices++] = n;
      this$1.indices[numIndices++] = n + 2;
      this$1.indices[numIndices++] = n + 1;

      lastIndex = n + 2;
      lastSign = sign;

      //Add miter
      if (lineJoin) {
        numVertices = this$1.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_TOP * lineJoin, numVertices);

        this$1.indices[numIndices++] = n + 1;
        this$1.indices[numIndices++] = n + 3;
        this$1.indices[numIndices++] = n;
      }
    }

    if (closed) {
      n = n || numVertices / 7;
      sign = _orient2.default.linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;

      numVertices = this.addVertices_(p0, p1, p2, sign * _ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);

      numVertices = this.addVertices_(p0, p1, p2, -sign * _ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastIndex - 1;
      this.indices[numIndices++] = lastIndex;

      this.indices[numIndices++] = n + 1;
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
    }
  };

  /**
   * @param {Array.<number>} p0 Last coordinates.
   * @param {Array.<number>} p1 Current coordinates.
   * @param {Array.<number>} p2 Next coordinates.
   * @param {number} product Sign, instruction, and rounding product.
   * @param {number} numVertices Vertex counter.
   * @return {number} Vertex counter.
   * @private
   */
  _ol_render_webgl_LineStringReplay_.prototype.addVertices_ = function (p0, p1, p2, product, numVertices) {
    this.vertices[numVertices++] = p0[0];
    this.vertices[numVertices++] = p0[1];
    this.vertices[numVertices++] = p1[0];
    this.vertices[numVertices++] = p1[1];
    this.vertices[numVertices++] = p2[0];
    this.vertices[numVertices++] = p2[1];
    this.vertices[numVertices++] = product;

    return numVertices;
  };

  /**
   * Check if the linestring can be drawn (i. e. valid).
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {boolean} The linestring can be drawn.
   * @private
   */
  _ol_render_webgl_LineStringReplay_.prototype.isValid_ = function (flatCoordinates, offset, end, stride) {
    var range = end - offset;
    if (range < stride * 2) {
      return false;
    } else if (range === stride * 2) {
      var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];
      return !_array2.default.equals(firstP, lastP);
    }

    return true;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
    var flatCoordinates = lineStringGeometry.getFlatCoordinates();
    var stride = lineStringGeometry.getStride();
    if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
      flatCoordinates = _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);
      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }
      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);
      this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
    var this$1 = this;

    var indexCount = this.indices.length;
    var lineStringGeometries = multiLineStringGeometry.getLineStrings();
    var i, ii;
    for (i = 0, ii = lineStringGeometries.length; i < ii; ++i) {
      var flatCoordinates = lineStringGeometries[i].getFlatCoordinates();
      var stride = lineStringGeometries[i].getStride();
      if (this$1.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
        flatCoordinates = _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this$1.origin[0], -this$1.origin[1]);
        this$1.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }
    if (this.indices.length > indexCount) {
      this.startIndices.push(indexCount);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(indexCount);
        this.state_.changed = false;
      }
    }
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
   * @param {number} stride Stride.
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawPolygonCoordinates = function (flatCoordinates, holeFlatCoordinates, stride) {
    var this$1 = this;

    if (!_topology2.default.lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {
      flatCoordinates.push(flatCoordinates[0]);
      flatCoordinates.push(flatCoordinates[1]);
    }
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
    if (holeFlatCoordinates.length) {
      var i, ii;
      for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
        if (!_topology2.default.lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {
          holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);
          holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);
        }
        this$1.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);
      }
    }
  };

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {number=} opt_index Index count.
   */
  _ol_render_webgl_LineStringReplay_.prototype.setPolygonStyle = function (feature, opt_index) {
    var index = opt_index === undefined ? this.indices.length : opt_index;
    this.startIndices.push(index);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(index);
      this.state_.changed = false;
    }
  };

  /**
   * @return {number} Current index.
   */
  _ol_render_webgl_LineStringReplay_.prototype.getCurrentIndex = function () {
    return this.indices.length;
  };

  /**
   * @inheritDoc
   **/
  _ol_render_webgl_LineStringReplay_.prototype.finish = function (context) {
    // create, bind, and populate the vertices buffer
    this.verticesBuffer = new _buffer2.default(this.vertices);

    // create, bind, and populate the indices buffer
    this.indicesBuffer = new _buffer2.default(this.indices);

    this.startIndices.push(this.indices.length);

    //Clean up, if there is nothing to draw
    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
      this.styles_ = [];
    }

    this.vertices = null;
    this.indices = null;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.getDeleteResourcesFunction = function (context) {
    var verticesBuffer = this.verticesBuffer;
    var indicesBuffer = this.indicesBuffer;
    return function () {
      context.deleteBuffer(verticesBuffer);
      context.deleteBuffer(indicesBuffer);
    };
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
    // get the program
    var fragmentShader, vertexShader;
    fragmentShader = _defaultshader2.default.fragment;
    vertexShader = _defaultshader2.default.vertex;
    var program = context.getProgram(fragmentShader, vertexShader);

    // get the locations
    var locations;
    if (!this.defaultLocations_) {
      locations = new _defaultshader2.default.Locations(gl, program);
      this.defaultLocations_ = locations;
    } else {
      locations = this.defaultLocations_;
    }

    context.useProgram(program);

    // enable the vertex attrib arrays
    gl.enableVertexAttribArray(locations.a_lastPos);
    gl.vertexAttribPointer(locations.a_lastPos, 2, _webgl4.default.FLOAT, false, 28, 0);

    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 28, 8);

    gl.enableVertexAttribArray(locations.a_nextPos);
    gl.vertexAttribPointer(locations.a_nextPos, 2, _webgl4.default.FLOAT, false, 28, 16);

    gl.enableVertexAttribArray(locations.a_direction);
    gl.vertexAttribPointer(locations.a_direction, 1, _webgl4.default.FLOAT, false, 28, 24);

    // Enable renderer specific uniforms.
    gl.uniform2fv(locations.u_size, size);
    gl.uniform1f(locations.u_pixelRatio, pixelRatio);

    return locations;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.shutDownProgram = function (gl, locations) {
    gl.disableVertexAttribArray(locations.a_lastPos);
    gl.disableVertexAttribArray(locations.a_position);
    gl.disableVertexAttribArray(locations.a_nextPos);
    gl.disableVertexAttribArray(locations.a_direction);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
    var this$1 = this;

    //Save GL parameters.
    var tmpDepthFunc = /** @type {number} */gl.getParameter(gl.DEPTH_FUNC);
    var tmpDepthMask = /** @type {boolean} */gl.getParameter(gl.DEPTH_WRITEMASK);

    if (!hitDetection) {
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      gl.depthFunc(gl.NOTEQUAL);
    }

    if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
    } else {
      //Draw by style groups to minimize drawElements() calls.
      var i, start, end, nextStyle;
      end = this.startIndices[this.startIndices.length - 1];
      for (i = this.styleIndices_.length - 1; i >= 0; --i) {
        start = this$1.styleIndices_[i];
        nextStyle = this$1.styles_[i];
        this$1.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
        this$1.drawElements(gl, context, start, end);
        gl.clear(gl.DEPTH_BUFFER_BIT);
        end = start;
      }
    }
    if (!hitDetection) {
      gl.disable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      //Restore GL parameters.
      gl.depthMask(tmpDepthMask);
      gl.depthFunc(tmpDepthFunc);
    }
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object} skippedFeaturesHash Ids of features to skip.
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
    featureIndex = this.startIndices.length - 2;
    end = start = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        featureStart = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid]) {
          if (start !== end) {
            this$1.drawElements(gl, context, start, end);
            gl.clear(gl.DEPTH_BUFFER_BIT);
          }
          end = featureStart;
        }
        featureIndex--;
        start = featureStart;
      }
      if (start !== end) {
        this$1.drawElements(gl, context, start, end);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      start = end = groupStart;
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
    featureIndex = this.startIndices.length - 2;
    end = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        start = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
        /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          this$1.drawElements(gl, context, start, end);

          var result = featureCallback(feature);

          if (result) {
            return result;
          }
        }
        featureIndex--;
        end = start;
      }
    }
    return undefined;
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {Array.<number>} color Color.
   * @param {number} lineWidth Line width.
   * @param {number} miterLimit Miter limit.
   */
  _ol_render_webgl_LineStringReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth, miterLimit) {
    gl.uniform4fv(this.defaultLocations_.u_color, color);
    gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
    gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_LineStringReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var strokeStyleLineCap = strokeStyle.getLineCap();
    this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : _webgl2.default.defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : _webgl2.default.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : _webgl2.default.defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : _webgl2.default.defaultLineJoin;
    var strokeStyleColor = strokeStyle.getColor();
    if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
      strokeStyleColor = _color2.default.asArray(strokeStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || _webgl2.default.defaultStrokeStyle;
    } else {
      strokeStyleColor = _webgl2.default.defaultStrokeStyle;
    }
    var strokeStyleWidth = strokeStyle.getWidth();
    strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : _webgl2.default.defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : _webgl2.default.defaultMiterLimit;
    if (!this.state_.strokeColor || !_array2.default.equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {
      this.state_.changed = true;
      this.state_.strokeColor = strokeStyleColor;
      this.state_.lineWidth = strokeStyleWidth;
      this.state_.miterLimit = strokeStyleMiterLimit;
      this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);
    }
  };

  /**
   * @enum {number}
   * @private
   */
  _ol_render_webgl_LineStringReplay_.Instruction_ = {
    ROUND: 2,
    BEGIN_LINE: 3,
    END_LINE: 5,
    BEGIN_LINE_CAP: 7,
    END_LINE_CAP: 11,
    BEVEL_FIRST: 13,
    BEVEL_SECOND: 17,
    MITER_BOTTOM: 19,
    MITER_TOP: 23
  };
}
exports.default = _ol_render_webgl_LineStringReplay_;


},{"../../array":42,"../../color":49,"../../extent":68,"../../geom/flat/orient":89,"../../geom/flat/topology":93,"../../geom/flat/transform":94,"../../index":110,"../../obj":146,"../../webgl":260,"../../webgl/buffer":261,"../webgl":183,"../webgl/linestringreplay/defaultshader":190,"../webgl/replay":193}],190:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_webgl_linestringreplay_defaultshader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Fragment = function () {
    _fragment2.default.call(this, _ol_render_webgl_linestringreplay_defaultshader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_linestringreplay_defaultshader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;varying float a;varying vec2 b;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((b.x+1.0)/2.0*o.x*p,(b.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_linestringreplay_defaultshader_.Fragment.DEBUG_SOURCE : _ol_render_webgl_linestringreplay_defaultshader_.Fragment.OPTIMIZED_SOURCE;

  _ol_render_webgl_linestringreplay_defaultshader_.fragment = new _ol_render_webgl_linestringreplay_defaultshader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Vertex = function () {
    _vertex2.default.call(this, _ol_render_webgl_linestringreplay_defaultshader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_linestringreplay_defaultshader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Vertex.DEBUG_SOURCE = 'varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Vertex.OPTIMIZED_SOURCE = 'varying float a;varying vec2 b;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;b=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_linestringreplay_defaultshader_.Vertex.DEBUG_SOURCE : _ol_render_webgl_linestringreplay_defaultshader_.Vertex.OPTIMIZED_SOURCE;

  _ol_render_webgl_linestringreplay_defaultshader_.vertex = new _ol_render_webgl_linestringreplay_defaultshader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_render_webgl_linestringreplay_defaultshader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_color = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_color' : 'n');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_lineWidth = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_lineWidth' : 'k');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_miterLimit = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_miterLimit' : 'l');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'm');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_pixelRatio = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_pixelRatio' : 'p');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_size = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_size' : 'o');

    /**
     * @type {number}
     */
    this.a_direction = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_direction' : 'g');

    /**
     * @type {number}
     */
    this.a_lastPos = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_lastPos' : 'd');

    /**
     * @type {number}
     */
    this.a_nextPos = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_nextPos' : 'f');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'e');
  };
}
exports.default = _ol_render_webgl_linestringreplay_defaultshader_;


},{"../../../index":110,"../../../webgl/fragment":264,"../../../webgl/vertex":266}],191:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _color = require('../../color');

var _color2 = _interopRequireDefault(_color);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _contains = require('../../geom/flat/contains');

var _contains2 = _interopRequireDefault(_contains);

var _orient = require('../../geom/flat/orient');

var _orient2 = _interopRequireDefault(_orient);

var _transform = require('../../geom/flat/transform');

var _transform2 = _interopRequireDefault(_transform);

var _defaultshader = require('../webgl/polygonreplay/defaultshader');

var _defaultshader2 = _interopRequireDefault(_defaultshader);

var _linestringreplay = require('../webgl/linestringreplay');

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _replay = require('../webgl/replay');

var _replay2 = _interopRequireDefault(_replay);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _stroke = require('../../style/stroke');

var _stroke2 = _interopRequireDefault(_stroke);

var _linkedlist = require('../../structs/linkedlist');

var _linkedlist2 = _interopRequireDefault(_linkedlist);

var _rbush = require('../../structs/rbush');

var _rbush2 = _interopRequireDefault(_rbush);

var _webgl3 = require('../../webgl');

var _webgl4 = _interopRequireDefault(_webgl3);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.webgl.Replay}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_PolygonReplay_ = function (tolerance, maxExtent) {
    _replay2.default.call(this, tolerance, maxExtent);

    this.lineStringReplay = new _linestringreplay2.default(tolerance, maxExtent);

    /**
     * @private
     * @type {ol.render.webgl.polygonreplay.defaultshader.Locations}
     */
    this.defaultLocations_ = null;

    /**
     * @private
     * @type {Array.<Array.<number>>}
     */
    this.styles_ = [];

    /**
     * @private
     * @type {Array.<number>}
     */
    this.styleIndices_ = [];

    /**
     * @private
     * @type {{fillColor: (Array.<number>|null),
     *         changed: boolean}|null}
     */
    this.state_ = {
      fillColor: null,
      changed: false
    };
  };

  _index2.default.inherits(_ol_render_webgl_PolygonReplay_, _replay2.default);

  /**
   * Draw one polygon.
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
   * @param {number} stride Stride.
   * @private
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawCoordinates_ = function (flatCoordinates, holeFlatCoordinates, stride) {
    var this$1 = this;

    // Triangulate the polygon
    var outerRing = new _linkedlist2.default();
    var rtree = new _rbush2.default();
    // Initialize the outer ring
    var maxX = this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);

    // Eliminate holes, if there are any
    if (holeFlatCoordinates.length) {
      var i, ii;
      var holeLists = [];
      for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
        var holeList = {
          list: new _linkedlist2.default(),
          maxX: undefined
        };
        holeLists.push(holeList);
        holeList.maxX = this$1.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, rtree, false);
      }
      holeLists.sort(function (a, b) {
        return b.maxX - a.maxX;
      });
      for (i = 0; i < holeLists.length; ++i) {
        this$1.bridgeHole_(holeLists[i].list, holeLists[i].maxX, outerRing, maxX, rtree);
      }
    }
    this.classifyPoints_(outerRing, rtree, false);
    this.triangulate_(outerRing, rtree);
  };

  /**
   * Inserts flat coordinates in a linked list and adds them to the vertex buffer.
   * @private
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} stride Stride.
   * @param {ol.structs.LinkedList} list Linked list.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean} clockwise Coordinate order should be clockwise.
   * @return {number} Maximum X value.
   */
  _ol_render_webgl_PolygonReplay_.prototype.processFlatCoordinates_ = function (flatCoordinates, stride, list, rtree, clockwise) {
    var this$1 = this;

    var isClockwise = _orient2.default.linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);
    var i, ii, maxX;
    var n = this.vertices.length / 2;
    /** @type {ol.WebglPolygonVertex} */
    var start;
    /** @type {ol.WebglPolygonVertex} */
    var p0;
    /** @type {ol.WebglPolygonVertex} */
    var p1;
    var extents = [];
    var segments = [];
    if (clockwise === isClockwise) {
      start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);
      p0 = start;
      maxX = flatCoordinates[0];
      for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {
        p1 = this$1.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
        segments.push(this$1.insertItem_(p0, p1, list));
        extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
        maxX = flatCoordinates[i] > maxX ? flatCoordinates[i] : maxX;
        p0 = p1;
      }
      segments.push(this.insertItem_(p1, start, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
    } else {
      var end = flatCoordinates.length - stride;
      start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);
      p0 = start;
      maxX = flatCoordinates[end];
      for (i = end - stride, ii = 0; i >= ii; i -= stride) {
        p1 = this$1.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
        segments.push(this$1.insertItem_(p0, p1, list));
        extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
        maxX = flatCoordinates[i] > maxX ? flatCoordinates[i] : maxX;
        p0 = p1;
      }
      segments.push(this.insertItem_(p1, start, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
    }
    rtree.load(extents, segments);

    return maxX;
  };

  /**
   * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.
   * @private
   * @param {ol.structs.LinkedList} list Polygon ring.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean} ccw The orientation of the polygon is counter-clockwise.
   * @return {boolean} There were reclassified points.
   */
  _ol_render_webgl_PolygonReplay_.prototype.classifyPoints_ = function (list, rtree, ccw) {
    var this$1 = this;

    var start = list.firstItem();
    var s0 = start;
    var s1 = list.nextItem();
    var pointsReclassified = false;
    do {
      var reflex = ccw ? _webgl2.default.triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : _webgl2.default.triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);
      if (reflex === undefined) {
        this$1.removeItem_(s0, s1, list, rtree);
        pointsReclassified = true;
        if (s1 === start) {
          start = list.getNextItem();
        }
        s1 = s0;
        list.prevItem();
      } else if (s0.p1.reflex !== reflex) {
        s0.p1.reflex = reflex;
        pointsReclassified = true;
      }
      s0 = s1;
      s1 = list.nextItem();
    } while (s0 !== start);
    return pointsReclassified;
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} hole Linked list of the hole.
   * @param {number} holeMaxX Maximum X value of the hole.
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {number} listMaxX Maximum X value of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   */
  _ol_render_webgl_PolygonReplay_.prototype.bridgeHole_ = function (hole, holeMaxX, list, listMaxX, rtree) {
    var this$1 = this;

    this.classifyPoints_(hole, rtree, true);
    var seg = hole.firstItem();
    while (seg.p1.x !== holeMaxX) {
      seg = hole.nextItem();
    }

    var p1 = seg.p1;
    /** @type {ol.WebglPolygonVertex} */
    var p2 = { x: listMaxX, y: p1.y, i: -1 };
    var minDist = Infinity;
    var i, ii, bestPoint;
    /** @type {ol.WebglPolygonVertex} */
    var p5;

    var intersectingSegments = this.getIntersections_({ p0: p1, p1: p2 }, rtree, true);
    for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {
      var currSeg = intersectingSegments[i];
      if (currSeg.p0.reflex === undefined) {
        var intersection = this$1.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);
        var dist = Math.abs(p1.x - intersection[0]);
        if (dist < minDist) {
          minDist = dist;
          p5 = { x: intersection[0], y: intersection[1], i: -1 };
          seg = currSeg;
        }
      }
    }
    if (minDist === Infinity) {
      return;
    }
    bestPoint = seg.p1;

    if (minDist > 0) {
      var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);
      if (pointsInTriangle.length) {
        var theta = Infinity;
        for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {
          var currPoint = pointsInTriangle[i];
          var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);
          if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {
            theta = currTheta;
            bestPoint = currPoint;
          }
        }
      }
    }

    seg = list.firstItem();
    while (seg.p1 !== bestPoint) {
      seg = list.nextItem();
    }

    //We clone the bridge points as they can have different convexity.
    var p0Bridge = { x: p1.x, y: p1.y, i: p1.i, reflex: undefined };
    var p1Bridge = { x: seg.p1.x, y: seg.p1.y, i: seg.p1.i, reflex: undefined };

    hole.getNextItem().p0 = p0Bridge;
    this.insertItem_(p1, seg.p1, hole, rtree);
    this.insertItem_(p1Bridge, p0Bridge, hole, rtree);
    seg.p1 = p1Bridge;
    hole.setFirstItem();
    list.concat(hole);
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   */
  _ol_render_webgl_PolygonReplay_.prototype.triangulate_ = function (list, rtree) {
    var this$1 = this;

    var ccw = false;
    var simple = this.isSimple_(list, rtree);

    // Start clipping ears
    while (list.getLength() > 3) {
      if (simple) {
        if (!this$1.clipEars_(list, rtree, simple, ccw)) {
          if (!this$1.classifyPoints_(list, rtree, ccw)) {
            // Due to the behavior of OL's PIP algorithm, the ear clipping cannot
            // introduce touching segments. However, the original data may have some.
            if (!this$1.resolveLocalSelfIntersections_(list, rtree, true)) {
              break;
            }
          }
        }
      } else {
        if (!this$1.clipEars_(list, rtree, simple, ccw)) {
          // We ran out of ears, try to reclassify.
          if (!this$1.classifyPoints_(list, rtree, ccw)) {
            // We have a bad polygon, try to resolve local self-intersections.
            if (!this$1.resolveLocalSelfIntersections_(list, rtree)) {
              simple = this$1.isSimple_(list, rtree);
              if (!simple) {
                // We have a really bad polygon, try more time consuming methods.
                this$1.splitPolygon_(list, rtree);
                break;
              } else {
                ccw = !this$1.isClockwise_(list);
                this$1.classifyPoints_(list, rtree, ccw);
              }
            }
          }
        }
      }
    }
    if (list.getLength() === 3) {
      var numIndices = this.indices.length;
      this.indices[numIndices++] = list.getPrevItem().p0.i;
      this.indices[numIndices++] = list.getCurrItem().p0.i;
      this.indices[numIndices++] = list.getNextItem().p0.i;
    }
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean} simple The polygon is simple.
   * @param {boolean} ccw Orientation of the polygon is counter-clockwise.
   * @return {boolean} There were processed ears.
   */
  _ol_render_webgl_PolygonReplay_.prototype.clipEars_ = function (list, rtree, simple, ccw) {
    var this$1 = this;

    var numIndices = this.indices.length;
    var start = list.firstItem();
    var s0 = list.getPrevItem();
    var s1 = start;
    var s2 = list.nextItem();
    var s3 = list.getNextItem();
    var p0, p1, p2;
    var processedEars = false;
    do {
      p0 = s1.p0;
      p1 = s1.p1;
      p2 = s2.p1;
      if (p1.reflex === false) {
        // We might have a valid ear
        var diagonalIsInside = ccw ? this$1.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this$1.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);
        if ((simple || this$1.getIntersections_({ p0: p0, p1: p2 }, rtree).length === 0) && diagonalIsInside && this$1.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0) {
          //The diagonal is completely inside the polygon
          if (simple || p0.reflex === false || p2.reflex === false || _orient2.default.linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {
            //The diagonal is persumably valid, we have an ear
            this$1.indices[numIndices++] = p0.i;
            this$1.indices[numIndices++] = p1.i;
            this$1.indices[numIndices++] = p2.i;
            this$1.removeItem_(s1, s2, list, rtree);
            if (s2 === start) {
              start = s3;
            }
            processedEars = true;
          }
        }
      }
      // Else we have a reflex point.
      s0 = list.getPrevItem();
      s1 = list.getCurrItem();
      s2 = list.nextItem();
      s3 = list.getNextItem();
    } while (s1 !== start && list.getLength() > 3);

    return processedEars;
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean=} opt_touch Resolve touching segments.
   * @return {boolean} There were resolved intersections.
  */
  _ol_render_webgl_PolygonReplay_.prototype.resolveLocalSelfIntersections_ = function (list, rtree, opt_touch) {
    var this$1 = this;

    var start = list.firstItem();
    list.nextItem();
    var s0 = start;
    var s1 = list.nextItem();
    var resolvedIntersections = false;

    do {
      var intersection = this$1.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);
      if (intersection) {
        var breakCond = false;
        var numVertices = this$1.vertices.length;
        var numIndices = this$1.indices.length;
        var n = numVertices / 2;
        var seg = list.prevItem();
        list.removeItem();
        rtree.remove(seg);
        breakCond = seg === start;
        var p;
        if (opt_touch) {
          if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {
            list.prevItem();
            p = s0.p0;
            s1.p0 = p;
            rtree.remove(s0);
            breakCond = breakCond || s0 === start;
          } else {
            p = s1.p1;
            s0.p1 = p;
            rtree.remove(s1);
            breakCond = breakCond || s1 === start;
          }
          list.removeItem();
        } else {
          p = this$1.createPoint_(intersection[0], intersection[1], n);
          s0.p1 = p;
          s1.p0 = p;
          rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
          rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);
        }

        this$1.indices[numIndices++] = seg.p0.i;
        this$1.indices[numIndices++] = seg.p1.i;
        this$1.indices[numIndices++] = p.i;

        resolvedIntersections = true;
        if (breakCond) {
          break;
        }
      }

      s0 = list.getPrevItem();
      s1 = list.nextItem();
    } while (s0 !== start);
    return resolvedIntersections;
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @return {boolean} The polygon is simple.
   */
  _ol_render_webgl_PolygonReplay_.prototype.isSimple_ = function (list, rtree) {
    var this$1 = this;

    var start = list.firstItem();
    var seg = start;
    do {
      if (this$1.getIntersections_(seg, rtree).length) {
        return false;
      }
      seg = list.nextItem();
    } while (seg !== start);
    return true;
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @return {boolean} Orientation is clockwise.
   */
  _ol_render_webgl_PolygonReplay_.prototype.isClockwise_ = function (list) {
    var length = list.getLength() * 2;
    var flatCoordinates = new Array(length);
    var start = list.firstItem();
    var seg = start;
    var i = 0;
    do {
      flatCoordinates[i++] = seg.p0.x;
      flatCoordinates[i++] = seg.p0.y;
      seg = list.nextItem();
    } while (seg !== start);
    return _orient2.default.linearRingIsClockwise(flatCoordinates, 0, length, 2);
  };

  /**
   * @private
   * @param {ol.structs.LinkedList} list Linked list of the polygon.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   */
  _ol_render_webgl_PolygonReplay_.prototype.splitPolygon_ = function (list, rtree) {
    var this$1 = this;

    var start = list.firstItem();
    var s0 = start;
    do {
      var intersections = this$1.getIntersections_(s0, rtree);
      if (intersections.length) {
        var s1 = intersections[0];
        var n = this$1.vertices.length / 2;
        var intersection = this$1.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);
        var p = this$1.createPoint_(intersection[0], intersection[1], n);
        var newPolygon = new _linkedlist2.default();
        var newRtree = new _rbush2.default();
        this$1.insertItem_(p, s0.p1, newPolygon, newRtree);
        s0.p1 = p;
        rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);
        var currItem = list.nextItem();
        while (currItem !== s1) {
          this$1.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);
          rtree.remove(currItem);
          list.removeItem();
          currItem = list.getCurrItem();
        }
        this$1.insertItem_(s1.p0, p, newPolygon, newRtree);
        s1.p0 = p;
        rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);
        this$1.classifyPoints_(list, rtree, false);
        this$1.triangulate_(list, rtree);
        this$1.classifyPoints_(newPolygon, newRtree, false);
        this$1.triangulate_(newPolygon, newRtree);
        break;
      }
      s0 = list.nextItem();
    } while (s0 !== start);
  };

  /**
   * @private
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   * @param {number} i Index.
   * @return {ol.WebglPolygonVertex} List item.
   */
  _ol_render_webgl_PolygonReplay_.prototype.createPoint_ = function (x, y, i) {
    var numVertices = this.vertices.length;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    /** @type {ol.WebglPolygonVertex} */
    var p = {
      x: x,
      y: y,
      i: i,
      reflex: undefined
    };
    return p;
  };

  /**
   * @private
   * @param {ol.WebglPolygonVertex} p0 First point of segment.
   * @param {ol.WebglPolygonVertex} p1 Second point of segment.
   * @param {ol.structs.LinkedList} list Polygon ring.
   * @param {ol.structs.RBush=} opt_rtree Insert the segment into the R-Tree.
   * @return {ol.WebglPolygonSegment} segment.
   */
  _ol_render_webgl_PolygonReplay_.prototype.insertItem_ = function (p0, p1, list, opt_rtree) {
    var seg = {
      p0: p0,
      p1: p1
    };
    list.insertItem(seg);
    if (opt_rtree) {
      opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);
    }
    return seg;
  };

  /**
   * @private
   * @param {ol.WebglPolygonSegment} s0 Segment before the remove candidate.
   * @param {ol.WebglPolygonSegment} s1 Remove candidate segment.
   * @param {ol.structs.LinkedList} list Polygon ring.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   */
  _ol_render_webgl_PolygonReplay_.prototype.removeItem_ = function (s0, s1, list, rtree) {
    if (list.getCurrItem() === s1) {
      list.removeItem();
      s0.p1 = s1.p1;
      rtree.remove(s1);
      rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
    }
  };

  /**
   * @private
   * @param {ol.WebglPolygonVertex} p0 First point.
   * @param {ol.WebglPolygonVertex} p1 Second point.
   * @param {ol.WebglPolygonVertex} p2 Third point.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean=} opt_reflex Only include reflex points.
   * @return {Array.<ol.WebglPolygonVertex>} Points in the triangle.
   */
  _ol_render_webgl_PolygonReplay_.prototype.getPointsInTriangle_ = function (p0, p1, p2, rtree, opt_reflex) {
    var i, ii, j, p;
    var result = [];
    var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);
    for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
      for (j in segmentsInExtent[i]) {
        p = segmentsInExtent[i][j];
        if (typeof p === 'object' && (!opt_reflex || p.reflex)) {
          if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && _contains2.default.linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {
            result.push(p);
          }
        }
      }
    }
    return result;
  };

  /**
   * @private
   * @param {ol.WebglPolygonSegment} segment Segment.
   * @param {ol.structs.RBush} rtree R-Tree of the polygon.
   * @param {boolean=} opt_touch Touching segments should be considered an intersection.
   * @return {Array.<ol.WebglPolygonSegment>} Intersecting segments.
   */
  _ol_render_webgl_PolygonReplay_.prototype.getIntersections_ = function (segment, rtree, opt_touch) {
    var this$1 = this;

    var p0 = segment.p0;
    var p1 = segment.p1;
    var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
    var result = [];
    var i, ii;
    for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
      var currSeg = segmentsInExtent[i];
      if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this$1.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {
        result.push(currSeg);
      }
    }
    return result;
  };

  /**
   * Line intersection algorithm by Paul Bourke.
   * @see http://paulbourke.net/geometry/pointlineplane/
   *
   * @private
   * @param {ol.WebglPolygonVertex} p0 First point.
   * @param {ol.WebglPolygonVertex} p1 Second point.
   * @param {ol.WebglPolygonVertex} p2 Third point.
   * @param {ol.WebglPolygonVertex} p3 Fourth point.
   * @param {boolean=} opt_touch Touching segments should be considered an intersection.
   * @return {Array.<number>|undefined} Intersection coordinates.
   */
  _ol_render_webgl_PolygonReplay_.prototype.calculateIntersection_ = function (p0, p1, p2, p3, opt_touch) {
    var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);
    if (denom !== 0) {
      var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;
      var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;
      if (!opt_touch && ua > _webgl2.default.EPSILON && ua < 1 - _webgl2.default.EPSILON && ub > _webgl2.default.EPSILON && ub < 1 - _webgl2.default.EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
        return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];
      }
    }
    return undefined;
  };

  /**
   * @private
   * @param {ol.WebglPolygonVertex} p0 Point before the start of the diagonal.
   * @param {ol.WebglPolygonVertex} p1 Start point of the diagonal.
   * @param {ol.WebglPolygonVertex} p2 Ear candidate.
   * @param {ol.WebglPolygonVertex} p3 End point of the diagonal.
   * @param {ol.WebglPolygonVertex} p4 Point after the end of the diagonal.
   * @return {boolean} Diagonal is inside the polygon.
   */
  _ol_render_webgl_PolygonReplay_.prototype.diagonalIsInside_ = function (p0, p1, p2, p3, p4) {
    if (p1.reflex === undefined || p3.reflex === undefined) {
      return false;
    }
    var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);
    var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);
    var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);
    var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);
    var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;
    var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;
    return p1InCone && p3InCone;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
    var this$1 = this;

    var polygons = multiPolygonGeometry.getPolygons();
    var stride = multiPolygonGeometry.getStride();
    var currIndex = this.indices.length;
    var currLineIndex = this.lineStringReplay.getCurrentIndex();
    var i, ii, j, jj;
    for (i = 0, ii = polygons.length; i < ii; ++i) {
      var linearRings = polygons[i].getLinearRings();
      if (linearRings.length > 0) {
        var flatCoordinates = linearRings[0].getFlatCoordinates();
        flatCoordinates = _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this$1.origin[0], -this$1.origin[1]);
        var holes = [];
        var holeFlatCoords;
        for (j = 1, jj = linearRings.length; j < jj; ++j) {
          holeFlatCoords = linearRings[j].getFlatCoordinates();
          holeFlatCoords = _transform2.default.translate(holeFlatCoords, 0, holeFlatCoords.length, stride, -this$1.origin[0], -this$1.origin[1]);
          holes.push(holeFlatCoords);
        }
        this$1.lineStringReplay.drawPolygonCoordinates(flatCoordinates, holes, stride);
        this$1.drawCoordinates_(flatCoordinates, holes, stride);
      }
    }
    if (this.indices.length > currIndex) {
      this.startIndices.push(currIndex);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(currIndex);
        this.state_.changed = false;
      }
    }
    if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {
      this.lineStringReplay.setPolygonStyle(feature, currLineIndex);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
    var this$1 = this;

    var linearRings = polygonGeometry.getLinearRings();
    var stride = polygonGeometry.getStride();
    if (linearRings.length > 0) {
      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }
      this.lineStringReplay.setPolygonStyle(feature);

      var flatCoordinates = linearRings[0].getFlatCoordinates();
      flatCoordinates = _transform2.default.translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);
      var holes = [];
      var i, ii, holeFlatCoords;
      for (i = 1, ii = linearRings.length; i < ii; ++i) {
        holeFlatCoords = linearRings[i].getFlatCoordinates();
        holeFlatCoords = _transform2.default.translate(holeFlatCoords, 0, holeFlatCoords.length, stride, -this$1.origin[0], -this$1.origin[1]);
        holes.push(holeFlatCoords);
      }
      this.lineStringReplay.drawPolygonCoordinates(flatCoordinates, holes, stride);
      this.drawCoordinates_(flatCoordinates, holes, stride);
    }
  };

  /**
   * @inheritDoc
   **/
  _ol_render_webgl_PolygonReplay_.prototype.finish = function (context) {
    // create, bind, and populate the vertices buffer
    this.verticesBuffer = new _buffer2.default(this.vertices);

    // create, bind, and populate the indices buffer
    this.indicesBuffer = new _buffer2.default(this.indices);

    this.startIndices.push(this.indices.length);

    this.lineStringReplay.finish(context);

    //Clean up, if there is nothing to draw
    if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
      this.styles_ = [];
    }

    this.vertices = null;
    this.indices = null;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.getDeleteResourcesFunction = function (context) {
    var verticesBuffer = this.verticesBuffer;
    var indicesBuffer = this.indicesBuffer;
    var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);
    return function () {
      context.deleteBuffer(verticesBuffer);
      context.deleteBuffer(indicesBuffer);
      lineDeleter();
    };
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
    // get the program
    var fragmentShader, vertexShader;
    fragmentShader = _defaultshader2.default.fragment;
    vertexShader = _defaultshader2.default.vertex;
    var program = context.getProgram(fragmentShader, vertexShader);

    // get the locations
    var locations;
    if (!this.defaultLocations_) {
      locations = new _defaultshader2.default.Locations(gl, program);
      this.defaultLocations_ = locations;
    } else {
      locations = this.defaultLocations_;
    }

    context.useProgram(program);

    // enable the vertex attrib arrays
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, _webgl4.default.FLOAT, false, 8, 0);

    return locations;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.shutDownProgram = function (gl, locations) {
    gl.disableVertexAttribArray(locations.a_position);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
    var this$1 = this;

    //Save GL parameters.
    var tmpDepthFunc = /** @type {number} */gl.getParameter(gl.DEPTH_FUNC);
    var tmpDepthMask = /** @type {boolean} */gl.getParameter(gl.DEPTH_WRITEMASK);

    if (!hitDetection) {
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      gl.depthFunc(gl.NOTEQUAL);
    }

    if (!_obj2.default.isEmpty(skippedFeaturesHash)) {
      this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
    } else {
      //Draw by style groups to minimize drawElements() calls.
      var i, start, end, nextStyle;
      end = this.startIndices[this.startIndices.length - 1];
      for (i = this.styleIndices_.length - 1; i >= 0; --i) {
        start = this$1.styleIndices_[i];
        nextStyle = this$1.styles_[i];
        this$1.setFillStyle_(gl, nextStyle);
        this$1.drawElements(gl, context, start, end);
        end = start;
      }
    }
    if (!hitDetection) {
      gl.disable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      //Restore GL parameters.
      gl.depthMask(tmpDepthMask);
      gl.depthFunc(tmpDepthFunc);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
    featureIndex = this.startIndices.length - 2;
    end = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setFillStyle_(gl, nextStyle);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        start = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || _extent2.default.intersects(
        /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          this$1.drawElements(gl, context, start, end);

          var result = featureCallback(feature);

          if (result) {
            return result;
          }
        }
        featureIndex--;
        end = start;
      }
    }
    return undefined;
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object} skippedFeaturesHash Ids of features to skip.
   */
  _ol_render_webgl_PolygonReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
    var this$1 = this;

    var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
    featureIndex = this.startIndices.length - 2;
    end = start = this.startIndices[featureIndex + 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      nextStyle = this$1.styles_[i];
      this$1.setFillStyle_(gl, nextStyle);
      groupStart = this$1.styleIndices_[i];

      while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
        featureStart = this$1.startIndices[featureIndex];
        feature = this$1.startIndicesFeature[featureIndex];
        featureUid = _index2.default.getUid(feature).toString();

        if (skippedFeaturesHash[featureUid]) {
          if (start !== end) {
            this$1.drawElements(gl, context, start, end);
            gl.clear(gl.DEPTH_BUFFER_BIT);
          }
          end = featureStart;
        }
        featureIndex--;
        start = featureStart;
      }
      if (start !== end) {
        this$1.drawElements(gl, context, start, end);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      start = end = groupStart;
    }
  };

  /**
   * @private
   * @param {WebGLRenderingContext} gl gl.
   * @param {Array.<number>} color Color.
   */
  _ol_render_webgl_PolygonReplay_.prototype.setFillStyle_ = function (gl, color) {
    gl.uniform4fv(this.defaultLocations_.u_color, color);
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_PolygonReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
    var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
    if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
      fillStyleColor = _color2.default.asArray(fillStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || _webgl2.default.defaultFillStyle;
    } else {
      fillStyleColor = _webgl2.default.defaultFillStyle;
    }
    if (!this.state_.fillColor || !_array2.default.equals(fillStyleColor, this.state_.fillColor)) {
      this.state_.fillColor = fillStyleColor;
      this.state_.changed = true;
      this.styles_.push(fillStyleColor);
    }
    //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.
    if (strokeStyle) {
      this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    } else {
      var nullStrokeStyle = new _stroke2.default({
        color: [0, 0, 0, 0],
        lineWidth: 0
      });
      this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);
    }
  };
}
exports.default = _ol_render_webgl_PolygonReplay_;


},{"../../array":42,"../../color":49,"../../extent":68,"../../geom/flat/contains":82,"../../geom/flat/orient":89,"../../geom/flat/transform":94,"../../index":110,"../../obj":146,"../../structs/linkedlist":233,"../../structs/rbush":236,"../../style/stroke":243,"../../webgl":260,"../../webgl/buffer":261,"../webgl":183,"../webgl/linestringreplay":189,"../webgl/polygonreplay/defaultshader":192,"../webgl/replay":193}],192:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_render_webgl_polygonreplay_defaultshader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Fragment = function () {
    _fragment2.default.call(this, _ol_render_webgl_polygonreplay_defaultshader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_polygonreplay_defaultshader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_polygonreplay_defaultshader_.Fragment.DEBUG_SOURCE : _ol_render_webgl_polygonreplay_defaultshader_.Fragment.OPTIMIZED_SOURCE;

  _ol_render_webgl_polygonreplay_defaultshader_.fragment = new _ol_render_webgl_polygonreplay_defaultshader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Vertex = function () {
    _vertex2.default.call(this, _ol_render_webgl_polygonreplay_defaultshader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_render_webgl_polygonreplay_defaultshader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Vertex.DEBUG_SOURCE = '\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Vertex.OPTIMIZED_SOURCE = 'attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}';

  /**
   * @const
   * @type {string}
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_render_webgl_polygonreplay_defaultshader_.Vertex.DEBUG_SOURCE : _ol_render_webgl_polygonreplay_defaultshader_.Vertex.OPTIMIZED_SOURCE;

  _ol_render_webgl_polygonreplay_defaultshader_.vertex = new _ol_render_webgl_polygonreplay_defaultshader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_render_webgl_polygonreplay_defaultshader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_color = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_color' : 'e');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetRotateMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'd');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_offsetScaleMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'c');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'f');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'b');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'a');
  };
}
exports.default = _ol_render_webgl_polygonreplay_defaultshader_;


},{"../../../index":110,"../../../webgl/fragment":264,"../../../webgl/vertex":266}],193:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _vectorcontext = require('../vectorcontext');

var _vectorcontext2 = _interopRequireDefault(_vectorcontext);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

var _mat = require('../../vec/mat4');

var _mat2 = _interopRequireDefault(_mat);

var _webgl = require('../../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @abstract
   * @extends {ol.render.VectorContext}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_Replay_ = function (tolerance, maxExtent) {
    _vectorcontext2.default.call(this);

    /**
     * @protected
     * @type {number}
     */
    this.tolerance = tolerance;

    /**
     * @protected
     * @const
     * @type {ol.Extent}
     */
    this.maxExtent = maxExtent;

    /**
     * The origin of the coordinate system for the point coordinates sent to
     * the GPU. To eliminate jitter caused by precision problems in the GPU
     * we use the "Rendering Relative to Eye" technique described in the "3D
     * Engine Design for Virtual Globes" book.
     * @protected
     * @type {ol.Coordinate}
     */
    this.origin = _extent2.default.getCenter(maxExtent);

    /**
     * @private
     * @type {ol.Transform}
     */
    this.projectionMatrix_ = _transform2.default.create();

    /**
     * @private
     * @type {ol.Transform}
     */
    this.offsetRotateMatrix_ = _transform2.default.create();

    /**
     * @private
     * @type {ol.Transform}
     */
    this.offsetScaleMatrix_ = _transform2.default.create();

    /**
     * @private
     * @type {Array.<number>}
     */
    this.tmpMat4_ = _mat2.default.create();

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.indices = [];

    /**
     * @protected
     * @type {?ol.webgl.Buffer}
     */
    this.indicesBuffer = null;

    /**
     * Start index per feature (the index).
     * @protected
     * @type {Array.<number>}
     */
    this.startIndices = [];

    /**
     * Start index per feature (the feature).
     * @protected
     * @type {Array.<ol.Feature|ol.render.Feature>}
     */
    this.startIndicesFeature = [];

    /**
     * @protected
     * @type {Array.<number>}
     */
    this.vertices = [];

    /**
     * @protected
     * @type {?ol.webgl.Buffer}
     */
    this.verticesBuffer = null;

    /**
     * Optional parameter for PolygonReplay instances.
     * @protected
     * @type {ol.render.webgl.LineStringReplay|undefined}
     */
    this.lineStringReplay = undefined;
  };

  _index2.default.inherits(_ol_render_webgl_Replay_, _vectorcontext2.default);

  /**
   * @abstract
   * @param {ol.webgl.Context} context WebGL context.
   * @return {function()} Delete resources function.
   */
  _ol_render_webgl_Replay_.prototype.getDeleteResourcesFunction = function (context) {};

  /**
   * @abstract
   * @param {ol.webgl.Context} context Context.
   */
  _ol_render_webgl_Replay_.prototype.finish = function (context) {};

  /**
   * @abstract
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @return {ol.render.webgl.circlereplay.defaultshader.Locations|
              ol.render.webgl.imagereplay.defaultshader.Locations|
              ol.render.webgl.linestringreplay.defaultshader.Locations|
              ol.render.webgl.polygonreplay.defaultshader.Locations} Locations.
   */
  _ol_render_webgl_Replay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {};

  /**
   * @abstract
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.render.webgl.circlereplay.defaultshader.Locations|
             ol.render.webgl.imagereplay.defaultshader.Locations|
             ol.render.webgl.linestringreplay.defaultshader.Locations|
             ol.render.webgl.polygonreplay.defaultshader.Locations} locations Locations.
   */
  _ol_render_webgl_Replay_.prototype.shutDownProgram = function (gl, locations) {};

  /**
   * @abstract
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {boolean} hitDetection Hit detection mode.
   */
  _ol_render_webgl_Replay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {};

  /**
   * @abstract
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
   *  this extent are checked.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_Replay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {};

  /**
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
   *  this extent are checked.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_Replay_.prototype.drawHitDetectionReplay = function (gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
    if (!oneByOne) {
      // draw all hit-detection features in "once" (by texture group)
      return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);
    } else {
      // draw hit-detection features one by one
      return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);
    }
  };

  /**
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_Replay_.prototype.drawHitDetectionReplayAll = function (gl, context, skippedFeaturesHash, featureCallback) {
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    this.drawReplay(gl, context, skippedFeaturesHash, true);

    var result = featureCallback(null);
    if (result) {
      return result;
    } else {
      return undefined;
    }
  };

  /**
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
   *  this extent are checked.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_Replay_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
    var gl = context.getGL();
    var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;

    if (this.lineStringReplay) {
      tmpStencil = gl.isEnabled(gl.STENCIL_TEST);
      tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
      tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);
      tmpStencilRef = gl.getParameter(gl.STENCIL_REF);
      tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);
      tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);
      tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
      tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);

      gl.enable(gl.STENCIL_TEST);
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.stencilMask(255);
      gl.stencilFunc(gl.ALWAYS, 1, 255);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

      this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);

      gl.stencilMask(0);
      gl.stencilFunc(gl.NOTEQUAL, 1, 255);
    }

    context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.verticesBuffer);

    context.bindBuffer(_webgl2.default.ELEMENT_ARRAY_BUFFER, this.indicesBuffer);

    var locations = this.setUpProgram(gl, context, size, pixelRatio);

    // set the "uniform" values
    var projectionMatrix = _transform2.default.reset(this.projectionMatrix_);
    _transform2.default.scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));
    _transform2.default.rotate(projectionMatrix, -rotation);
    _transform2.default.translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));

    var offsetScaleMatrix = _transform2.default.reset(this.offsetScaleMatrix_);
    _transform2.default.scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);

    var offsetRotateMatrix = _transform2.default.reset(this.offsetRotateMatrix_);
    if (rotation !== 0) {
      _transform2.default.rotate(offsetRotateMatrix, -rotation);
    }

    gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, projectionMatrix));
    gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, offsetScaleMatrix));
    gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, offsetRotateMatrix));
    gl.uniform1f(locations.u_opacity, opacity);

    // draw!
    var result;
    if (featureCallback === undefined) {
      this.drawReplay(gl, context, skippedFeaturesHash, false);
    } else {
      // draw feature by feature for the hit-detection
      result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
    }

    // disable the vertex attrib arrays
    this.shutDownProgram(gl, locations);

    if (this.lineStringReplay) {
      if (!tmpStencil) {
        gl.disable(gl.STENCIL_TEST);
      }
      gl.clear(gl.STENCIL_BUFFER_BIT);
      gl.stencilFunc( /** @type {number} */tmpStencilFunc,
      /** @type {number} */tmpStencilRef, /** @type {number} */tmpStencilMaskVal);
      gl.stencilMask( /** @type {number} */tmpStencilMask);
      gl.stencilOp( /** @type {number} */tmpStencilOpFail,
      /** @type {number} */tmpStencilOpZFail, /** @type {number} */tmpStencilOpPass);
    }

    return result;
  };

  /**
   * @protected
   * @param {WebGLRenderingContext} gl gl.
   * @param {ol.webgl.Context} context Context.
   * @param {number} start Start index.
   * @param {number} end End index.
   */
  _ol_render_webgl_Replay_.prototype.drawElements = function (gl, context, start, end) {
    var elementType = context.hasOESElementIndexUint ? _webgl2.default.UNSIGNED_INT : _webgl2.default.UNSIGNED_SHORT;
    var elementSize = context.hasOESElementIndexUint ? 4 : 2;

    var numItems = end - start;
    var offsetInBytes = start * elementSize;
    gl.drawElements(_webgl2.default.TRIANGLES, numItems, elementType, offsetInBytes);
  };
}
exports.default = _ol_render_webgl_Replay_;


},{"../../extent":68,"../../index":110,"../../transform":254,"../../vec/mat4":255,"../../webgl":260,"../vectorcontext":182}],194:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _obj = require('../../obj');

var _obj2 = _interopRequireDefault(_obj);

var _replay = require('../replay');

var _replay2 = _interopRequireDefault(_replay);

var _replaygroup = require('../replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _circlereplay = require('../webgl/circlereplay');

var _circlereplay2 = _interopRequireDefault(_circlereplay);

var _imagereplay = require('../webgl/imagereplay');

var _imagereplay2 = _interopRequireDefault(_imagereplay);

var _linestringreplay = require('../webgl/linestringreplay');

var _linestringreplay2 = _interopRequireDefault(_linestringreplay);

var _polygonreplay = require('../webgl/polygonreplay');

var _polygonreplay2 = _interopRequireDefault(_polygonreplay);

var _textreplay = require('../webgl/textreplay');

var _textreplay2 = _interopRequireDefault(_textreplay);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.render.ReplayGroup}
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @param {number=} opt_renderBuffer Render buffer.
   * @struct
   */
  var _ol_render_webgl_ReplayGroup_ = function (tolerance, maxExtent, opt_renderBuffer) {
    _replaygroup2.default.call(this);

    /**
     * @type {ol.Extent}
     * @private
     */
    this.maxExtent_ = maxExtent;

    /**
     * @type {number}
     * @private
     */
    this.tolerance_ = tolerance;

    /**
     * @type {number|undefined}
     * @private
     */
    this.renderBuffer_ = opt_renderBuffer;

    /**
     * @private
     * @type {!Object.<string,
     *        Object.<ol.render.ReplayType, ol.render.webgl.Replay>>}
     */
    this.replaysByZIndex_ = {};
  };

  _index2.default.inherits(_ol_render_webgl_ReplayGroup_, _replaygroup2.default);

  /**
   * @param {ol.webgl.Context} context WebGL context.
   * @return {function()} Delete resources function.
   */
  _ol_render_webgl_ReplayGroup_.prototype.getDeleteResourcesFunction = function (context) {
    var this$1 = this;

    var functions = [];
    var zKey;
    for (zKey in this$1.replaysByZIndex_) {
      var replays = this$1.replaysByZIndex_[zKey];
      var replayKey;
      for (replayKey in replays) {
        functions.push(replays[replayKey].getDeleteResourcesFunction(context));
      }
    }
    return function () {
      var arguments$1 = arguments;
      var this$1 = this;

      var length = functions.length;
      var result;
      for (var i = 0; i < length; i++) {
        result = functions[i].apply(this$1, arguments$1);
      }
      return result;
    };
  };

  /**
   * @param {ol.webgl.Context} context Context.
   */
  _ol_render_webgl_ReplayGroup_.prototype.finish = function (context) {
    var this$1 = this;

    var zKey;
    for (zKey in this$1.replaysByZIndex_) {
      var replays = this$1.replaysByZIndex_[zKey];
      var replayKey;
      for (replayKey in replays) {
        replays[replayKey].finish(context);
      }
    }
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
    var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
    var replays = this.replaysByZIndex_[zIndexKey];
    if (replays === undefined) {
      replays = {};
      this.replaysByZIndex_[zIndexKey] = replays;
    }
    var replay = replays[replayType];
    if (replay === undefined) {
      /**
       * @type {Function}
       */
      var Constructor = _ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
      replay = new Constructor(this.tolerance_, this.maxExtent_);
      replays[replayType] = replay;
    }
    return replay;
  };

  /**
   * @inheritDoc
   */
  _ol_render_webgl_ReplayGroup_.prototype.isEmpty = function () {
    return _obj2.default.isEmpty(this.replaysByZIndex_);
  };

  /**
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   */
  _ol_render_webgl_ReplayGroup_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
    var this$1 = this;

    /** @type {Array.<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(_array2.default.numberSafeCompareFunction);

    var i, ii, j, jj, replays, replay;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      replays = this$1.replaysByZIndex_[zs[i].toString()];
      for (j = 0, jj = _replay2.default.ORDER.length; j < jj; ++j) {
        replay = replays[_replay2.default.ORDER[j]];
        if (replay !== undefined) {
          replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);
        }
      }
    }
  };

  /**
   * @private
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
   *  this extent are checked.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_ReplayGroup_.prototype.replayHitDetection_ = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
    var this$1 = this;

    /** @type {Array.<number>} */
    var zs = Object.keys(this.replaysByZIndex_).map(Number);
    zs.sort(function (a, b) {
      return b - a;
    });

    var i, ii, j, replays, replay, result;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      replays = this$1.replaysByZIndex_[zs[i].toString()];
      for (j = _replay2.default.ORDER.length - 1; j >= 0; --j) {
        replay = replays[_replay2.default.ORDER[j]];
        if (replay !== undefined) {
          result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
          if (result) {
            return result;
          }
        }
      }
    }
    return undefined;
  };

  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} callback Feature callback.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {
    var gl = context.getGL();
    gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());

    /**
     * @type {ol.Extent}
     */
    var hitExtent;
    if (this.renderBuffer_ !== undefined) {
      // build an extent around the coordinate, so that only features that
      // intersect this extent are checked
      hitExtent = _extent2.default.buffer(_extent2.default.createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);
    }

    return this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var imageData = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

      if (imageData[3] > 0) {
        var result = callback(feature);
        if (result) {
          return result;
        }
      }
    }, true, hitExtent);
  };

  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @return {boolean} Is there a feature at the given coordinate?
   */
  _ol_render_webgl_ReplayGroup_.prototype.hasFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
    var gl = context.getGL();
    gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());

    var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {boolean} Is there a feature?
     */
    function (feature) {
      var imageData = new Uint8Array(4);
      gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
      return imageData[3] > 0;
    }, false);

    return hasFeature !== undefined;
  };

  /**
   * @const
   * @private
   * @type {Array.<number>}
   */
  _ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_ = [1, 1];

  /**
   * @const
   * @private
   * @type {Object.<ol.render.ReplayType,
   *                function(new: ol.render.webgl.Replay, number,
   *                ol.Extent)>}
   */
  _ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
    'Circle': _circlereplay2.default,
    'Image': _imagereplay2.default,
    'LineString': _linestringreplay2.default,
    'Polygon': _polygonreplay2.default,
    'Text': _textreplay2.default
  };
}
exports.default = _ol_render_webgl_ReplayGroup_;


},{"../../array":42,"../../extent":68,"../../index":110,"../../obj":146,"../replay":179,"../replaygroup":180,"../webgl/circlereplay":184,"../webgl/imagereplay":186,"../webgl/linestringreplay":189,"../webgl/polygonreplay":191,"../webgl/textreplay":195}],195:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @abstract
   * @param {number} tolerance Tolerance.
   * @param {ol.Extent} maxExtent Max extent.
   * @struct
   */
  var _ol_render_webgl_TextReplay_ = function (tolerance, maxExtent) {};

  /**
   * @param {ol.style.Text} textStyle Text style.
   */
  _ol_render_webgl_TextReplay_.prototype.setTextStyle = function (textStyle) {};

  /**
   * @param {ol.webgl.Context} context Context.
   * @param {ol.Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {ol.Size} size Size.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} opacity Global opacity.
   * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
   *  to skip.
   * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
   * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
   * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
   *  this extent are checked.
   * @return {T|undefined} Callback result.
   * @template T
   */
  _ol_render_webgl_TextReplay_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
    return undefined;
  };

  /**
   * @param {Array.<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   */
  _ol_render_webgl_TextReplay_.prototype.drawText = function (flatCoordinates, offset, end, stride, geometry, feature) {};

  /**
   * @abstract
   * @param {ol.webgl.Context} context Context.
   */
  _ol_render_webgl_TextReplay_.prototype.finish = function (context) {};

  /**
   * @param {ol.webgl.Context} context WebGL context.
   * @return {function()} Delete resources function.
   */
  _ol_render_webgl_TextReplay_.prototype.getDeleteResourcesFunction = function (context) {
    return _index2.default.nullFunction;
  };
}
exports.default = _ol_render_webgl_TextReplay_;


},{"../../index":110}],196:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _coordinate = require('../../coordinate');

var _coordinate2 = _interopRequireDefault(_coordinate);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _layer = require('../canvas/layer');

var _layer2 = _interopRequireDefault(_layer);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var _ol_renderer_canvas_IntermediateCanvas_ = function (layer) {

  _layer2.default.call(this, layer);

  /**
   * @protected
   * @type {ol.Transform}
   */
  this.coordinateToCanvasPixelTransform = _transform2.default.create();

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.hitCanvasContext_ = null;
};

_index2.default.inherits(_ol_renderer_canvas_IntermediateCanvas_, _layer2.default);

/**
 * @inheritDoc
 */
_ol_renderer_canvas_IntermediateCanvas_.prototype.composeFrame = function (frameState, layerState, context) {

  this.preCompose(context, frameState);

  var image = this.getImage();
  if (image) {

    // clipped rendering if layer extent is set
    var extent = layerState.extent;
    var clipped = extent !== undefined && !_extent2.default.containsExtent(extent, frameState.extent) && _extent2.default.intersects(extent, frameState.extent);
    if (clipped) {
      this.clip(context, frameState, /** @type {ol.Extent} */extent);
    }

    var imageTransform = this.getImageTransform();
    // for performance reasons, context.save / context.restore is not used
    // to save and restore the transformation matrix and the opacity.
    // see http://jsperf.com/context-save-restore-versus-variable
    var alpha = context.globalAlpha;
    context.globalAlpha = layerState.opacity;

    // for performance reasons, context.setTransform is only used
    // when the view is rotated. see http://jsperf.com/canvas-transform
    var dx = imageTransform[4];
    var dy = imageTransform[5];
    var dw = image.width * imageTransform[0];
    var dh = image.height * imageTransform[3];
    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    context.globalAlpha = alpha;

    if (clipped) {
      context.restore();
    }
  }

  this.postCompose(context, frameState, layerState);
};

/**
 * @abstract
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.
 */
_ol_renderer_canvas_IntermediateCanvas_.prototype.getImage = function () {};

/**
 * @abstract
 * @return {!ol.Transform} Image transform.
 */
_ol_renderer_canvas_IntermediateCanvas_.prototype.getImageTransform = function () {};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_IntermediateCanvas_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  if (!this.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== _index2.default.nullFunction) {
    // for ImageVector sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    return _layer2.default.prototype.forEachLayerAtCoordinate.apply(this, arguments);
  } else {
    var pixel = _transform2.default.apply(this.coordinateToCanvasPixelTransform, coordinate.slice());
    _coordinate2.default.scale(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = _dom2.default.createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
exports.default = _ol_renderer_canvas_IntermediateCanvas_;


},{"../../coordinate":57,"../../dom":60,"../../extent":68,"../../index":110,"../../transform":254,"../canvas/layer":197}],197:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _functions = require('../../functions');

var _functions2 = _interopRequireDefault(_functions);

var _event = require('../../render/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('../../render/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _canvas = require('../../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _immediate = require('../../render/canvas/immediate');

var _immediate2 = _interopRequireDefault(_immediate);

var _layer = require('../layer');

var _layer2 = _interopRequireDefault(_layer);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var _ol_renderer_canvas_Layer_ = function (layer) {

  _layer2.default.call(this, layer);

  /**
   * @protected
   * @type {number}
   */
  this.renderedResolution;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = _transform2.default.create();
};

_index2.default.inherits(_ol_renderer_canvas_Layer_, _layer2.default);

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Extent} extent Clip extent.
 * @protected
 */
_ol_renderer_canvas_Layer_.prototype.clip = function (context, frameState, extent) {
  var pixelRatio = frameState.pixelRatio;
  var width = frameState.size[0] * pixelRatio;
  var height = frameState.size[1] * pixelRatio;
  var rotation = frameState.viewState.rotation;
  var topLeft = _extent2.default.getTopLeft( /** @type {ol.Extent} */extent);
  var topRight = _extent2.default.getTopRight( /** @type {ol.Extent} */extent);
  var bottomRight = _extent2.default.getBottomRight( /** @type {ol.Extent} */extent);
  var bottomLeft = _extent2.default.getBottomLeft( /** @type {ol.Extent} */extent);

  _transform2.default.apply(frameState.coordinateToPixelTransform, topLeft);
  _transform2.default.apply(frameState.coordinateToPixelTransform, topRight);
  _transform2.default.apply(frameState.coordinateToPixelTransform, bottomRight);
  _transform2.default.apply(frameState.coordinateToPixelTransform, bottomLeft);

  context.save();
  _canvas2.default.rotateAtOffset(context, -rotation, width / 2, height / 2);
  context.beginPath();
  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
  context.clip();
  _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
};

/**
 * @param {ol.render.EventType} type Event type.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @private
 */
_ol_renderer_canvas_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState, opt_transform) {
  var layer = this.getLayer();
  if (layer.hasListener(type)) {
    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;
    _canvas2.default.rotateAtOffset(context, -rotation, width / 2, height / 2);
    var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);
    var render = new _immediate2.default(context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);
    var composeEvent = new _event2.default(type, render, frameState, context, null);
    layer.dispatchEvent(composeEvent);
    _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
  }
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
_ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, _functions2.default.TRUE, this);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
_ol_renderer_canvas_Layer_.prototype.postCompose = function (context, frameState, layerState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, context, frameState, opt_transform);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
_ol_renderer_canvas_Layer_.prototype.preCompose = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, context, frameState, opt_transform);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
_ol_renderer_canvas_Layer_.prototype.dispatchRenderEvent = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(_eventtype2.default.RENDER, context, frameState, opt_transform);
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} offsetX Offset on the x-axis in view coordinates.
 * @protected
 * @return {!ol.Transform} Transform.
 */
_ol_renderer_canvas_Layer_.prototype.getTransform = function (frameState, offsetX) {
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var dx1 = pixelRatio * frameState.size[0] / 2;
  var dy1 = pixelRatio * frameState.size[1] / 2;
  var sx = pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0] + offsetX;
  var dy2 = -viewState.center[1];
  return _transform2.default.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};

/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {CanvasRenderingContext2D} context Context.
 */
_ol_renderer_canvas_Layer_.prototype.composeFrame = function (frameState, layerState, context) {};

/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @return {boolean} whether composeFrame should be called.
 */
_ol_renderer_canvas_Layer_.prototype.prepareFrame = function (frameState, layerState) {};
exports.default = _ol_renderer_canvas_Layer_;


},{"../../extent":68,"../../functions":78,"../../index":110,"../../render/canvas":167,"../../render/canvas/immediate":169,"../../render/event":176,"../../render/eventtype":177,"../../transform":254,"../layer":202}],198:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _css = require('../../css');

var _css2 = _interopRequireDefault(_css);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _layer = require('../../layer/layer');

var _layer2 = _interopRequireDefault(_layer);

var _event = require('../../render/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('../../render/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _canvas = require('../../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _immediate = require('../../render/canvas/immediate');

var _immediate2 = _interopRequireDefault(_immediate);

var _map = require('../map');

var _map2 = _interopRequireDefault(_map);

var _type = require('../type');

var _type2 = _interopRequireDefault(_type);

var _state = require('../../source/state');

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.Map} map Map.
 */
var _ol_renderer_canvas_Map_ = function (container, map) {

  _map2.default.call(this, container, map);

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = _dom2.default.createCanvasContext2D();

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = this.context_.canvas;

  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = _css2.default.CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);

  /**
   * @private
   * @type {boolean}
   */
  this.renderedVisible_ = true;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = _transform2.default.create();
}; // FIXME offset panning

_index2.default.inherits(_ol_renderer_canvas_Map_, _map2.default);

/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
_ol_renderer_canvas_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();
  var context = this.context_;
  if (map.hasListener(type)) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;

    var transform = this.getTransform(frameState);

    var vectorContext = new _immediate2.default(context, pixelRatio, extent, transform, rotation);
    var composeEvent = new _event2.default(type, vectorContext, frameState, context, null);
    map.dispatchEvent(composeEvent);
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 * @return {!ol.Transform} Transform.
 */
_ol_renderer_canvas_Map_.prototype.getTransform = function (frameState) {
  var viewState = frameState.viewState;
  var dx1 = this.canvas_.width / 2;
  var dy1 = this.canvas_.height / 2;
  var sx = frameState.pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0];
  var dy2 = -viewState.center[1];
  return _transform2.default.compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_Map_.prototype.getType = function () {
  return _type2.default.CANVAS;
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_Map_.prototype.renderFrame = function (frameState) {
  var this$1 = this;


  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }
    return;
  }

  var context = this.context_;
  var pixelRatio = frameState.pixelRatio;
  var width = Math.round(frameState.size[0] * pixelRatio);
  var height = Math.round(frameState.size[1] * pixelRatio);
  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  } else {
    context.clearRect(0, 0, width, height);
  }

  var rotation = frameState.viewState.rotation;

  this.calculateMatrices2D(frameState);

  this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, frameState);

  var layerStatesArray = frameState.layerStatesArray;
  _array2.default.stableSort(layerStatesArray, _map2.default.sortByZIndex);

  if (rotation) {
    context.save();
    _canvas2.default.rotateAtOffset(context, rotation, width / 2, height / 2);
  }

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layer, layerRenderer, layerState;
  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    layer = layerState.layer;
    layerRenderer = /** @type {ol.renderer.canvas.Layer} */this$1.getLayerRenderer(layer);
    if (!_layer2.default.visibleAtResolution(layerState, viewResolution) || layerState.sourceState != _state2.default.READY) {
      continue;
    }
    if (layerRenderer.prepareFrame(frameState, layerState)) {
      layerRenderer.composeFrame(frameState, layerState, context);
    }
  }

  if (rotation) {
    context.restore();
  }

  this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, frameState);

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  var this$1 = this;

  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;

  var coordinate = _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = /** @type {ol.renderer.canvas.Layer} */this$1.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
exports.default = _ol_renderer_canvas_Map_;


},{"../../array":42,"../../css":58,"../../dom":60,"../../index":110,"../../layer/layer":128,"../../render/canvas":167,"../../render/canvas/immediate":169,"../../render/event":176,"../../render/eventtype":177,"../../source/state":219,"../../transform":254,"../map":203,"../type":204}],199:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _tilerange = require('../../tilerange');

var _tilerange2 = _interopRequireDefault(_tilerange);

var _tilestate = require('../../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _viewhint = require('../../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _intermediatecanvas = require('../canvas/intermediatecanvas');

var _intermediatecanvas2 = _interopRequireDefault(_intermediatecanvas);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.
 */
var _ol_renderer_canvas_TileLayer_ = function (tileLayer) {

  _intermediatecanvas2.default.call(this, tileLayer);

  /**
   * @protected
   * @type {CanvasRenderingContext2D}
   */
  this.context = this.context === null ? null : _dom2.default.createCanvasContext2D();

  /**
   * @private
   * @type {number}
   */
  this.oversampling_;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedExtent_ = null;

  /**
   * @protected
   * @type {number}
   */
  this.renderedRevision;

  /**
   * @protected
   * @type {!Array.<ol.Tile>}
   */
  this.renderedTiles = [];

  /**
   * @protected
   * @type {ol.Extent}
   */
  this.tmpExtent = _extent2.default.createEmpty();

  /**
   * @private
   * @type {ol.TileRange}
   */
  this.tmpTileRange_ = new _tilerange2.default(0, 0, 0, 0);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.imageTransform_ = _transform2.default.create();

  /**
   * @protected
   * @type {number}
   */
  this.zDirection = 0;
}; // FIXME find correct globalCompositeOperation

_index2.default.inherits(_ol_renderer_canvas_TileLayer_, _intermediatecanvas2.default);

/**
 * @private
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Tile is drawable.
 */
_ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function (tile) {
  var tileState = tile.getState();
  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
  return tileState == _tilestate2.default.LOADED || tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError;
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var this$1 = this;


  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var viewResolution = viewState.resolution;
  var viewCenter = viewState.center;

  var tileLayer = this.getLayer();
  var tileSource = /** @type {ol.source.Tile} */tileLayer.getSource();
  var sourceRevision = tileSource.getRevision();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
  var tileResolution = tileGrid.getResolution(z);
  var oversampling = Math.round(viewResolution / tileResolution) || 1;
  var extent = frameState.extent;

  if (layerState.extent !== undefined) {
    extent = _extent2.default.getIntersection(extent, layerState.extent);
  }
  if (_extent2.default.isEmpty(extent)) {
    // Return false to prevent the rendering of the layer.
    return false;
  }

  var tileRange = tileGrid.getTileRangeForExtentAndResolution(extent, tileResolution);
  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

  /**
   * @type {Object.<number, Object.<string, ol.Tile>>}
   */
  var tilesToDrawByZ = {};
  tilesToDrawByZ[z] = {};

  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);

  var tmpExtent = this.tmpExtent;
  var tmpTileRange = this.tmpTileRange_;
  var newTiles = false;
  var tile, x, y;
  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tile = tileSource.getTile(z, x, y, pixelRatio, projection);
      if (!this$1.isDrawableTile_(tile)) {
        tile = tile.getInterimTile();
      }
      if (this$1.isDrawableTile_(tile)) {
        if (tile.getState() == _tilestate2.default.LOADED) {
          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
          if (!newTiles && this$1.renderedTiles.indexOf(tile) == -1) {
            newTiles = true;
          }
        }
        continue;
      }

      var fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
      if (!fullyLoaded) {
        var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
        if (childTileRange) {
          findLoadedTiles(z + 1, childTileRange);
        }
      }
    }
  }

  var hints = frameState.viewHints;
  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && (hints[_viewhint2.default.ANIMATING] || hints[_viewhint2.default.INTERACTING])) && (newTiles || !(this.renderedExtent_ && _extent2.default.containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision) || oversampling != this.oversampling_) {

    var context = this.context;
    if (context) {
      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
      var canvas = context.canvas;
      if (canvas.width != width || canvas.height != height) {
        this.oversampling_ = oversampling;
        canvas.width = width;
        canvas.height = height;
      } else {
        context.clearRect(0, 0, width, height);
        oversampling = this.oversampling_;
      }
    }

    this.renderedTiles.length = 0;
    /** @type {Array.<number>} */
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(_array2.default.numberSafeCompareFunction);
    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
    var tileExtent, tileGutter, tilesToDraw, w, h;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      currentZ = zs[i];
      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      currentResolution = tileGrid.getResolution(currentZ);
      currentScale = currentResolution / tileResolution;
      tileGutter = tilePixelRatio * tileSource.getGutter(projection);
      tilesToDraw = tilesToDrawByZ[currentZ];
      for (var tileCoordKey in tilesToDraw) {
        tile = tilesToDraw[tileCoordKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
        w = currentTilePixelSize[0] * currentScale / oversampling;
        h = currentTilePixelSize[1] * currentScale / oversampling;
        this$1.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter);
        this$1.renderedTiles.push(tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    this.renderedExtent_ = imageExtent;
  }

  var scale = this.renderedResolution / viewResolution;
  var transform = _transform2.default.compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
  _transform2.default.compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);

  return this.renderedTiles.length > 0;
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} x Left of the tile.
 * @param {number} y Top of the tile.
 * @param {number} w Width of the tile.
 * @param {number} h Height of the tile.
 * @param {number} gutter Tile gutter.
 */
_ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter) {
  if (!this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
    this.context.clearRect(x, y, w, h);
  }
  var image = tile.getImage();
  if (image) {
    this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
  }
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_TileLayer_.prototype.getImage = function () {
  var context = this.context;
  return context ? context.canvas : null;
};

/**
 * @function
 * @return {ol.layer.Tile|ol.layer.VectorTile}
 */
_ol_renderer_canvas_TileLayer_.prototype.getLayer;

/**
 * @inheritDoc
 */
_ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};
exports.default = _ol_renderer_canvas_TileLayer_;


},{"../../array":42,"../../dom":60,"../../extent":68,"../../index":110,"../../tilerange":251,"../../tilestate":252,"../../transform":254,"../../viewhint":258,"../canvas/intermediatecanvas":196}],200:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _eventtype = require('../../render/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _canvas = require('../../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _replaygroup = require('../../render/canvas/replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _layer = require('../canvas/layer');

var _layer2 = _interopRequireDefault(_layer);

var _vector = require('../vector');

var _vector2 = _interopRequireDefault(_vector);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 */
var _ol_renderer_canvas_VectorLayer_ = function (vectorLayer) {

  _layer2.default.call(this, vectorLayer);

  /**
   * @private
   * @type {boolean}
   */
  this.dirty_ = false;

  /**
   * @private
   * @type {number}
   */
  this.renderedRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.renderedResolution_ = NaN;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedExtent_ = _extent2.default.createEmpty();

  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */
  this.renderedRenderOrder_ = null;

  /**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */
  this.replayGroup_ = null;

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = _dom2.default.createCanvasContext2D();
};

_index2.default.inherits(_ol_renderer_canvas_VectorLayer_, _layer2.default);

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  var this$1 = this;


  var extent = frameState.extent;
  var pixelRatio = frameState.pixelRatio;
  var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var rotation = viewState.rotation;
  var projectionExtent = projection.getExtent();
  var vectorSource = /** @type {ol.source.Vector} */this.getLayer().getSource();

  var transform = this.getTransform(frameState, 0);

  this.preCompose(context, frameState, transform);

  // clipped rendering if layer extent is set
  var clipExtent = layerState.extent;
  var clipped = clipExtent !== undefined;
  if (clipped) {
    this.clip(context, frameState, /** @type {ol.Extent} */clipExtent);
  }
  var replayGroup = this.replayGroup_;
  if (replayGroup && !replayGroup.isEmpty()) {
    var layer = this.getLayer();
    var drawOffsetX = 0;
    var drawOffsetY = 0;
    var replayContext;
    if (layer.hasListener(_eventtype2.default.RENDER)) {
      var drawWidth = context.canvas.width;
      var drawHeight = context.canvas.height;
      if (rotation) {
        var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
        drawOffsetX = (drawSize - drawWidth) / 2;
        drawOffsetY = (drawSize - drawHeight) / 2;
        drawWidth = drawHeight = drawSize;
      }
      // resize and clear
      this.context_.canvas.width = drawWidth;
      this.context_.canvas.height = drawHeight;
      replayContext = this.context_;
    } else {
      replayContext = context;
    }
    // for performance reasons, context.save / context.restore is not used
    // to save and restore the transformation matrix and the opacity.
    // see http://jsperf.com/context-save-restore-versus-variable
    var alpha = replayContext.globalAlpha;
    replayContext.globalAlpha = layerState.opacity;
    if (replayContext != context) {
      replayContext.translate(drawOffsetX, drawOffsetY);
    }

    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    _canvas2.default.rotateAtOffset(replayContext, -rotation, width / 2, height / 2);
    replayGroup.replay(replayContext, pixelRatio, transform, rotation, skippedFeatureUids);
    if (vectorSource.getWrapX() && projection.canWrapX() && !_extent2.default.containsExtent(projectionExtent, extent)) {
      var startX = extent[0];
      var worldWidth = _extent2.default.getWidth(projectionExtent);
      var world = 0;
      var offsetX;
      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        transform = this$1.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, pixelRatio, transform, rotation, skippedFeatureUids);
        startX += worldWidth;
      }
      world = 0;
      startX = extent[2];
      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        transform = this$1.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, pixelRatio, transform, rotation, skippedFeatureUids);
        startX -= worldWidth;
      }
      // restore original transform for render and compose events
      transform = this.getTransform(frameState, 0);
    }
    _canvas2.default.rotateAtOffset(replayContext, rotation, width / 2, height / 2);

    if (replayContext != context) {
      this.dispatchRenderEvent(replayContext, frameState, transform);
      context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
      replayContext.translate(-drawOffsetX, -drawOffsetY);
    }
    replayContext.globalAlpha = alpha;
  }

  if (clipped) {
    context.restore();
  }
  this.postCompose(context, frameState, layerState, transform);
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = this.getLayer();
    /** @type {Object.<string, boolean>} */
    var features = {};
    return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index2.default.getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
};

/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */
_ol_renderer_canvas_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorLayer_.prototype.prepareFrame = function (frameState, layerState) {

  var vectorLayer = /** @type {ol.layer.Vector} */this.getLayer();
  var vectorSource = vectorLayer.getSource();

  this.updateAttributions(frameState.attributions, vectorSource.getAttributions());
  this.updateLogos(frameState, vectorSource);

  var animating = frameState.viewHints[_viewhint2.default.ANIMATING];
  var interacting = frameState.viewHints[_viewhint2.default.INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = _vector2.default.defaultOrder;
  }

  var extent = _extent2.default.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
  var projectionExtent = viewState.projection.getExtent();

  if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !_extent2.default.containsExtent(projectionExtent, frameState.extent)) {
    // For the replay group, we need an extent that intersects the real world
    // (-180 to +180). To support geometries in a coordinate range from -540
    // to +540, we add at least 1 world width on each side of the projection
    // extent. If the viewport is wider than the world, we need to add half of
    // the viewport width to make sure we cover the whole viewport.
    var worldWidth = _extent2.default.getWidth(projectionExtent);
    var buffer = Math.max(_extent2.default.getWidth(extent) / 2, worldWidth);
    extent[0] = projectionExtent[0] - buffer;
    extent[2] = projectionExtent[2] + buffer;
  }

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent2.default.containsExtent(this.renderedExtent_, extent)) {
    return true;
  }

  this.replayGroup_ = null;

  this.dirty_ = false;

  var replayGroup = new _replaygroup2.default(_vector2.default.getTolerance(resolution, pixelRatio), extent, resolution, vectorSource.getOverlaps(), vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorLayer}
   */
  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  };
  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    features.forEach(renderFeature, this);
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }
  replayGroup.finish();

  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;

  return true;
};

/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */
_ol_renderer_canvas_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  var this$1 = this;

  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], _vector2.default.getSquaredTolerance(resolution, pixelRatio), this$1.handleStyleImageChange_, this$1) || loading;
    }
  } else {
    loading = _vector2.default.renderFeature(replayGroup, feature, styles, _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
  }
  return loading;
};
exports.default = _ol_renderer_canvas_VectorLayer_;


},{"../../dom":60,"../../extent":68,"../../index":110,"../../render/canvas":167,"../../render/canvas/replaygroup":174,"../../render/eventtype":177,"../../viewhint":258,"../canvas/layer":197,"../vector":205}],201:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _proj = require('../../proj');

var _proj2 = _interopRequireDefault(_proj);

var _units = require('../../proj/units');

var _units2 = _interopRequireDefault(_units);

var _vectortilerendertype = require('../../layer/vectortilerendertype');

var _vectortilerendertype2 = _interopRequireDefault(_vectortilerendertype);

var _replaytype = require('../../render/replaytype');

var _replaytype2 = _interopRequireDefault(_replaytype);

var _canvas = require('../../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _replaygroup = require('../../render/canvas/replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _replay = require('../../render/replay');

var _replay2 = _interopRequireDefault(_replay);

var _tilelayer = require('../canvas/tilelayer');

var _tilelayer2 = _interopRequireDefault(_tilelayer);

var _vector = require('../vector');

var _vector2 = _interopRequireDefault(_vector);

var _size = require('../../size');

var _size2 = _interopRequireDefault(_size);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.renderer.canvas.TileLayer}
 * @param {ol.layer.VectorTile} layer VectorTile layer.
 */
var _ol_renderer_canvas_VectorTileLayer_ = function (layer) {

  this.context = null;

  _tilelayer2.default.call(this, layer);

  /**
   * @private
   * @type {boolean}
   */
  this.dirty_ = false;

  /**
   * @private
   * @type {number}
   */
  this.renderedLayerRevision_;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.tmpTransform_ = _transform2.default.create();

  // Use lower resolution for pure vector rendering. Closest resolution otherwise.
  this.zDirection = layer.getRenderMode() == _vectortilerendertype2.default.VECTOR ? 1 : 0;
};

_index2.default.inherits(_ol_renderer_canvas_VectorTileLayer_, _tilelayer2.default);

/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */
_ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS = {
  'image': _replay2.default.ORDER,
  'hybrid': [_replaytype2.default.POLYGON, _replaytype2.default.LINE_STRING]
};

/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */
_ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS = {
  'hybrid': [_replaytype2.default.IMAGE, _replaytype2.default.TEXT],
  'vector': _replay2.default.ORDER
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var layer = this.getLayer();
  var layerRevision = layer.getRevision();
  if (this.renderedLayerRevision_ != layerRevision) {
    this.renderedTiles.length = 0;
    var renderMode = layer.getRenderMode();
    if (!this.context && renderMode != _vectortilerendertype2.default.VECTOR) {
      this.context = _dom2.default.createCanvasContext2D();
    }
    if (this.context && renderMode == _vectortilerendertype2.default.VECTOR) {
      this.context = null;
    }
  }
  this.renderedLayerRevision_ = layerRevision;
  return _tilelayer2.default.prototype.prepareFrame.apply(this, arguments);
};

/**
 * @param {ol.VectorTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.createReplayGroup_ = function (tile, frameState) {
  var this$1 = this;

  var layer = this.getLayer();
  var pixelRatio = frameState.pixelRatio;
  var projection = frameState.viewState.projection;
  var revision = layer.getRevision();
  var renderOrder = layer.getRenderOrder() || null;

  var replayState = tile.getReplayState();
  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {
    return;
  }

  replayState.replayGroup = null;
  replayState.dirty = false;

  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var tileGrid = source.getTileGrid();
  var tileCoord = tile.tileCoord;
  var tileProjection = tile.getProjection();
  var resolution = tileGrid.getResolution(tileCoord[0]);
  var extent, reproject, tileResolution;
  if (tileProjection.getUnits() == _units2.default.TILE_PIXELS) {
    var tilePixelRatio = tileResolution = source.getTilePixelRatio();
    var tileSize = _size2.default.toSize(tileGrid.getTileSize(tileCoord[0]));
    extent = [0, 0, tileSize[0] * tilePixelRatio, tileSize[1] * tilePixelRatio];
  } else {
    tileResolution = resolution;
    extent = tileGrid.getTileCoordExtent(tileCoord);
    if (!_proj2.default.equivalent(projection, tileProjection)) {
      reproject = true;
      tile.setProjection(projection);
    }
  }
  replayState.dirty = false;
  var replayGroup = new _replaygroup2.default(0, extent, tileResolution, source.getOverlaps(), layer.getRenderBuffer());
  var squaredTolerance = _vector2.default.getSquaredTolerance(tileResolution, pixelRatio);

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorTileLayer}
   */
  function renderFeature(feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call( /** @type {ol.Feature} */feature, resolution);
    } else {
      styleFunction = layer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      if (!Array.isArray(styles)) {
        styles = [styles];
      }
      var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
      replayState.dirty = replayState.dirty || dirty;
    }
  }

  var features = tile.getFeatures();
  if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
    features.sort(renderOrder);
  }
  var feature;
  for (var i = 0, ii = features.length; i < ii; ++i) {
    feature = features[i];
    if (reproject) {
      feature.getGeometry().transform(tileProjection, projection);
    }
    renderFeature.call(this$1, feature);
  }

  replayGroup.finish();

  replayState.renderedRevision = revision;
  replayState.renderedRenderOrder = renderOrder;
  replayState.replayGroup = replayGroup;
  replayState.resolution = NaN;
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter) {
  var vectorTile = /** @type {ol.VectorTile} */tile;
  this.createReplayGroup_(vectorTile, frameState);
  if (this.context) {
    this.renderTileImage_(vectorTile, frameState, layerState);
    _tilelayer2.default.prototype.drawTileImage.apply(this, arguments);
  }
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var this$1 = this;

  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
  var layer = this.getLayer();
  /** @type {Object.<string, boolean>} */
  var features = {};

  /** @type {Array.<ol.VectorTile>} */
  var replayables = this.renderedTiles;

  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var tileGrid = source.getTileGrid();
  var found, tileSpaceCoordinate;
  var i, ii, origin, replayGroup;
  var tile, tileCoord, tileExtent, tilePixelRatio, tileResolution;
  for (i = 0, ii = replayables.length; i < ii; ++i) {
    tile = replayables[i];
    tileCoord = tile.tileCoord;
    tileExtent = source.getTileGrid().getTileCoordExtent(tileCoord, this$1.tmpExtent);
    if (!_extent2.default.containsCoordinate(_extent2.default.buffer(tileExtent, hitTolerance * resolution), coordinate)) {
      continue;
    }
    if (tile.getProjection().getUnits() === _units2.default.TILE_PIXELS) {
      origin = _extent2.default.getTopLeft(tileExtent);
      tilePixelRatio = source.getTilePixelRatio();
      tileResolution = tileGrid.getResolution(tileCoord[0]) / tilePixelRatio;
      tileSpaceCoordinate = [(coordinate[0] - origin[0]) / tileResolution, (origin[1] - coordinate[1]) / tileResolution];
      resolution = tilePixelRatio;
    } else {
      tileSpaceCoordinate = coordinate;
    }
    replayGroup = tile.getReplayState().replayGroup;
    found = found || replayGroup.forEachFeatureAtCoordinate(tileSpaceCoordinate, resolution, rotation, hitTolerance, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = _index2.default.getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
  return found;
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @return {ol.Transform} transform Transform.
 * @private
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.getReplayTransform_ = function (tile, frameState) {
  if (tile.getProjection().getUnits() == _units2.default.TILE_PIXELS) {
    var layer = this.getLayer();
    var source = /** @type {ol.source.VectorTile} */layer.getSource();
    var tileGrid = source.getTileGrid();
    var tileCoord = tile.tileCoord;
    var tileResolution = tileGrid.getResolution(tileCoord[0]) / source.getTilePixelRatio();
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;
    var renderResolution = viewState.resolution / pixelRatio;
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    var center = viewState.center;
    var origin = _extent2.default.getTopLeft(tileExtent);
    var size = frameState.size;
    var offsetX = Math.round(pixelRatio * size[0] / 2);
    var offsetY = Math.round(pixelRatio * size[1] / 2);
    return _transform2.default.compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);
  } else {
    return this.getTransform(frameState, 0);
  }
};

/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};

/**
 * @inheritDoc
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.postCompose = function (context, frameState, layerState) {
  var this$1 = this;

  var renderMode = this.getLayer().getRenderMode();
  var replays = _ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS[renderMode];
  if (replays) {
    var pixelRatio = frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;
    var size = frameState.size;
    var offsetX = Math.round(pixelRatio * size[0] / 2);
    var offsetY = Math.round(pixelRatio * size[1] / 2);
    var tiles = this.renderedTiles;
    var clips = [];
    var zs = [];
    for (var i = tiles.length - 1; i >= 0; --i) {
      var tile = /** @type {ol.VectorTile} */tiles[i];
      // Create a clip mask for regions in this low resolution tile that are
      // already filled by a higher resolution tile
      var transform = this$1.getReplayTransform_(tile, frameState);
      var currentClip = tile.getReplayState().replayGroup.getClipCoords(transform);
      var currentZ = tile.tileCoord[0];
      context.save();
      context.globalAlpha = layerState.opacity;
      _canvas2.default.rotateAtOffset(context, -rotation, offsetX, offsetY);
      for (var j = 0, jj = clips.length; j < jj; ++j) {
        var clip = clips[j];
        if (currentZ < zs[j]) {
          context.beginPath();
          // counter-clockwise (outer ring) for current tile
          context.moveTo(currentClip[0], currentClip[1]);
          context.lineTo(currentClip[2], currentClip[3]);
          context.lineTo(currentClip[4], currentClip[5]);
          context.lineTo(currentClip[6], currentClip[7]);
          // clockwise (inner ring) for higher resolution tile
          context.moveTo(clip[6], clip[7]);
          context.lineTo(clip[4], clip[5]);
          context.lineTo(clip[2], clip[3]);
          context.lineTo(clip[0], clip[1]);
          context.clip();
        }
      }
      var replayGroup = tile.getReplayState().replayGroup;
      replayGroup.replay(context, pixelRatio, transform, rotation, {}, replays);
      context.restore();
      clips.push(currentClip);
      zs.push(currentZ);
    }
  }
  _tilelayer2.default.prototype.postCompose.apply(this, arguments);
};

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.renderFeature = function (feature, squaredTolerance, styles, replayGroup) {
  var this$1 = this;

  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], squaredTolerance, this$1.handleStyleImageChange_, this$1) || loading;
    }
  } else {
    loading = _vector2.default.renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this) || loading;
  }
  return loading;
};

/**
 * @param {ol.VectorTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @private
 */
_ol_renderer_canvas_VectorTileLayer_.prototype.renderTileImage_ = function (tile, frameState, layerState) {
  var layer = this.getLayer();
  var replayState = tile.getReplayState();
  var revision = layer.getRevision();
  var replays = _ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS[layer.getRenderMode()];
  if (replays && replayState.renderedTileRevision !== revision) {
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.tileCoord;
    var z = tile.tileCoord[0];
    var pixelRatio = frameState.pixelRatio;
    var source = layer.getSource();
    var tileGrid = source.getTileGrid();
    var tilePixelRatio = source.getTilePixelRatio();
    var transform = _transform2.default.reset(this.tmpTransform_);
    if (tile.getProjection().getUnits() == _units2.default.TILE_PIXELS) {
      var renderPixelRatio = pixelRatio / tilePixelRatio;
      _transform2.default.scale(transform, renderPixelRatio, renderPixelRatio);
    } else {
      var resolution = tileGrid.getResolution(z);
      var pixelScale = pixelRatio / resolution;
      var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
      _transform2.default.scale(transform, pixelScale, -pixelScale);
      _transform2.default.translate(transform, -tileExtent[0], -tileExtent[3]);
    }

    var context = tile.getContext();
    var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    replayState.replayGroup.replay(context, pixelRatio, transform, 0, {}, replays);
  }
};
exports.default = _ol_renderer_canvas_VectorTileLayer_;


},{"../../dom":60,"../../extent":68,"../../index":110,"../../layer/vectortilerendertype":134,"../../proj":158,"../../proj/units":165,"../../render/canvas":167,"../../render/canvas/replaygroup":174,"../../render/replay":179,"../../render/replaytype":181,"../../size":217,"../../transform":254,"../canvas/tilelayer":199,"../vector":205}],202:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _observable = require('../observable');

var _observable2 = _interopRequireDefault(_observable);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.Observable}
 * @param {ol.layer.Layer} layer Layer.
 * @struct
 */
var _ol_renderer_Layer_ = function (layer) {

  _observable2.default.call(this);

  /**
   * @private
   * @type {ol.layer.Layer}
   */
  this.layer_ = layer;
};

_index2.default.inherits(_ol_renderer_Layer_, _observable2.default);

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */
_ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = _index2.default.nullFunction;

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */
_ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = _functions2.default.FALSE;

/**
 * Create a function that adds loaded tiles to the tile lookup.
 * @param {ol.source.Tile} source Tile source.
 * @param {ol.proj.Projection} projection Projection of the tiles.
 * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded
 *     tiles by zoom level.
 * @return {function(number, ol.TileRange):boolean} A function that can be
 *     called with a zoom level and a tile range to add loaded tiles to the
 *     lookup.
 * @protected
 */
_ol_renderer_Layer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile.tileCoord.toString()] = tile;
      }
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};

/**
 * @return {ol.layer.Layer} Layer.
 */
_ol_renderer_Layer_.prototype.getLayer = function () {
  return this.layer_;
};

/**
 * Handle changes in image state.
 * @param {ol.events.Event} event Image change event.
 * @private
 */
_ol_renderer_Layer_.prototype.handleImageChange_ = function (event) {
  var image = /** @type {ol.Image} */event.target;
  if (image.getState() === _imagestate2.default.LOADED) {
    this.renderIfReadyAndVisible();
  }
};

/**
 * Load the image if not already loaded, and register the image change
 * listener if needed.
 * @param {ol.ImageBase} image Image.
 * @return {boolean} `true` if the image is already loaded, `false`
 *     otherwise.
 * @protected
 */
_ol_renderer_Layer_.prototype.loadImage = function (image) {
  var imageState = image.getState();
  if (imageState != _imagestate2.default.LOADED && imageState != _imagestate2.default.ERROR) {
    _events2.default.listen(image, _eventtype2.default.CHANGE, this.handleImageChange_, this);
  }
  if (imageState == _imagestate2.default.IDLE) {
    image.load();
    imageState = image.getState();
  }
  return imageState == _imagestate2.default.LOADED;
};

/**
 * @protected
 */
_ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function () {
  var layer = this.getLayer();
  if (layer.getVisible() && layer.getSourceState() == _state2.default.READY) {
    this.changed();
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @protected
 */
_ol_renderer_Layer_.prototype.scheduleExpireCache = function (frameState, tileSource) {
  if (tileSource.canExpireCache()) {
    /**
     * @param {ol.source.Tile} tileSource Tile source.
     * @param {ol.Map} map Map.
     * @param {olx.FrameState} frameState Frame state.
     */
    var postRenderFunction = function (tileSource, map, frameState) {
      var tileSourceKey = _index2.default.getUid(tileSource).toString();
      tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
    }.bind(null, tileSource);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */postRenderFunction);
  }
};

/**
 * @param {Object.<string, ol.Attribution>} attributionsSet Attributions
 *     set (target).
 * @param {Array.<ol.Attribution>} attributions Attributions (source).
 * @protected
 */
_ol_renderer_Layer_.prototype.updateAttributions = function (attributionsSet, attributions) {
  if (attributions) {
    var attribution, i, ii;
    for (i = 0, ii = attributions.length; i < ii; ++i) {
      attribution = attributions[i];
      attributionsSet[_index2.default.getUid(attribution).toString()] = attribution;
    }
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Source} source Source.
 * @protected
 */
_ol_renderer_Layer_.prototype.updateLogos = function (frameState, source) {
  var logo = source.getLogo();
  if (logo !== undefined) {
    if (typeof logo === 'string') {
      frameState.logos[logo] = '';
    } else if (logo) {
      _asserts2.default.assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.
      _asserts2.default.assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.
      frameState.logos[logo.src] = logo.href;
    }
  }
};

/**
 * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @protected
 */
_ol_renderer_Layer_.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {
  // FIXME should we use tilesToDrawByZ instead?
  var tileSourceKey = _index2.default.getUid(tileSource).toString();
  var zKey = z.toString();
  if (tileSourceKey in usedTiles) {
    if (zKey in usedTiles[tileSourceKey]) {
      usedTiles[tileSourceKey][zKey].extend(tileRange);
    } else {
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  } else {
    usedTiles[tileSourceKey] = {};
    usedTiles[tileSourceKey][zKey] = tileRange;
  }
};

/**
 * Manage tile pyramid.
 * This function performs a number of functions related to the tiles at the
 * current zoom and lower zoom levels:
 * - registers idle tiles in frameState.wantedTiles so that they are not
 *   discarded by the tile queue
 * - enqueues missing tiles
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {ol.Extent} extent Extent.
 * @param {number} currentZ Current Z.
 * @param {number} preload Load low resolution tiles up to 'preload' levels.
 * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.
 * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
 * @protected
 * @template T
 */
_ol_renderer_Layer_.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {
  var tileSourceKey = _index2.default.getUid(tileSource).toString();
  if (!(tileSourceKey in frameState.wantedTiles)) {
    frameState.wantedTiles[tileSourceKey] = {};
  }
  var wantedTiles = frameState.wantedTiles[tileSourceKey];
  var tileQueue = frameState.tileQueue;
  var minZoom = tileGrid.getMinZoom();
  var tile, tileRange, tileResolution, x, y, z;
  for (z = currentZ; z >= minZoom; --z) {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
    tileResolution = tileGrid.getResolution(z);
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (currentZ - z <= preload) {
          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (tile.getState() == _tilestate2.default.IDLE) {
            wantedTiles[tile.getKey()] = true;
            if (!tileQueue.isKeyQueued(tile.getKey())) {
              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
            }
          }
          if (opt_tileCallback !== undefined) {
            opt_tileCallback.call(opt_this, tile);
          }
        } else {
          tileSource.useTile(z, x, y, projection);
        }
      }
    }
  }
};
exports.default = _ol_renderer_Layer_;


},{"../asserts":44,"../events":62,"../events/eventtype":66,"../functions":78,"../imagestate":108,"../index":110,"../observable":149,"../source/state":219,"../tilestate":252}],203:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _disposable = require('../disposable');

var _disposable2 = _interopRequireDefault(_disposable);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _layer = require('../layer/layer');

var _layer2 = _interopRequireDefault(_layer);

var _style = require('../style');

var _style2 = _interopRequireDefault(_style);

var _transform = require('../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @abstract
 * @extends {ol.Disposable}
 * @param {Element} container Container.
 * @param {ol.Map} map Map.
 * @struct
 */
var _ol_renderer_Map_ = function (container, map) {

  _disposable2.default.call(this);

  /**
   * @private
   * @type {ol.Map}
   */
  this.map_ = map;

  /**
   * @private
   * @type {Object.<string, ol.renderer.Layer>}
   */
  this.layerRenderers_ = {};

  /**
   * @private
   * @type {Object.<string, ol.EventsKey>}
   */
  this.layerRendererListeners_ = {};
};

_index2.default.inherits(_ol_renderer_Map_, _disposable2.default);

/**
 * @param {olx.FrameState} frameState FrameState.
 * @protected
 */
_ol_renderer_Map_.prototype.calculateMatrices2D = function (frameState) {
  var viewState = frameState.viewState;
  var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
  var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

  _transform2.default.compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);

  _transform2.default.invert(_transform2.default.setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
};

/**
 * @inheritDoc
 */
_ol_renderer_Map_.prototype.disposeInternal = function () {
  var this$1 = this;

  for (var id in this$1.layerRenderers_) {
    this$1.layerRenderers_[id].dispose();
  }
};

/**
 * @param {ol.Map} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
_ol_renderer_Map_.expireIconCache_ = function (map, frameState) {
  var cache = _style2.default.iconImageCache;
  cache.expire();
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
_ol_renderer_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var this$1 = this;

  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {ol.layer.Layer} layer Layer.
   * @return {?} Callback result.
   */
  function forEachFeatureAtCoordinate(feature, layer) {
    var key = _index2.default.getUid(feature).toString();
    var managed = frameState.layerStates[_index2.default.getUid(layer)].managed;
    if (!(key in frameState.skippedFeatureUids && !managed)) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }
  }

  var projection = viewState.projection;

  var translatedCoordinate = coordinate;
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();
    var worldWidth = _extent2.default.getWidth(projectionExtent);
    var x = coordinate[0];
    if (x < projectionExtent[0] || x > projectionExtent[2]) {
      var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
    }
  }

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this$1.getLayerRenderer(layer);
      if (layer.getSource()) {
        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
      }
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};

/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
_ol_renderer_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
 * @return {boolean} Is there a feature at the given coordinate?
 * @template U
 */
_ol_renderer_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, _functions2.default.TRUE, this, layerFilter, thisArg);

  return hasFeature !== undefined;
};

/**
 * @param {ol.layer.Layer} layer Layer.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */
_ol_renderer_Map_.prototype.getLayerRenderer = function (layer) {
  var layerKey = _index2.default.getUid(layer).toString();
  if (layerKey in this.layerRenderers_) {
    return this.layerRenderers_[layerKey];
  } else {
    var layerRenderer = layer.createRenderer(this);
    this.layerRenderers_[layerKey] = layerRenderer;
    this.layerRendererListeners_[layerKey] = _events2.default.listen(layerRenderer, _eventtype2.default.CHANGE, this.handleLayerRendererChange_, this);

    return layerRenderer;
  }
};

/**
 * @param {string} layerKey Layer key.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */
_ol_renderer_Map_.prototype.getLayerRendererByKey = function (layerKey) {
  return this.layerRenderers_[layerKey];
};

/**
 * @protected
 * @return {Object.<string, ol.renderer.Layer>} Layer renderers.
 */
_ol_renderer_Map_.prototype.getLayerRenderers = function () {
  return this.layerRenderers_;
};

/**
 * @return {ol.Map} Map.
 */
_ol_renderer_Map_.prototype.getMap = function () {
  return this.map_;
};

/**
 * @abstract
 * @return {string} Type
 */
_ol_renderer_Map_.prototype.getType = function () {};

/**
 * Handle changes in a layer renderer.
 * @private
 */
_ol_renderer_Map_.prototype.handleLayerRendererChange_ = function () {
  this.map_.render();
};

/**
 * @param {string} layerKey Layer key.
 * @return {ol.renderer.Layer} Layer renderer.
 * @private
 */
_ol_renderer_Map_.prototype.removeLayerRendererByKey_ = function (layerKey) {
  var layerRenderer = this.layerRenderers_[layerKey];
  delete this.layerRenderers_[layerKey];

  _events2.default.unlistenByKey(this.layerRendererListeners_[layerKey]);
  delete this.layerRendererListeners_[layerKey];

  return layerRenderer;
};

/**
 * Render.
 * @param {?olx.FrameState} frameState Frame state.
 */
_ol_renderer_Map_.prototype.renderFrame = _index2.default.nullFunction;

/**
 * @param {ol.Map} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
_ol_renderer_Map_.prototype.removeUnusedLayerRenderers_ = function (map, frameState) {
  var this$1 = this;

  var layerKey;
  for (layerKey in this$1.layerRenderers_) {
    if (!frameState || !(layerKey in frameState.layerStates)) {
      this$1.removeLayerRendererByKey_(layerKey).dispose();
    }
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 */
_ol_renderer_Map_.prototype.scheduleExpireIconCache = function (frameState) {
  frameState.postRenderFunctions.push(
  /** @type {ol.PostRenderFunction} */_ol_renderer_Map_.expireIconCache_);
};

/**
 * @param {!olx.FrameState} frameState Frame state.
 * @protected
 */
_ol_renderer_Map_.prototype.scheduleRemoveUnusedLayerRenderers = function (frameState) {
  var this$1 = this;

  var layerKey;
  for (layerKey in this$1.layerRenderers_) {
    if (!(layerKey in frameState.layerStates)) {
      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */this$1.removeUnusedLayerRenderers_.bind(this$1));
      return;
    }
  }
};

/**
 * @param {ol.LayerState} state1 First layer state.
 * @param {ol.LayerState} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
_ol_renderer_Map_.sortByZIndex = function (state1, state2) {
  return state1.zIndex - state2.zIndex;
};
exports.default = _ol_renderer_Map_;


},{"../disposable":59,"../events":62,"../events/eventtype":66,"../extent":68,"../functions":78,"../index":110,"../layer/layer":128,"../style":237,"../transform":254}],204:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Available renderers: `'canvas'` or `'webgl'`.
 * @enum {string}
 */
var _ol_renderer_Type_ = {
  CANVAS: 'canvas',
  WEBGL: 'webgl'
};

exports.default = _ol_renderer_Type_;


},{}],205:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _replaytype = require('../render/replaytype');

var _replaytype2 = _interopRequireDefault(_replaytype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_renderer_vector_ = {};

/**
 * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.
 * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.
 * @return {number} Order.
 */
_ol_renderer_vector_.defaultOrder = function (feature1, feature2) {
  return _index2.default.getUid(feature1) - _index2.default.getUid(feature2);
};

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
_ol_renderer_vector_.getSquaredTolerance = function (resolution, pixelRatio) {
  var tolerance = _ol_renderer_vector_.getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
};

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
_ol_renderer_vector_.getTolerance = function (resolution, pixelRatio) {
  return _index2.default.SIMPLIFY_TOLERANCE * resolution / pixelRatio;
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Circle} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderCircleGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getCenter(), 0, 2, 2, geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */
_ol_renderer_vector_.renderFeature = function (replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle, imageState;
  imageStyle = style.getImage();
  if (imageStyle) {
    imageState = imageStyle.getImageState();
    if (imageState == _imagestate2.default.LOADED || imageState == _imagestate2.default.ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == _imagestate2.default.IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  _ol_renderer_vector_.renderFeature_(replayGroup, feature, style, squaredTolerance);
  return loading;
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @private
 */
_ol_renderer_vector_.renderFeature_ = function (replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];
  geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderGeometryCollectionGeometry_ = function (replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getFlatMidpoint(), 0, 2, 2, geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    var flatMidpointCoordinates = geometry.getFlatMidpoints();
    textReplay.drawText(flatMidpointCoordinates, 0, flatMidpointCoordinates.length, 2, geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    var flatInteriorPointCoordinates = geometry.getFlatInteriorPoints();
    textReplay.drawText(flatInteriorPointCoordinates, 0, flatInteriorPointCoordinates.length, 2, geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate2.default.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.IMAGE);
    imageReplay.setImageStyle(imageStyle);
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getFlatCoordinates(), 0, 2, 2, geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != _imagestate2.default.LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.IMAGE);
    imageReplay.setImageStyle(imageStyle);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    var flatCoordinates = geometry.getFlatCoordinates();
    textReplay.drawText(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), _replaytype2.default.TEXT);
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry.getFlatInteriorPoint(), 0, 2, 2, geometry, feature);
  }
};

/**
 * @const
 * @private
 * @type {Object.<ol.geom.GeometryType,
 *                function(ol.render.ReplayGroup, ol.geom.Geometry,
 *                         ol.style.Style, Object)>}
 */
_ol_renderer_vector_.GEOMETRY_RENDERERS_ = {
  'Point': _ol_renderer_vector_.renderPointGeometry_,
  'LineString': _ol_renderer_vector_.renderLineStringGeometry_,
  'Polygon': _ol_renderer_vector_.renderPolygonGeometry_,
  'MultiPoint': _ol_renderer_vector_.renderMultiPointGeometry_,
  'MultiLineString': _ol_renderer_vector_.renderMultiLineStringGeometry_,
  'MultiPolygon': _ol_renderer_vector_.renderMultiPolygonGeometry_,
  'GeometryCollection': _ol_renderer_vector_.renderGeometryCollectionGeometry_,
  'Circle': _ol_renderer_vector_.renderCircleGeometry_
};
exports.default = _ol_renderer_vector_;


},{"../imagestate":108,"../index":110,"../render/replaytype":181}],206:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_renderer_webgl_defaultmapshader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_renderer_webgl_defaultmapshader_.Fragment = function () {
    _fragment2.default.call(this, _ol_renderer_webgl_defaultmapshader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_renderer_webgl_defaultmapshader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_renderer_webgl_defaultmapshader_.Fragment.DEBUG_SOURCE : _ol_renderer_webgl_defaultmapshader_.Fragment.OPTIMIZED_SOURCE;

  _ol_renderer_webgl_defaultmapshader_.fragment = new _ol_renderer_webgl_defaultmapshader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_renderer_webgl_defaultmapshader_.Vertex = function () {
    _vertex2.default.call(this, _ol_renderer_webgl_defaultmapshader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_renderer_webgl_defaultmapshader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Vertex.DEBUG_SOURCE = 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Vertex.OPTIMIZED_SOURCE = 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_defaultmapshader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_renderer_webgl_defaultmapshader_.Vertex.DEBUG_SOURCE : _ol_renderer_webgl_defaultmapshader_.Vertex.OPTIMIZED_SOURCE;

  _ol_renderer_webgl_defaultmapshader_.vertex = new _ol_renderer_webgl_defaultmapshader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_renderer_webgl_defaultmapshader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_opacity = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_opacity' : 'f');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_projectionMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_projectionMatrix' : 'e');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_texCoordMatrix = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texCoordMatrix' : 'd');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_texture = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texture' : 'g');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'b');

    /**
     * @type {number}
     */
    this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'c');
  };
}
exports.default = _ol_renderer_webgl_defaultmapshader_;


},{"../../index":110,"../../webgl/fragment":264,"../../webgl/vertex":266}],207:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _event = require('../../render/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('../../render/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _immediate = require('../../render/webgl/immediate');

var _immediate2 = _interopRequireDefault(_immediate);

var _layer = require('../layer');

var _layer2 = _interopRequireDefault(_layer);

var _defaultmapshader = require('../webgl/defaultmapshader');

var _defaultmapshader2 = _interopRequireDefault(_defaultmapshader);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

var _mat = require('../../vec/mat4');

var _mat2 = _interopRequireDefault(_mat);

var _webgl = require('../../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

var _context = require('../../webgl/context');

var _context2 = _interopRequireDefault(_context);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @abstract
   * @extends {ol.renderer.Layer}
   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
   * @param {ol.layer.Layer} layer Layer.
   */
  var _ol_renderer_webgl_Layer_ = function (mapRenderer, layer) {

    _layer2.default.call(this, layer);

    /**
     * @protected
     * @type {ol.renderer.webgl.Map}
     */
    this.mapRenderer = mapRenderer;

    /**
     * @private
     * @type {ol.webgl.Buffer}
     */
    this.arrayBuffer_ = new _buffer2.default([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);

    /**
     * @protected
     * @type {WebGLTexture}
     */
    this.texture = null;

    /**
     * @protected
     * @type {WebGLFramebuffer}
     */
    this.framebuffer = null;

    /**
     * @protected
     * @type {number|undefined}
     */
    this.framebufferDimension = undefined;

    /**
     * @protected
     * @type {ol.Transform}
     */
    this.texCoordMatrix = _transform2.default.create();

    /**
     * @protected
     * @type {ol.Transform}
     */
    this.projectionMatrix = _transform2.default.create();

    /**
     * @type {Array.<number>}
     * @private
     */
    this.tmpMat4_ = _mat2.default.create();

    /**
     * @private
     * @type {ol.renderer.webgl.defaultmapshader.Locations}
     */
    this.defaultLocations_ = null;
  };

  _index2.default.inherits(_ol_renderer_webgl_Layer_, _layer2.default);

  /**
   * @param {olx.FrameState} frameState Frame state.
   * @param {number} framebufferDimension Framebuffer dimension.
   * @protected
   */
  _ol_renderer_webgl_Layer_.prototype.bindFramebuffer = function (frameState, framebufferDimension) {

    var gl = this.mapRenderer.getGL();

    if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {
      /**
       * @param {WebGLRenderingContext} gl GL.
       * @param {WebGLFramebuffer} framebuffer Framebuffer.
       * @param {WebGLTexture} texture Texture.
       */
      var postRenderFunction = function (gl, framebuffer, texture) {
        if (!gl.isContextLost()) {
          gl.deleteFramebuffer(framebuffer);
          gl.deleteTexture(texture);
        }
      }.bind(null, gl, this.framebuffer, this.texture);

      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */postRenderFunction);

      var texture = _context2.default.createEmptyTexture(gl, framebufferDimension, framebufferDimension);

      var framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(_webgl2.default.FRAMEBUFFER, _webgl2.default.COLOR_ATTACHMENT0, _webgl2.default.TEXTURE_2D, texture, 0);

      this.texture = texture;
      this.framebuffer = framebuffer;
      this.framebufferDimension = framebufferDimension;
    } else {
      gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, this.framebuffer);
    }
  };

  /**
   * @param {olx.FrameState} frameState Frame state.
   * @param {ol.LayerState} layerState Layer state.
   * @param {ol.webgl.Context} context Context.
   */
  _ol_renderer_webgl_Layer_.prototype.composeFrame = function (frameState, layerState, context) {

    this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, context, frameState);

    context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.arrayBuffer_);

    var gl = context.getGL();

    var fragmentShader = _defaultmapshader2.default.fragment;
    var vertexShader = _defaultmapshader2.default.vertex;

    var program = context.getProgram(fragmentShader, vertexShader);

    var locations;
    if (!this.defaultLocations_) {
      locations = new _defaultmapshader2.default.Locations(gl, program);
      this.defaultLocations_ = locations;
    } else {
      locations = this.defaultLocations_;
    }

    if (context.useProgram(program)) {
      gl.enableVertexAttribArray(locations.a_position);
      gl.vertexAttribPointer(locations.a_position, 2, _webgl2.default.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(locations.a_texCoord);
      gl.vertexAttribPointer(locations.a_texCoord, 2, _webgl2.default.FLOAT, false, 16, 8);
      gl.uniform1i(locations.u_texture, 0);
    }

    gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));
    gl.uniformMatrix4fv(locations.u_projectionMatrix, false, _mat2.default.fromTransform(this.tmpMat4_, this.getProjectionMatrix()));
    gl.uniform1f(locations.u_opacity, layerState.opacity);
    gl.bindTexture(_webgl2.default.TEXTURE_2D, this.getTexture());
    gl.drawArrays(_webgl2.default.TRIANGLE_STRIP, 0, 4);

    this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, context, frameState);
  };

  /**
   * @param {ol.render.EventType} type Event type.
   * @param {ol.webgl.Context} context WebGL context.
   * @param {olx.FrameState} frameState Frame state.
   * @private
   */
  _ol_renderer_webgl_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState) {
    var layer = this.getLayer();
    if (layer.hasListener(type)) {
      var viewState = frameState.viewState;
      var resolution = viewState.resolution;
      var pixelRatio = frameState.pixelRatio;
      var extent = frameState.extent;
      var center = viewState.center;
      var rotation = viewState.rotation;
      var size = frameState.size;

      var render = new _immediate2.default(context, center, resolution, rotation, size, extent, pixelRatio);
      var composeEvent = new _event2.default(type, render, frameState, null, context);
      layer.dispatchEvent(composeEvent);
    }
  };

  /**
   * @return {!ol.Transform} Matrix.
   */
  _ol_renderer_webgl_Layer_.prototype.getTexCoordMatrix = function () {
    return this.texCoordMatrix;
  };

  /**
   * @return {WebGLTexture} Texture.
   */
  _ol_renderer_webgl_Layer_.prototype.getTexture = function () {
    return this.texture;
  };

  /**
   * @return {!ol.Transform} Matrix.
   */
  _ol_renderer_webgl_Layer_.prototype.getProjectionMatrix = function () {
    return this.projectionMatrix;
  };

  /**
   * Handle webglcontextlost.
   */
  _ol_renderer_webgl_Layer_.prototype.handleWebGLContextLost = function () {
    this.texture = null;
    this.framebuffer = null;
    this.framebufferDimension = undefined;
  };

  /**
   * @abstract
   * @param {olx.FrameState} frameState Frame state.
   * @param {ol.LayerState} layerState Layer state.
   * @param {ol.webgl.Context} context Context.
   * @return {boolean} whether composeFrame should be called.
   */
  _ol_renderer_webgl_Layer_.prototype.prepareFrame = function (frameState, layerState, context) {};

  /**
   * @abstract
   * @param {ol.Pixel} pixel Pixel.
   * @param {olx.FrameState} frameState FrameState.
   * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
   *     callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  _ol_renderer_webgl_Layer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {};
}
exports.default = _ol_renderer_webgl_Layer_;


},{"../../index":110,"../../render/event":176,"../../render/eventtype":177,"../../render/webgl/immediate":188,"../../transform":254,"../../vec/mat4":255,"../../webgl":260,"../../webgl/buffer":261,"../../webgl/context":262,"../layer":202,"../webgl/defaultmapshader":206}],208:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _css = require('../../css');

var _css2 = _interopRequireDefault(_css);

var _dom = require('../../dom');

var _dom2 = _interopRequireDefault(_dom);

var _events = require('../../events');

var _events2 = _interopRequireDefault(_events);

var _layer = require('../../layer/layer');

var _layer2 = _interopRequireDefault(_layer);

var _event = require('../../render/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('../../render/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _immediate = require('../../render/webgl/immediate');

var _immediate2 = _interopRequireDefault(_immediate);

var _map = require('../map');

var _map2 = _interopRequireDefault(_map);

var _type = require('../type');

var _type2 = _interopRequireDefault(_type);

var _state = require('../../source/state');

var _state2 = _interopRequireDefault(_state);

var _lrucache = require('../../structs/lrucache');

var _lrucache2 = _interopRequireDefault(_lrucache);

var _priorityqueue = require('../../structs/priorityqueue');

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

var _webgl = require('../../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _context = require('../../webgl/context');

var _context2 = _interopRequireDefault(_context);

var _contexteventtype = require('../../webgl/contexteventtype');

var _contexteventtype2 = _interopRequireDefault(_contexteventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.renderer.Map}
   * @param {Element} container Container.
   * @param {ol.Map} map Map.
   */
  var _ol_renderer_webgl_Map_ = function (container, map) {
    _map2.default.call(this, container, map);

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = /** @type {HTMLCanvasElement} */
    document.createElement('CANVAS');
    this.canvas_.style.width = '100%';
    this.canvas_.style.height = '100%';
    this.canvas_.style.display = 'block';
    this.canvas_.className = _css2.default.CLASS_UNSELECTABLE;
    container.insertBefore(this.canvas_, container.childNodes[0] || null);

    /**
     * @private
     * @type {number}
     */
    this.clipTileCanvasWidth_ = 0;

    /**
     * @private
     * @type {number}
     */
    this.clipTileCanvasHeight_ = 0;

    /**
     * @private
     * @type {CanvasRenderingContext2D}
     */
    this.clipTileContext_ = _dom2.default.createCanvasContext2D();

    /**
     * @private
     * @type {boolean}
     */
    this.renderedVisible_ = true;

    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    this.gl_ = _webgl2.default.getContext(this.canvas_, {
      antialias: true,
      depth: true,
      failIfMajorPerformanceCaveat: true,
      preserveDrawingBuffer: false,
      stencil: true
    });

    /**
     * @private
     * @type {ol.webgl.Context}
     */
    this.context_ = new _context2.default(this.canvas_, this.gl_);

    _events2.default.listen(this.canvas_, _contexteventtype2.default.LOST, this.handleWebGLContextLost, this);
    _events2.default.listen(this.canvas_, _contexteventtype2.default.RESTORED, this.handleWebGLContextRestored, this);

    /**
     * @private
     * @type {ol.structs.LRUCache.<ol.WebglTextureCacheEntry|null>}
     */
    this.textureCache_ = new _lrucache2.default();

    /**
     * @private
     * @type {ol.Coordinate}
     */
    this.focus_ = null;

    /**
     * @private
     * @type {ol.structs.PriorityQueue.<Array>}
     */
    this.tileTextureQueue_ = new _priorityqueue2.default(
    /**
     * @param {Array.<*>} element Element.
     * @return {number} Priority.
     * @this {ol.renderer.webgl.Map}
     */
    function (element) {
      var tileCenter = /** @type {ol.Coordinate} */element[1];
      var tileResolution = /** @type {number} */element[2];
      var deltaX = tileCenter[0] - this.focus_[0];
      var deltaY = tileCenter[1] - this.focus_[1];
      return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
    }.bind(this),
    /**
     * @param {Array.<*>} element Element.
     * @return {string} Key.
     */
    function (element) {
      return (/** @type {ol.Tile} */element[0].getKey()
      );
    });

    /**
     * @param {ol.Map} map Map.
     * @param {?olx.FrameState} frameState Frame state.
     * @return {boolean} false.
     * @this {ol.renderer.webgl.Map}
     */
    this.loadNextTileTexture_ = function (map, frameState) {
      if (!this.tileTextureQueue_.isEmpty()) {
        this.tileTextureQueue_.reprioritize();
        var element = this.tileTextureQueue_.dequeue();
        var tile = /** @type {ol.Tile} */element[0];
        var tileSize = /** @type {ol.Size} */element[3];
        var tileGutter = /** @type {number} */element[4];
        this.bindTileTexture(tile, tileSize, tileGutter, _webgl2.default.LINEAR, _webgl2.default.LINEAR);
      }
      return false;
    }.bind(this);

    /**
     * @private
     * @type {number}
     */
    this.textureCacheFrameMarkerCount_ = 0;

    this.initializeGL_();
  };

  _index2.default.inherits(_ol_renderer_webgl_Map_, _map2.default);

  /**
   * @param {ol.Tile} tile Tile.
   * @param {ol.Size} tileSize Tile size.
   * @param {number} tileGutter Tile gutter.
   * @param {number} magFilter Mag filter.
   * @param {number} minFilter Min filter.
   */
  _ol_renderer_webgl_Map_.prototype.bindTileTexture = function (tile, tileSize, tileGutter, magFilter, minFilter) {
    var gl = this.getGL();
    var tileKey = tile.getKey();
    if (this.textureCache_.containsKey(tileKey)) {
      var textureCacheEntry = this.textureCache_.get(tileKey);
      gl.bindTexture(_webgl2.default.TEXTURE_2D, textureCacheEntry.texture);
      if (textureCacheEntry.magFilter != magFilter) {
        gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MAG_FILTER, magFilter);
        textureCacheEntry.magFilter = magFilter;
      }
      if (textureCacheEntry.minFilter != minFilter) {
        gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MIN_FILTER, minFilter);
        textureCacheEntry.minFilter = minFilter;
      }
    } else {
      var texture = gl.createTexture();
      gl.bindTexture(_webgl2.default.TEXTURE_2D, texture);
      if (tileGutter > 0) {
        var clipTileCanvas = this.clipTileContext_.canvas;
        var clipTileContext = this.clipTileContext_;
        if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {
          clipTileCanvas.width = tileSize[0];
          clipTileCanvas.height = tileSize[1];
          this.clipTileCanvasWidth_ = tileSize[0];
          this.clipTileCanvasHeight_ = tileSize[1];
        } else {
          clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);
        }
        clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);
        gl.texImage2D(_webgl2.default.TEXTURE_2D, 0, _webgl2.default.RGBA, _webgl2.default.RGBA, _webgl2.default.UNSIGNED_BYTE, clipTileCanvas);
      } else {
        gl.texImage2D(_webgl2.default.TEXTURE_2D, 0, _webgl2.default.RGBA, _webgl2.default.RGBA, _webgl2.default.UNSIGNED_BYTE, tile.getImage());
      }
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MAG_FILTER, magFilter);
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_MIN_FILTER, minFilter);
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_S, _webgl2.default.CLAMP_TO_EDGE);
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_T, _webgl2.default.CLAMP_TO_EDGE);
      this.textureCache_.set(tileKey, {
        texture: texture,
        magFilter: magFilter,
        minFilter: minFilter
      });
    }
  };

  /**
   * @param {ol.render.EventType} type Event type.
   * @param {olx.FrameState} frameState Frame state.
   * @private
   */
  _ol_renderer_webgl_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
    var map = this.getMap();
    if (map.hasListener(type)) {
      var context = this.context_;

      var extent = frameState.extent;
      var size = frameState.size;
      var viewState = frameState.viewState;
      var pixelRatio = frameState.pixelRatio;

      var resolution = viewState.resolution;
      var center = viewState.center;
      var rotation = viewState.rotation;

      var vectorContext = new _immediate2.default(context, center, resolution, rotation, size, extent, pixelRatio);
      var composeEvent = new _event2.default(type, vectorContext, frameState, null, context);
      map.dispatchEvent(composeEvent);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.disposeInternal = function () {
    var gl = this.getGL();
    if (!gl.isContextLost()) {
      this.textureCache_.forEach(
      /**
       * @param {?ol.WebglTextureCacheEntry} textureCacheEntry
       *     Texture cache entry.
       */
      function (textureCacheEntry) {
        if (textureCacheEntry) {
          gl.deleteTexture(textureCacheEntry.texture);
        }
      });
    }
    this.context_.dispose();
    _map2.default.prototype.disposeInternal.call(this);
  };

  /**
   * @param {ol.Map} map Map.
   * @param {olx.FrameState} frameState Frame state.
   * @private
   */
  _ol_renderer_webgl_Map_.prototype.expireCache_ = function (map, frameState) {
    var this$1 = this;

    var gl = this.getGL();
    var textureCacheEntry;
    while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index2.default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
      textureCacheEntry = this$1.textureCache_.peekLast();
      if (!textureCacheEntry) {
        if (+this$1.textureCache_.peekLastKey() == frameState.index) {
          break;
        } else {
          --this$1.textureCacheFrameMarkerCount_;
        }
      } else {
        gl.deleteTexture(textureCacheEntry.texture);
      }
      this$1.textureCache_.pop();
    }
  };

  /**
   * @return {ol.webgl.Context} The context.
   */
  _ol_renderer_webgl_Map_.prototype.getContext = function () {
    return this.context_;
  };

  /**
   * @return {WebGLRenderingContext} GL.
   */
  _ol_renderer_webgl_Map_.prototype.getGL = function () {
    return this.gl_;
  };

  /**
   * @return {ol.structs.PriorityQueue.<Array>} Tile texture queue.
   */
  _ol_renderer_webgl_Map_.prototype.getTileTextureQueue = function () {
    return this.tileTextureQueue_;
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.getType = function () {
    return _type2.default.WEBGL;
  };

  /**
   * @param {ol.events.Event} event Event.
   * @protected
   */
  _ol_renderer_webgl_Map_.prototype.handleWebGLContextLost = function (event) {
    event.preventDefault();
    this.textureCache_.clear();
    this.textureCacheFrameMarkerCount_ = 0;

    var renderers = this.getLayerRenderers();
    for (var id in renderers) {
      var renderer = /** @type {ol.renderer.webgl.Layer} */renderers[id];
      renderer.handleWebGLContextLost();
    }
  };

  /**
   * @protected
   */
  _ol_renderer_webgl_Map_.prototype.handleWebGLContextRestored = function () {
    this.initializeGL_();
    this.getMap().render();
  };

  /**
   * @private
   */
  _ol_renderer_webgl_Map_.prototype.initializeGL_ = function () {
    var gl = this.gl_;
    gl.activeTexture(_webgl2.default.TEXTURE0);
    gl.blendFuncSeparate(_webgl2.default.SRC_ALPHA, _webgl2.default.ONE_MINUS_SRC_ALPHA, _webgl2.default.ONE, _webgl2.default.ONE_MINUS_SRC_ALPHA);
    gl.disable(_webgl2.default.CULL_FACE);
    gl.disable(_webgl2.default.DEPTH_TEST);
    gl.disable(_webgl2.default.SCISSOR_TEST);
    gl.disable(_webgl2.default.STENCIL_TEST);
  };

  /**
   * @param {ol.Tile} tile Tile.
   * @return {boolean} Is tile texture loaded.
   */
  _ol_renderer_webgl_Map_.prototype.isTileTextureLoaded = function (tile) {
    return this.textureCache_.containsKey(tile.getKey());
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.renderFrame = function (frameState) {
    var this$1 = this;


    var context = this.getContext();
    var gl = this.getGL();

    if (gl.isContextLost()) {
      return false;
    }

    if (!frameState) {
      if (this.renderedVisible_) {
        this.canvas_.style.display = 'none';
        this.renderedVisible_ = false;
      }
      return false;
    }

    this.focus_ = frameState.focus;

    this.textureCache_.set((-frameState.index).toString(), null);
    ++this.textureCacheFrameMarkerCount_;

    this.dispatchComposeEvent_(_eventtype2.default.PRECOMPOSE, frameState);

    /** @type {Array.<ol.LayerState>} */
    var layerStatesToDraw = [];
    var layerStatesArray = frameState.layerStatesArray;
    _array2.default.stableSort(layerStatesArray, _map2.default.sortByZIndex);

    var viewResolution = frameState.viewState.resolution;
    var i, ii, layerRenderer, layerState;
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerState = layerStatesArray[i];
      if (_layer2.default.visibleAtResolution(layerState, viewResolution) && layerState.sourceState == _state2.default.READY) {
        layerRenderer = /** @type {ol.renderer.webgl.Layer} */this$1.getLayerRenderer(layerState.layer);
        if (layerRenderer.prepareFrame(frameState, layerState, context)) {
          layerStatesToDraw.push(layerState);
        }
      }
    }

    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    if (this.canvas_.width != width || this.canvas_.height != height) {
      this.canvas_.width = width;
      this.canvas_.height = height;
    }

    gl.bindFramebuffer(_webgl2.default.FRAMEBUFFER, null);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(_webgl2.default.COLOR_BUFFER_BIT);
    gl.enable(_webgl2.default.BLEND);
    gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);

    for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {
      layerState = layerStatesToDraw[i];
      layerRenderer = /** @type {ol.renderer.webgl.Layer} */this$1.getLayerRenderer(layerState.layer);
      layerRenderer.composeFrame(frameState, layerState, context);
    }

    if (!this.renderedVisible_) {
      this.canvas_.style.display = '';
      this.renderedVisible_ = true;
    }

    this.calculateMatrices2D(frameState);

    if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > _index2.default.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */this.expireCache_.bind(this));
    }

    if (!this.tileTextureQueue_.isEmpty()) {
      frameState.postRenderFunctions.push(this.loadNextTileTexture_);
      frameState.animate = true;
    }

    this.dispatchComposeEvent_(_eventtype2.default.POSTCOMPOSE, frameState);

    this.scheduleRemoveUnusedLayerRenderers(frameState);
    this.scheduleExpireIconCache(frameState);
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
    var this$1 = this;

    var result;

    if (this.getGL().isContextLost()) {
      return false;
    }

    var viewState = frameState.viewState;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {
        var layerRenderer = this$1.getLayerRenderer(layer);
        result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
    var this$1 = this;

    var hasFeature = false;

    if (this.getGL().isContextLost()) {
      return false;
    }

    var viewState = frameState.viewState;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
        var layerRenderer = this$1.getLayerRenderer(layer);
        hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);
        if (hasFeature) {
          return true;
        }
      }
    }
    return hasFeature;
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
    var this$1 = this;

    if (this.getGL().isContextLost()) {
      return false;
    }

    var viewState = frameState.viewState;
    var result;

    var layerStates = frameState.layerStatesArray;
    var numLayers = layerStates.length;
    var i;
    for (i = numLayers - 1; i >= 0; --i) {
      var layerState = layerStates[i];
      var layer = layerState.layer;
      if (_layer2.default.visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
        var layerRenderer = /** @type {ol.renderer.webgl.Layer} */this$1.getLayerRenderer(layer);
        result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);
        if (result) {
          return result;
        }
      }
    }
    return undefined;
  };
} // FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)

exports.default = _ol_renderer_webgl_Map_;


},{"../../array":42,"../../css":58,"../../dom":60,"../../events":62,"../../index":110,"../../layer/layer":128,"../../render/event":176,"../../render/eventtype":177,"../../render/webgl/immediate":188,"../../source/state":219,"../../structs/lrucache":234,"../../structs/priorityqueue":235,"../../webgl":260,"../../webgl/context":262,"../../webgl/contexteventtype":263,"../map":203,"../type":204}],209:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _tilestate = require('../../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _tilerange = require('../../tilerange');

var _tilerange2 = _interopRequireDefault(_tilerange);

var _array = require('../../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _math = require('../../math');

var _math2 = _interopRequireDefault(_math);

var _layer = require('../webgl/layer');

var _layer2 = _interopRequireDefault(_layer);

var _tilelayershader = require('../webgl/tilelayershader');

var _tilelayershader2 = _interopRequireDefault(_tilelayershader);

var _size = require('../../size');

var _size2 = _interopRequireDefault(_size);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

var _webgl = require('../../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _buffer = require('../../webgl/buffer');

var _buffer2 = _interopRequireDefault(_buffer);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

// FIXME large resolutions lead to too large framebuffers :-(
// FIXME animated shaders! check in redraw

if (false) {
  /**
   * @constructor
   * @extends {ol.renderer.webgl.Layer}
   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
   * @param {ol.layer.Tile} tileLayer Tile layer.
   */
  var _ol_renderer_webgl_TileLayer_ = function (mapRenderer, tileLayer) {

    _layer2.default.call(this, mapRenderer, tileLayer);

    /**
     * @private
     * @type {ol.webgl.Fragment}
     */
    this.fragmentShader_ = _tilelayershader2.default.fragment;

    /**
     * @private
     * @type {ol.webgl.Vertex}
     */
    this.vertexShader_ = _tilelayershader2.default.vertex;

    /**
     * @private
     * @type {ol.renderer.webgl.tilelayershader.Locations}
     */
    this.locations_ = null;

    /**
     * @private
     * @type {ol.webgl.Buffer}
     */
    this.renderArrayBuffer_ = new _buffer2.default([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);

    /**
     * @private
     * @type {ol.TileRange}
     */
    this.renderedTileRange_ = null;

    /**
     * @private
     * @type {ol.Extent}
     */
    this.renderedFramebufferExtent_ = null;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {ol.Size}
     */
    this.tmpSize_ = [0, 0];
  };

  _index2.default.inherits(_ol_renderer_webgl_TileLayer_, _layer2.default);

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_TileLayer_.prototype.disposeInternal = function () {
    var context = this.mapRenderer.getContext();
    context.deleteBuffer(this.renderArrayBuffer_);
    _layer2.default.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_TileLayer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
    var mapRenderer = this.mapRenderer;

    return (
      /**
       * @param {number} zoom Zoom level.
       * @param {ol.TileRange} tileRange Tile range.
       * @return {boolean} The tile range is fully loaded.
       */
      function (zoom, tileRange) {
        function callback(tile) {
          var loaded = mapRenderer.isTileTextureLoaded(tile);
          if (loaded) {
            if (!tiles[zoom]) {
              tiles[zoom] = {};
            }
            tiles[zoom][tile.tileCoord.toString()] = tile;
          }
          return loaded;
        }
        return source.forEachLoadedTile(projection, zoom, tileRange, callback);
      }
    );
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_TileLayer_.prototype.handleWebGLContextLost = function () {
    _layer2.default.prototype.handleWebGLContextLost.call(this);
    this.locations_ = null;
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_TileLayer_.prototype.prepareFrame = function (frameState, layerState, context) {
    var this$1 = this;


    var mapRenderer = this.mapRenderer;
    var gl = context.getGL();

    var viewState = frameState.viewState;
    var projection = viewState.projection;

    var tileLayer = /** @type {ol.layer.Tile} */this.getLayer();
    var tileSource = tileLayer.getSource();
    var tileGrid = tileSource.getTileGridForProjection(projection);
    var z = tileGrid.getZForResolution(viewState.resolution);
    var tileResolution = tileGrid.getResolution(z);

    var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);
    var pixelRatio = tilePixelSize[0] / _size2.default.toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];
    var tilePixelResolution = tileResolution / pixelRatio;
    var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);

    var center = viewState.center;
    var extent = frameState.extent;
    var tileRange = tileGrid.getTileRangeForExtentAndResolution(extent, tileResolution);

    var framebufferExtent;
    if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {
      framebufferExtent = this.renderedFramebufferExtent_;
    } else {

      var tileRangeSize = tileRange.getSize();

      var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);
      var framebufferDimension = _math2.default.roundUpToPowerOfTwo(maxDimension);
      var framebufferExtentDimension = tilePixelResolution * framebufferDimension;
      var origin = tileGrid.getOrigin(z);
      var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;
      var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;
      framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];

      this.bindFramebuffer(frameState, framebufferDimension);
      gl.viewport(0, 0, framebufferDimension, framebufferDimension);

      gl.clearColor(0, 0, 0, 0);
      gl.clear(_webgl2.default.COLOR_BUFFER_BIT);
      gl.disable(_webgl2.default.BLEND);

      var program = context.getProgram(this.fragmentShader_, this.vertexShader_);
      context.useProgram(program);
      if (!this.locations_) {
        this.locations_ = new _tilelayershader2.default.Locations(gl, program);
      }

      context.bindBuffer(_webgl2.default.ARRAY_BUFFER, this.renderArrayBuffer_);
      gl.enableVertexAttribArray(this.locations_.a_position);
      gl.vertexAttribPointer(this.locations_.a_position, 2, _webgl2.default.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(this.locations_.a_texCoord);
      gl.vertexAttribPointer(this.locations_.a_texCoord, 2, _webgl2.default.FLOAT, false, 16, 8);
      gl.uniform1i(this.locations_.u_texture, 0);

      /**
       * @type {Object.<number, Object.<string, ol.Tile>>}
       */
      var tilesToDrawByZ = {};
      tilesToDrawByZ[z] = {};

      var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);

      var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
      var allTilesLoaded = true;
      var tmpExtent = _extent2.default.createEmpty();
      var tmpTileRange = new _tilerange2.default(0, 0, 0, 0);
      var childTileRange, drawable, fullyLoaded, tile, tileState;
      var x, y, tileExtent;
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {

          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (layerState.extent !== undefined) {
            // ignore tiles outside layer extent
            tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
            if (!_extent2.default.intersects(tileExtent, layerState.extent)) {
              continue;
            }
          }
          tileState = tile.getState();
          drawable = tileState == _tilestate2.default.LOADED || tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError;
          if (!drawable) {
            tile = tile.getInterimTile();
          }
          tileState = tile.getState();
          if (tileState == _tilestate2.default.LOADED) {
            if (mapRenderer.isTileTextureLoaded(tile)) {
              tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
              continue;
            }
          } else if (tileState == _tilestate2.default.EMPTY || tileState == _tilestate2.default.ERROR && !useInterimTilesOnError) {
            continue;
          }

          allTilesLoaded = false;
          fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
          if (!fullyLoaded) {
            childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
            if (childTileRange) {
              findLoadedTiles(z + 1, childTileRange);
            }
          }
        }
      }

      /** @type {Array.<number>} */
      var zs = Object.keys(tilesToDrawByZ).map(Number);
      zs.sort(_array2.default.numberSafeCompareFunction);
      var u_tileOffset = new Float32Array(4);
      var i, ii, tileKey, tilesToDraw;
      for (i = 0, ii = zs.length; i < ii; ++i) {
        tilesToDraw = tilesToDrawByZ[zs[i]];
        for (tileKey in tilesToDraw) {
          tile = tilesToDraw[tileKey];
          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
          u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;
          u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;
          u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;
          u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;
          gl.uniform4fv(this$1.locations_.u_tileOffset, u_tileOffset);
          mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, _webgl2.default.LINEAR, _webgl2.default.LINEAR);
          gl.drawArrays(_webgl2.default.TRIANGLE_STRIP, 0, 4);
        }
      }

      if (allTilesLoaded) {
        this.renderedTileRange_ = tileRange;
        this.renderedFramebufferExtent_ = framebufferExtent;
        this.renderedRevision_ = tileSource.getRevision();
      } else {
        this.renderedTileRange_ = null;
        this.renderedFramebufferExtent_ = null;
        this.renderedRevision_ = -1;
        frameState.animate = true;
      }
    }

    this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
    var tileTextureQueue = mapRenderer.getTileTextureQueue();
    this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(),
    /**
     * @param {ol.Tile} tile Tile.
     */
    function (tile) {
      if (tile.getState() == _tilestate2.default.LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {
        tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);
      }
    }, this);
    this.scheduleExpireCache(frameState, tileSource);
    this.updateLogos(frameState, tileSource);

    var texCoordMatrix = this.texCoordMatrix;
    _transform2.default.reset(texCoordMatrix);
    _transform2.default.translate(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));
    if (viewState.rotation !== 0) {
      _transform2.default.rotate(texCoordMatrix, viewState.rotation);
    }
    _transform2.default.scale(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));
    _transform2.default.translate(texCoordMatrix, -0.5, -0.5);

    return true;
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_TileLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
    if (!this.framebuffer) {
      return undefined;
    }

    var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];

    var pixelOnFrameBufferScaled = _transform2.default.apply(this.texCoordMatrix, pixelOnMapScaled.slice());
    var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];

    var gl = this.mapRenderer.getContext().getGL();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    var imageData = new Uint8Array(4);
    gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  };
}
exports.default = _ol_renderer_webgl_TileLayer_;


},{"../../array":42,"../../extent":68,"../../index":110,"../../math":144,"../../size":217,"../../tilerange":251,"../../tilestate":252,"../../transform":254,"../../webgl":260,"../../webgl/buffer":261,"../webgl/layer":207,"../webgl/tilelayershader":210}],210:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _fragment = require('../../webgl/fragment');

var _fragment2 = _interopRequireDefault(_fragment);

var _vertex = require('../../webgl/vertex');

var _vertex2 = _interopRequireDefault(_vertex);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_renderer_webgl_tilelayershader_ = {}; // This file is automatically generated, do not edit


if (false) {

  /**
   * @constructor
   * @extends {ol.webgl.Fragment}
   * @struct
   */
  _ol_renderer_webgl_tilelayershader_.Fragment = function () {
    _fragment2.default.call(this, _ol_renderer_webgl_tilelayershader_.Fragment.SOURCE);
  };
  _index2.default.inherits(_ol_renderer_webgl_tilelayershader_.Fragment, _fragment2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Fragment.DEBUG_SOURCE = 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Fragment.OPTIMIZED_SOURCE = 'precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Fragment.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_renderer_webgl_tilelayershader_.Fragment.DEBUG_SOURCE : _ol_renderer_webgl_tilelayershader_.Fragment.OPTIMIZED_SOURCE;

  _ol_renderer_webgl_tilelayershader_.fragment = new _ol_renderer_webgl_tilelayershader_.Fragment();

  /**
   * @constructor
   * @extends {ol.webgl.Vertex}
   * @struct
   */
  _ol_renderer_webgl_tilelayershader_.Vertex = function () {
    _vertex2.default.call(this, _ol_renderer_webgl_tilelayershader_.Vertex.SOURCE);
  };
  _index2.default.inherits(_ol_renderer_webgl_tilelayershader_.Vertex, _vertex2.default);

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Vertex.DEBUG_SOURCE = 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Vertex.OPTIMIZED_SOURCE = 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}';

  /**
   * @const
   * @type {string}
   */
  _ol_renderer_webgl_tilelayershader_.Vertex.SOURCE = _index2.default.DEBUG_WEBGL ? _ol_renderer_webgl_tilelayershader_.Vertex.DEBUG_SOURCE : _ol_renderer_webgl_tilelayershader_.Vertex.OPTIMIZED_SOURCE;

  _ol_renderer_webgl_tilelayershader_.vertex = new _ol_renderer_webgl_tilelayershader_.Vertex();

  /**
   * @constructor
   * @param {WebGLRenderingContext} gl GL.
   * @param {WebGLProgram} program Program.
   * @struct
   */
  _ol_renderer_webgl_tilelayershader_.Locations = function (gl, program) {

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_texture = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_texture' : 'e');

    /**
     * @type {WebGLUniformLocation}
     */
    this.u_tileOffset = gl.getUniformLocation(program, _index2.default.DEBUG_WEBGL ? 'u_tileOffset' : 'd');

    /**
     * @type {number}
     */
    this.a_position = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_position' : 'b');

    /**
     * @type {number}
     */
    this.a_texCoord = gl.getAttribLocation(program, _index2.default.DEBUG_WEBGL ? 'a_texCoord' : 'c');
  };
}
exports.default = _ol_renderer_webgl_tilelayershader_;


},{"../../index":110,"../../webgl/fragment":264,"../../webgl/vertex":266}],211:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../../index');

var _index2 = _interopRequireDefault(_index);

var _viewhint = require('../../viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _extent = require('../../extent');

var _extent2 = _interopRequireDefault(_extent);

var _replaygroup = require('../../render/webgl/replaygroup');

var _replaygroup2 = _interopRequireDefault(_replaygroup);

var _vector = require('../vector');

var _vector2 = _interopRequireDefault(_vector);

var _layer = require('../webgl/layer');

var _layer2 = _interopRequireDefault(_layer);

var _transform = require('../../transform');

var _transform2 = _interopRequireDefault(_transform);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.renderer.webgl.Layer}
   * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
   * @param {ol.layer.Vector} vectorLayer Vector layer.
   */
  var _ol_renderer_webgl_VectorLayer_ = function (mapRenderer, vectorLayer) {

    _layer2.default.call(this, mapRenderer, vectorLayer);

    /**
     * @private
     * @type {boolean}
     */
    this.dirty_ = false;

    /**
     * @private
     * @type {number}
     */
    this.renderedRevision_ = -1;

    /**
     * @private
     * @type {number}
     */
    this.renderedResolution_ = NaN;

    /**
     * @private
     * @type {ol.Extent}
     */
    this.renderedExtent_ = _extent2.default.createEmpty();

    /**
     * @private
     * @type {function(ol.Feature, ol.Feature): number|null}
     */
    this.renderedRenderOrder_ = null;

    /**
     * @private
     * @type {ol.render.webgl.ReplayGroup}
     */
    this.replayGroup_ = null;

    /**
     * The last layer state.
     * @private
     * @type {?ol.LayerState}
     */
    this.layerState_ = null;
  };

  _index2.default.inherits(_ol_renderer_webgl_VectorLayer_, _layer2.default);

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
    this.layerState_ = layerState;
    var viewState = frameState.viewState;
    var replayGroup = this.replayGroup_;
    var size = frameState.size;
    var pixelRatio = frameState.pixelRatio;
    var gl = this.mapRenderer.getGL();
    if (replayGroup && !replayGroup.isEmpty()) {
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);
      replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});
      gl.disable(gl.SCISSOR_TEST);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.disposeInternal = function () {
    var replayGroup = this.replayGroup_;
    if (replayGroup) {
      var context = this.mapRenderer.getContext();
      replayGroup.getDeleteResourcesFunction(context)();
      this.replayGroup_ = null;
    }
    _layer2.default.prototype.disposeInternal.call(this);
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
    if (!this.replayGroup_ || !this.layerState_) {
      return undefined;
    } else {
      var context = this.mapRenderer.getContext();
      var viewState = frameState.viewState;
      var layer = this.getLayer();
      var layerState = this.layerState_;
      /** @type {Object.<string, boolean>} */
      var features = {};
      return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {},
      /**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */
      function (feature) {
        var key = _index2.default.getUid(feature).toString();
        if (!(key in features)) {
          features[key] = true;
          return callback.call(thisArg, feature, layer);
        }
      });
    }
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
    if (!this.replayGroup_ || !this.layerState_) {
      return false;
    } else {
      var context = this.mapRenderer.getContext();
      var viewState = frameState.viewState;
      var layerState = this.layerState_;
      return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);
    }
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
    var coordinate = _transform2.default.apply(frameState.pixelToCoordinateTransform, pixel.slice());
    var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  };

  /**
   * Handle changes in image style state.
   * @param {ol.events.Event} event Image style change event.
   * @private
   */
  _ol_renderer_webgl_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
    this.renderIfReadyAndVisible();
  };

  /**
   * @inheritDoc
   */
  _ol_renderer_webgl_VectorLayer_.prototype.prepareFrame = function (frameState, layerState, context) {

    var vectorLayer = /** @type {ol.layer.Vector} */this.getLayer();
    var vectorSource = vectorLayer.getSource();

    this.updateAttributions(frameState.attributions, vectorSource.getAttributions());
    this.updateLogos(frameState, vectorSource);

    var animating = frameState.viewHints[_viewhint2.default.ANIMATING];
    var interacting = frameState.viewHints[_viewhint2.default.INTERACTING];
    var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
    var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

    if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
      return true;
    }

    var frameStateExtent = frameState.extent;
    var viewState = frameState.viewState;
    var projection = viewState.projection;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var vectorLayerRevision = vectorLayer.getRevision();
    var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
    var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

    if (vectorLayerRenderOrder === undefined) {
      vectorLayerRenderOrder = _vector2.default.defaultOrder;
    }

    var extent = _extent2.default.buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

    if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && _extent2.default.containsExtent(this.renderedExtent_, extent)) {
      return true;
    }

    if (this.replayGroup_) {
      frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));
    }

    this.dirty_ = false;

    var replayGroup = new _replaygroup2.default(_vector2.default.getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());
    vectorSource.loadFeatures(extent, resolution, projection);
    /**
     * @param {ol.Feature} feature Feature.
     * @this {ol.renderer.webgl.VectorLayer}
     */
    var renderFeature = function (feature) {
      var styles;
      var styleFunction = feature.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction.call(feature, resolution);
      } else {
        styleFunction = vectorLayer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
      }
      if (styles) {
        var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
      }
    };
    if (vectorLayerRenderOrder) {
      /** @type {Array.<ol.Feature>} */
      var features = [];
      vectorSource.forEachFeatureInExtent(extent,
      /**
       * @param {ol.Feature} feature Feature.
       */
      function (feature) {
        features.push(feature);
      }, this);
      features.sort(vectorLayerRenderOrder);
      features.forEach(renderFeature, this);
    } else {
      vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
    }
    replayGroup.finish(context);

    this.renderedResolution_ = resolution;
    this.renderedRevision_ = vectorLayerRevision;
    this.renderedRenderOrder_ = vectorLayerRenderOrder;
    this.renderedExtent_ = extent;
    this.replayGroup_ = replayGroup;

    return true;
  };

  /**
   * @param {ol.Feature} feature Feature.
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
   *     styles.
   * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
   * @return {boolean} `true` if an image is loading.
   */
  _ol_renderer_webgl_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
    var this$1 = this;

    if (!styles) {
      return false;
    }
    var loading = false;
    if (Array.isArray(styles)) {
      for (var i = styles.length - 1, ii = 0; i >= ii; --i) {
        loading = _vector2.default.renderFeature(replayGroup, feature, styles[i], _vector2.default.getSquaredTolerance(resolution, pixelRatio), this$1.handleStyleImageChange_, this$1) || loading;
      }
    } else {
      loading = _vector2.default.renderFeature(replayGroup, feature, styles, _vector2.default.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
    return loading;
  };
}
exports.default = _ol_renderer_webgl_VectorLayer_;


},{"../../extent":68,"../../index":110,"../../render/webgl/replaygroup":194,"../../transform":254,"../../viewhint":258,"../vector":205,"../webgl/layer":207}],212:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _extent = require('./extent');

var _extent2 = _interopRequireDefault(_extent);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

var _proj = require('./proj');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_reproj_ = {};

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
_ol_reproj_.calculateSourceResolution = function (sourceProj, targetProj, targetCenter, targetResolution) {

  var sourceCenter = _proj2.default.transform(targetCenter, targetProj, sourceProj);

  // calculate the ideal resolution of the source data
  var sourceResolution = _proj2.default.getPointResolution(targetProj, targetResolution, targetCenter);

  var targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== undefined) {
    sourceResolution *= targetMetersPerUnit;
  }
  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== undefined) {
    sourceResolution /= sourceMetersPerUnit;
  }

  // Based on the projection properties, the point resolution at the specified
  // coordinates may be slightly different. We need to reverse-compensate this
  // in order to achieve optimal results.

  var compensationFactor = _proj2.default.getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;

  if (isFinite(compensationFactor) && compensationFactor > 0) {
    sourceResolution /= compensationFactor;
  }

  return sourceResolution;
};

/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {ol.Coordinate} New point 1 px farther from the centroid.
 * @private
 */
_ol_reproj_.enlargeClipPoint_ = function (centroidX, centroidY, x, y) {
  var dX = x - centroidX,
      dY = y - centroidY;
  var distance = Math.sqrt(dX * dX + dY * dY);
  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
};

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {ol.Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.
 * @param {Array.<{extent: ol.Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 *             Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
_ol_reproj_.render = function (width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {

  var context = _dom2.default.createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

  if (sources.length === 0) {
    return context.canvas;
  }

  context.scale(pixelRatio, pixelRatio);

  var sourceDataExtent = _extent2.default.createEmpty();
  sources.forEach(function (src, i, arr) {
    _extent2.default.extend(sourceDataExtent, src.extent);
  });

  var canvasWidthInUnits = _extent2.default.getWidth(sourceDataExtent);
  var canvasHeightInUnits = _extent2.default.getHeight(sourceDataExtent);
  var stitchContext = _dom2.default.createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

  var stitchScale = pixelRatio / sourceResolution;

  sources.forEach(function (src, i, arr) {
    var xPos = src.extent[0] - sourceDataExtent[0];
    var yPos = -(src.extent[3] - sourceDataExtent[3]);
    var srcWidth = _extent2.default.getWidth(src.extent);
    var srcHeight = _extent2.default.getHeight(src.extent);

    stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
  });

  var targetTopLeft = _extent2.default.getTopLeft(targetExtent);

  triangulation.getTriangles().forEach(function (triangle, i, arr) {
    /* Calculate affine transform (src -> dst)
     * Resulting matrix can be used to transform coordinate
     * from `sourceProjection` to destination pixels.
     *
     * To optimize number of context calls and increase numerical stability,
     * we also do the following operations:
     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
     * here before solving the linear system so [ui, vi] are pixel coordinates.
     *
     * Src points: xi, yi
     * Dst points: ui, vi
     * Affine coefficients: aij
     *
     * | x0 y0 1  0  0 0 |   |a00|   |u0|
     * | x1 y1 1  0  0 0 |   |a01|   |u1|
     * | x2 y2 1  0  0 0 | x |a02| = |u2|
     * |  0  0 0 x0 y0 1 |   |a10|   |v0|
     * |  0  0 0 x1 y1 1 |   |a11|   |v1|
     * |  0  0 0 x2 y2 1 |   |a12|   |v2|
     */
    var source = triangle.source,
        target = triangle.target;
    var x0 = source[0][0],
        y0 = source[0][1],
        x1 = source[1][0],
        y1 = source[1][1],
        x2 = source[2][0],
        y2 = source[2][1];
    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
        v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
        v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
        v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

    // Shift all the source points to improve numerical stability
    // of all the subsequent calculations. The [x0, y0] is used here.
    // This is also used to simplify the linear system.
    var sourceNumericalShiftX = x0,
        sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;

    var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
    var affineCoefs = _math2.default.solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }

    context.save();
    context.beginPath();
    var centroidX = (u0 + u1 + u2) / 3,
        centroidY = (v0 + v1 + v2) / 3;
    var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);
    var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);
    var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);

    context.moveTo(p1[0], p1[1]);
    context.lineTo(p0[0], p0[1]);
    context.lineTo(p2[0], p2[1]);
    context.clip();

    context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

    context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);

    context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);

    context.drawImage(stitchContext.canvas, 0, 0);
    context.restore();
  });

  if (opt_renderEdges) {
    context.save();

    context.strokeStyle = 'black';
    context.lineWidth = 1;

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
      var target = triangle.target;
      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
          v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
          v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
          v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });

    context.restore();
  }
  return context.canvas;
};
exports.default = _ol_reproj_;


},{"./dom":60,"./extent":68,"./math":144,"./proj":158}],213:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _tile = require('../tile');

var _tile2 = _interopRequireDefault(_tile);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

var _reproj = require('../reproj');

var _reproj2 = _interopRequireDefault(_reproj);

var _triangulation = require('../reproj/triangulation');

var _triangulation2 = _interopRequireDefault(_triangulation);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link ol.source.TileImage}.
 *
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.
 * @param {ol.TileCoord} tileCoord Coordinate of the tile.
 * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {ol.ReprojTileFunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */
var _ol_reproj_Tile_ = function (sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  var this$1 = this;

  _tile2.default.call(this, tileCoord, _tilestate2.default.IDLE);

  /**
   * @private
   * @type {boolean}
   */
  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {number}
   */
  this.gutter_ = gutter;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.sourceTileGrid_ = sourceTileGrid;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.targetTileGrid_ = targetTileGrid;

  /**
   * @private
   * @type {ol.TileCoord}
   */
  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

  /**
   * @private
   * @type {!Array.<ol.Tile>}
   */
  this.sourceTiles_ = [];

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.sourcesListenerKeys_ = null;

  /**
   * @private
   * @type {number}
   */
  this.sourceZ_ = 0;

  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();

  var limitedTargetExtent = maxTargetExtent ? _extent2.default.getIntersection(targetExtent, maxTargetExtent) : targetExtent;

  if (_extent2.default.getArea(limitedTargetExtent) === 0) {
    // Tile is completely outside range -> EMPTY
    // TODO: is it actually correct that the source even creates the tile ?
    this.state = _tilestate2.default.EMPTY;
    return;
  }

  var sourceProjExtent = sourceProj.getExtent();
  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = _extent2.default.getIntersection(maxSourceExtent, sourceProjExtent);
    }
  }

  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);

  var targetCenter = _extent2.default.getCenter(limitedTargetExtent);
  var sourceResolution = _reproj2.default.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    // invalid sourceResolution -> EMPTY
    // probably edges of the projections when no extent is defined
    this.state = _tilestate2.default.EMPTY;
    return;
  }

  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : _index2.default.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;

  /**
   * @private
   * @type {!ol.reproj.Triangulation}
   */
  this.triangulation_ = new _triangulation2.default(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);

  if (this.triangulation_.getTriangles().length === 0) {
    // no valid triangles -> EMPTY
    this.state = _tilestate2.default.EMPTY;
    return;
  }

  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();

  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = _math2.default.clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = _math2.default.clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = _extent2.default.getIntersection(sourceExtent, maxSourceExtent);
    }
  }

  if (!_extent2.default.getArea(sourceExtent)) {
    this.state = _tilestate2.default.EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);

    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this$1.sourceZ_, srcX, srcY, pixelRatio);
        if (tile) {
          this$1.sourceTiles_.push(tile);
        }
      }
    }

    if (this.sourceTiles_.length === 0) {
      this.state = _tilestate2.default.EMPTY;
    }
  }
};

_index2.default.inherits(_ol_reproj_Tile_, _tile2.default);

/**
 * @inheritDoc
 */
_ol_reproj_Tile_.prototype.disposeInternal = function () {
  if (this.state == _tilestate2.default.LOADING) {
    this.unlistenSources_();
  }
  _tile2.default.prototype.disposeInternal.call(this);
};

/**
 * @inheritDoc
 */
_ol_reproj_Tile_.prototype.getImage = function () {
  return this.canvas_;
};

/**
 * @private
 */
_ol_reproj_Tile_.prototype.reproject_ = function () {
  var sources = [];
  this.sourceTiles_.forEach(function (tile, i, arr) {
    if (tile && tile.getState() == _tilestate2.default.LOADED) {
      sources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
        image: tile.getImage()
      });
    }
  }, this);
  this.sourceTiles_.length = 0;

  if (sources.length === 0) {
    this.state = _tilestate2.default.ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === 'number' ? size : size[0];
    var height = typeof size === 'number' ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = _reproj2.default.render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);

    this.state = _tilestate2.default.LOADED;
  }
  this.changed();
};

/**
 * @inheritDoc
 */
_ol_reproj_Tile_.prototype.load = function () {
  if (this.state == _tilestate2.default.IDLE) {
    this.state = _tilestate2.default.LOADING;
    this.changed();

    var leftToLoad = 0;

    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _tilestate2.default.IDLE || state == _tilestate2.default.LOADING) {
        leftToLoad++;

        var sourceListenKey;
        sourceListenKey = _events2.default.listen(tile, _eventtype2.default.CHANGE, function (e) {
          var state = tile.getState();
          if (state == _tilestate2.default.LOADED || state == _tilestate2.default.ERROR || state == _tilestate2.default.EMPTY) {
            _events2.default.unlistenByKey(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }, this);

    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == _tilestate2.default.IDLE) {
        tile.load();
      }
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};

/**
 * @private
 */
_ol_reproj_Tile_.prototype.unlistenSources_ = function () {
  this.sourcesListenerKeys_.forEach(_events2.default.unlistenByKey);
  this.sourcesListenerKeys_ = null;
};
exports.default = _ol_reproj_Tile_;


},{"../events":62,"../events/eventtype":66,"../extent":68,"../index":110,"../math":144,"../reproj":212,"../reproj/triangulation":214,"../tile":245,"../tilestate":252}],214:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent to triangulate.
 * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */
var _ol_reproj_Triangulation_ = function (sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object.<string, ol.Coordinate>} */
  var transformInvCache = {};
  var transformInv = _proj2.default.getTransform(this.targetProj_, this.sourceProj_);

  /**
   * @param {ol.Coordinate} c A coordinate.
   * @return {ol.Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {ol.Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array.<ol.ReprojTriangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && _extent2.default.getWidth(maxSourceExtent) == _extent2.default.getWidth(this.sourceProj_.getExtent());

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? _extent2.default.getWidth(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ? _extent2.default.getWidth(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = _extent2.default.getTopLeft(targetExtent);
  var destinationTopRight = _extent2.default.getTopRight(targetExtent);
  var destinationBottomRight = _extent2.default.getBottomRight(targetExtent);
  var destinationBottomLeft = _extent2.default.getBottomLeft(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, _index2.default.RASTER_REPROJECTION_MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }, this);
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @private
 */
_ol_reproj_Triangulation_.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} d The target d coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @param {ol.Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
_ol_reproj_Triangulation_.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = _extent2.default.boundingExtent([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ? _extent2.default.getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = _extent2.default.boundingExtent([a, b, c, d]);
      var targetCoverageX = _extent2.default.getWidth(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > _index2.default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > _index2.default.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!_extent2.default.intersects(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX = (_math2.default.modulo(aSrc[0], sourceWorldWidth) + _math2.default.modulo(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - _math2.default.modulo(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {ol.Extent} Calculated extent.
 */
_ol_reproj_Triangulation_.prototype.calculateSourceExtent = function () {
  var extent = _extent2.default.createEmpty();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;
    _extent2.default.extendCoordinate(extent, src[0]);
    _extent2.default.extendCoordinate(extent, src[1]);
    _extent2.default.extendCoordinate(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.
 */
_ol_reproj_Triangulation_.prototype.getTriangles = function () {
  return this.triangles_;
};
exports.default = _ol_reproj_Triangulation_;


},{"../extent":68,"../index":110,"../math":144,"../proj":158}],215:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require('./array');

var _array2 = _interopRequireDefault(_array);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_ResolutionConstraint_ = {};

/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */
_ol_ResolutionConstraint_.createSnapToResolutions = function (resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = _array2.default.linearFindNearest(resolutions, resolution, direction);
        z = _math2.default.clamp(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);
        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */
_ol_ResolutionConstraint_.createSnapToPower = function (power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);
        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }
        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    }
  );
};
exports.default = _ol_ResolutionConstraint_;


},{"./array":42,"./math":144}],216:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_RotationConstraint_ = {};

/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
_ol_RotationConstraint_.disable = function (rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
};

/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
_ol_RotationConstraint_.none = function (rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
};

/**
 * @param {number} n N.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
_ol_RotationConstraint_.createSnapToN = function (n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
_ol_RotationConstraint_.createSnapToZero = function (opt_tolerance) {
  var tolerance = opt_tolerance || _math2.default.toRadians(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    }
  );
};
exports.default = _ol_RotationConstraint_;


},{"./math":144}],217:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_size_ = {};

/**
 * Returns a buffered size.
 * @param {ol.Size} size Size.
 * @param {number} buffer Buffer.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The buffered size.
 */
_ol_size_.buffer = function (size, buffer, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * buffer;
  opt_size[1] = size[1] + 2 * buffer;
  return opt_size;
};

/**
 * Determines if a size has a positive area.
 * @param {ol.Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
_ol_size_.hasArea = function (size) {
  return size[0] > 0 && size[1] > 0;
};

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {ol.Size} size Size.
 * @param {number} ratio Ratio.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The scaled size.
 */
_ol_size_.scale = function (size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
};

/**
 * Returns an `ol.Size` array for the passed in number (meaning: square) or
 * `ol.Size` array.
 * (meaning: non-square),
 * @param {number|ol.Size} size Width and height.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} Size.
 * @api
 */
_ol_size_.toSize = function (size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */size;
    }
    return opt_size;
  }
};
exports.default = _ol_size_;


},{}],218:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _attribution = require('../attribution');

var _attribution2 = _interopRequireDefault(_attribution);

var _object = require('../object');

var _object2 = _interopRequireDefault(_object);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link ol.layer.Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {ol.SourceSourceOptions} options Source options.
 * @api
 */
var _ol_source_Source_ = function (options) {

  _object2.default.call(this);

  /**
   * @private
   * @type {ol.proj.Projection}
   */
  this.projection_ = _proj2.default.get(options.projection);

  /**
   * @private
   * @type {Array.<ol.Attribution>}
   */
  this.attributions_ = _ol_source_Source_.toAttributionsArray_(options.attributions);

  /**
   * @private
   * @type {string|olx.LogoOptions|undefined}
   */
  this.logo_ = options.logo;

  /**
   * @private
   * @type {ol.source.State}
   */
  this.state_ = options.state !== undefined ? options.state : _state2.default.READY;

  /**
   * @private
   * @type {boolean}
   */
  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
};

_index2.default.inherits(_ol_source_Source_, _object2.default);

/**
 * Turns various ways of defining an attribution to an array of `ol.Attributions`.
 *
 * @param {ol.AttributionLike|undefined}
 *     attributionLike The attributions as string, array of strings,
 *     `ol.Attribution`, array of `ol.Attribution` or undefined.
 * @return {Array.<ol.Attribution>} The array of `ol.Attribution` or null if
 *     `undefined` was given.
 */
_ol_source_Source_.toAttributionsArray_ = function (attributionLike) {
  if (typeof attributionLike === 'string') {
    return [new _attribution2.default({ html: attributionLike })];
  } else if (attributionLike instanceof _attribution2.default) {
    return [attributionLike];
  } else if (Array.isArray(attributionLike)) {
    var len = attributionLike.length;
    var attributions = new Array(len);
    for (var i = 0; i < len; i++) {
      var item = attributionLike[i];
      if (typeof item === 'string') {
        attributions[i] = new _attribution2.default({ html: item });
      } else {
        attributions[i] = item;
      }
    }
    return attributions;
  } else {
    return null;
  }
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
_ol_source_Source_.prototype.forEachFeatureAtCoordinate = _index2.default.nullFunction;

/**
 * Get the attributions of the source.
 * @return {Array.<ol.Attribution>} Attributions.
 * @api
 */
_ol_source_Source_.prototype.getAttributions = function () {
  return this.attributions_;
};

/**
 * Get the logo of the source.
 * @return {string|olx.LogoOptions|undefined} Logo.
 * @api
 */
_ol_source_Source_.prototype.getLogo = function () {
  return this.logo_;
};

/**
 * Get the projection of the source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */
_ol_source_Source_.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */
_ol_source_Source_.prototype.getResolutions = function () {};

/**
 * Get the state of the source, see {@link ol.source.State} for possible states.
 * @return {ol.source.State} State.
 * @api
 */
_ol_source_Source_.prototype.getState = function () {
  return this.state_;
};

/**
 * @return {boolean|undefined} Wrap X.
 */
_ol_source_Source_.prototype.getWrapX = function () {
  return this.wrapX_;
};

/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */
_ol_source_Source_.prototype.refresh = function () {
  this.changed();
};

/**
 * Set the attributions of the source.
 * @param {ol.AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution}`,
 *     `Array<{@link ol.Attribution}>` or `undefined`.
 * @api
 */
_ol_source_Source_.prototype.setAttributions = function (attributions) {
  this.attributions_ = _ol_source_Source_.toAttributionsArray_(attributions);
  this.changed();
};

/**
 * Set the logo of the source.
 * @param {string|olx.LogoOptions|undefined} logo Logo.
 */
_ol_source_Source_.prototype.setLogo = function (logo) {
  this.logo_ = logo;
};

/**
 * Set the state of the source.
 * @param {ol.source.State} state State.
 * @protected
 */
_ol_source_Source_.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};
exports.default = _ol_source_Source_;


},{"../attribution":45,"../index":110,"../object":147,"../proj":158,"../source/state":219}],219:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
var _ol_source_State_ = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};

exports.default = _ol_source_State_;


},{}],220:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _tilecache = require('../tilecache');

var _tilecache2 = _interopRequireDefault(_tilecache);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

var _size = require('../size');

var _size2 = _interopRequireDefault(_size);

var _source = require('../source/source');

var _source2 = _interopRequireDefault(_source);

var _tilecoord = require('../tilecoord');

var _tilecoord2 = _interopRequireDefault(_tilecoord);

var _tilegrid = require('../tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceTileOptions} options Tile source options.
 * @api
 */
var _ol_source_Tile_ = function (options) {

  _source2.default.call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    state: options.state,
    wrapX: options.wrapX
  });

  /**
   * @private
   * @type {boolean}
   */
  this.opaque_ = options.opaque !== undefined ? options.opaque : false;

  /**
   * @private
   * @type {number}
   */
  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

  /**
   * @protected
   * @type {ol.tilegrid.TileGrid}
   */
  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

  /**
   * @protected
   * @type {ol.TileCache}
   */
  this.tileCache = new _tilecache2.default(options.cacheSize);

  /**
   * @protected
   * @type {ol.Size}
   */
  this.tmpSize = [0, 0];

  /**
   * @private
   * @type {string}
   */
  this.key_ = '';
};

_index2.default.inherits(_ol_source_Tile_, _source2.default);

/**
 * @return {boolean} Can expire cache.
 */
_ol_source_Tile_.prototype.canExpireCache = function () {
  return this.tileCache.canExpireCache();
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */
_ol_source_Tile_.prototype.expireCache = function (projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {function(ol.Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */
_ol_source_Tile_.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
  var this$1 = this;

  var tileCache = this.getTileCacheForProjection(projection);
  if (!tileCache) {
    return false;
  }

  var covered = true;
  var tile, tileCoordKey, loaded;
  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = this$1.getKeyZXY(z, x, y);
      loaded = false;
      if (tileCache.containsKey(tileCoordKey)) {
        tile = /** @type {!ol.Tile} */tileCache.get(tileCoordKey);
        loaded = tile.getState() === _tilestate2.default.LOADED;
        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }
      if (!loaded) {
        covered = false;
      }
    }
  }
  return covered;
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {number} Gutter.
 */
_ol_source_Tile_.prototype.getGutter = function (projection) {
  return 0;
};

/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */
_ol_source_Tile_.prototype.getKey = function () {
  return this.key_;
};

/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */
_ol_source_Tile_.prototype.setKey = function (key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 * @protected
 */
_ol_source_Tile_.prototype.getKeyZXY = _tilecoord2.default.getKeyZXY;

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {boolean} Opaque.
 */
_ol_source_Tile_.prototype.getOpaque = function (projection) {
  return this.opaque_;
};

/**
 * @inheritDoc
 */
_ol_source_Tile_.prototype.getResolutions = function () {
  return this.tileGrid.getResolutions();
};

/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 */
_ol_source_Tile_.prototype.getTile = function (z, x, y, pixelRatio, projection) {};

/**
 * Return the tile grid of the tile source.
 * @return {ol.tilegrid.TileGrid} Tile grid.
 * @api
 */
_ol_source_Tile_.prototype.getTileGrid = function () {
  return this.tileGrid;
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Tile grid.
 */
_ol_source_Tile_.prototype.getTileGridForProjection = function (projection) {
  if (!this.tileGrid) {
    return _tilegrid2.default.getForProjection(projection);
  } else {
    return this.tileGrid;
  }
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCache} Tile cache.
 * @protected
 */
_ol_source_Tile_.prototype.getTileCacheForProjection = function (projection) {
  var thisProj = this.getProjection();
  if (thisProj && !_proj2.default.equivalent(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};

/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `opt_pixelRatio` as close as possible. When no `opt_pixelRatio` is
 * provided, it is meant to return `this.tilePixelRatio_`.
 * @param {number=} opt_pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */
_ol_source_Tile_.prototype.getTilePixelRatio = function (opt_pixelRatio) {
  return this.tilePixelRatio_;
};

/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.Size} Tile size.
 */
_ol_source_Tile_.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
  var tileSize = _size2.default.toSize(tileGrid.getTileSize(z), this.tmpSize);
  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return _size2.default.scale(tileSize, tilePixelRatio, this.tmpSize);
  }
};

/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection=} opt_projection Projection.
 * @return {ol.TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */
_ol_source_Tile_.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);
  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = _tilegrid2.default.wrapX(tileGrid, tileCoord, projection);
  }
  return _tilecoord2.default.withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
};

/**
 * @inheritDoc
 */
_ol_source_Tile_.prototype.refresh = function () {
  this.tileCache.clear();
  this.changed();
};

/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {ol.proj.Projection} projection Projection.
 */
_ol_source_Tile_.prototype.useTile = _index2.default.nullFunction;

/**
 * @classdesc
 * Events emitted by {@link ol.source.Tile} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Tile.Event}
 * @param {string} type Type.
 * @param {ol.Tile} tile The tile.
 */
_ol_source_Tile_.Event = function (type, tile) {

  _event2.default.call(this, type);

  /**
   * The tile related to the event.
   * @type {ol.Tile}
   * @api
   */
  this.tile = tile;
};
_index2.default.inherits(_ol_source_Tile_.Event, _event2.default);
exports.default = _ol_source_Tile_;


},{"../events/event":64,"../index":110,"../proj":158,"../size":217,"../source/source":218,"../tilecache":246,"../tilecoord":247,"../tilegrid":248,"../tilestate":252}],221:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_source_TileEventType_ = {

  /**
   * Triggered when a tile starts loading.
   * @event ol.source.Tile.Event#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading.
   * @event ol.source.Tile.Event#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event ol.source.Tile.Event#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

};

exports.default = _ol_source_TileEventType_;


},{}],222:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _imagetile = require('../imagetile');

var _imagetile2 = _interopRequireDefault(_imagetile);

var _tilecache = require('../tilecache');

var _tilecache2 = _interopRequireDefault(_tilecache);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

var _tile = require('../reproj/tile');

var _tile2 = _interopRequireDefault(_tile);

var _urltile = require('../source/urltile');

var _urltile2 = _interopRequireDefault(_urltile);

var _tilegrid = require('../tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.TileImageOptions} options Image tile options.
 * @api
 */
var _ol_source_TileImage_ = function (options) {

  _urltile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _ol_source_TileImage_.defaultTileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX
  });

  /**
   * @protected
   * @type {?string}
   */
  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @protected
   * @type {function(new: ol.ImageTile, ol.TileCoord, ol.TileState, string,
   *        ?string, ol.TileLoadFunctionType)}
   */
  this.tileClass = options.tileClass !== undefined ? options.tileClass : _imagetile2.default;

  /**
   * @protected
   * @type {Object.<string, ol.TileCache>}
   */
  this.tileCacheForProjection = {};

  /**
   * @protected
   * @type {Object.<string, ol.tilegrid.TileGrid>}
   */
  this.tileGridForProjection = {};

  /**
   * @private
   * @type {number|undefined}
   */
  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

  /**
   * @private
   * @type {boolean}
   */
  this.renderReprojectionEdges_ = false;
};

_index2.default.inherits(_ol_source_TileImage_, _urltile2.default);

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.canExpireCache = function () {
  var this$1 = this;

  if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
    return _urltile2.default.prototype.canExpireCache.call(this);
  }
  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this$1.tileCacheForProjection) {
      if (this$1.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.expireCache = function (projection, usedTiles) {
  var this$1 = this;

  if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
    _urltile2.default.prototype.expireCache.call(this, projection, usedTiles);
    return;
  }
  var usedTileCache = this.getTileCacheForProjection(projection);

  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
  for (var id in this$1.tileCacheForProjection) {
    var tileCache = this$1.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.getGutter = function (projection) {
  if (_index2.default.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !_proj2.default.equivalent(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};

/**
 * @protected
 * @return {number} Gutter.
 */
_ol_source_TileImage_.prototype.getGutterInternal = function () {
  return 0;
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.getOpaque = function (projection) {
  if (_index2.default.ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !_proj2.default.equivalent(this.getProjection(), projection)) {
    return false;
  } else {
    return _urltile2.default.prototype.getOpaque.call(this, projection);
  }
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.getTileGridForProjection = function (projection) {
  if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
    return _urltile2.default.prototype.getTileGridForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (this.tileGrid && (!thisProj || _proj2.default.equivalent(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = _index2.default.getUid(projection).toString();
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = _tilegrid2.default.getForProjection(projection);
    }
    return (/** @type {!ol.tilegrid.TileGrid} */this.tileGridForProjection[projKey]
    );
  }
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.getTileCacheForProjection = function (projection) {
  if (!_index2.default.ENABLE_RASTER_REPROJECTION) {
    return _urltile2.default.prototype.getTileCacheForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (!thisProj || _proj2.default.equivalent(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = _index2.default.getUid(projection).toString();
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new _tilecache2.default(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!ol.Tile} Tile.
 * @private
 */
_ol_source_TileImage_.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _tilestate2.default.IDLE : _tilestate2.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction);
  tile.key = key;
  _events2.default.listen(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);
  return tile;
};

/**
 * @inheritDoc
 */
_ol_source_TileImage_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  if (!_index2.default.ENABLE_RASTER_REPROJECTION || !this.getProjection() || !projection || _proj2.default.equivalent(this.getProjection(), projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, /** @type {!ol.proj.Projection} */projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile;
    var tileCoordKey = this.getKeyZXY.apply(this, tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = /** @type {!ol.Tile} */cache.get(tileCoordKey);
    }
    var key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceProjection = /** @type {!ol.proj.Projection} */this.getProjection();
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new _tile2.default(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function (z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;

      if (tile) {
        newTile.interimTile = tile;
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 * @protected
 */
_ol_source_TileImage_.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
  var tile = null;
  var tileCoordKey = this.getKeyZXY(z, x, y);
  var key = this.getKey();
  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);
    if (tile.key != key) {
      // The source's params changed. If the tile has an interim tile and if we
      // can use it then we use it. Otherwise we create a new tile.  In both
      // cases we attempt to assign an interim tile to the new tile.
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);

      //make the new tile the head of the list,
      if (interimTile.getState() == _tilestate2.default.IDLE) {
        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }
      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }
  return tile;
};

/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */
_ol_source_TileImage_.prototype.setRenderReprojectionEdges = function (render) {
  var this$1 = this;

  if (!_index2.default.ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }
  this.renderReprojectionEdges_ = render;
  for (var id in this$1.tileCacheForProjection) {
    this$1.tileCacheForProjection[id].clear();
  }
  this.changed();
};

/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {ol.ProjectionLike} projection Projection.
 * @param {ol.tilegrid.TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */
_ol_source_TileImage_.prototype.setTileGridForProjection = function (projection, tilegrid) {
  if (_index2.default.ENABLE_RASTER_REPROJECTION) {
    var proj = _proj2.default.get(projection);
    if (proj) {
      var projKey = _index2.default.getUid(proj).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};

/**
 * @param {ol.ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
_ol_source_TileImage_.defaultTileLoadFunction = function (imageTile, src) {
  imageTile.getImage().src = src;
};
exports.default = _ol_source_TileImage_;


},{"../events":62,"../events/eventtype":66,"../imagetile":109,"../index":110,"../proj":158,"../reproj/tile":213,"../source/urltile":224,"../tilecache":246,"../tilegrid":248,"../tilestate":252}],223:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _attribution = require('../attribution');

var _attribution2 = _interopRequireDefault(_attribution);

var _tileurlfunction = require('../tileurlfunction');

var _tileurlfunction2 = _interopRequireDefault(_tileurlfunction);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _net = require('../net');

var _net2 = _interopRequireDefault(_net);

var _proj = require('../proj');

var _proj2 = _interopRequireDefault(_proj);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

var _tileimage = require('../source/tileimage');

var _tileimage2 = _interopRequireDefault(_tileimage);

var _tilegrid = require('../tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Layer source for tile data in TileJSON format.
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.TileJSONOptions} options TileJSON options.
 * @api
 */
var _ol_source_TileJSON_ = function (options) {

  /**
   * @type {TileJSON}
   * @private
   */
  this.tileJSON_ = null;

  _tileimage2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    projection: _proj2.default.get('EPSG:3857'),
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    state: _state2.default.LOADING,
    tileLoadFunction: options.tileLoadFunction,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });

  if (options.jsonp) {
    _net2.default.jsonp(options.url, this.handleTileJSONResponse.bind(this), this.handleTileJSONError.bind(this));
  } else {
    var client = new XMLHttpRequest();
    client.addEventListener('load', this.onXHRLoad_.bind(this));
    client.addEventListener('error', this.onXHRError_.bind(this));
    client.open('GET', options.url);
    client.send();
  }
}; // FIXME check order of async callbacks

/**
 * @see http://mapbox.com/developers/api/
 */

_index2.default.inherits(_ol_source_TileJSON_, _tileimage2.default);

/**
 * @private
 * @param {Event} event The load event.
 */
_ol_source_TileJSON_.prototype.onXHRLoad_ = function (event) {
  var client = /** @type {XMLHttpRequest} */event.target;
  // status will be 0 for file:// urls
  if (!client.status || client.status >= 200 && client.status < 300) {
    var response;
    try {
      response = /** @type {TileJSON} */JSON.parse(client.responseText);
    } catch (err) {
      this.handleTileJSONError();
      return;
    }
    this.handleTileJSONResponse(response);
  } else {
    this.handleTileJSONError();
  }
};

/**
 * @private
 * @param {Event} event The error event.
 */
_ol_source_TileJSON_.prototype.onXHRError_ = function (event) {
  this.handleTileJSONError();
};

/**
 * @return {TileJSON} The tilejson object.
 * @api
 */
_ol_source_TileJSON_.prototype.getTileJSON = function () {
  return this.tileJSON_;
};

/**
 * @protected
 * @param {TileJSON} tileJSON Tile JSON.
 */
_ol_source_TileJSON_.prototype.handleTileJSONResponse = function (tileJSON) {

  var epsg4326Projection = _proj2.default.get('EPSG:4326');

  var sourceProjection = this.getProjection();
  var extent;
  if (tileJSON.bounds !== undefined) {
    var transform = _proj2.default.getTransformFromProjections(epsg4326Projection, sourceProjection);
    extent = _extent2.default.applyTransform(tileJSON.bounds, transform);
  }

  var minZoom = tileJSON.minzoom || 0;
  var maxZoom = tileJSON.maxzoom || 22;
  var tileGrid = _tilegrid2.default.createXYZ({
    extent: _tilegrid2.default.extentFromProjection(sourceProjection),
    maxZoom: maxZoom,
    minZoom: minZoom
  });
  this.tileGrid = tileGrid;

  this.tileUrlFunction = _tileurlfunction2.default.createFromTemplates(tileJSON.tiles, tileGrid);

  if (tileJSON.attribution !== undefined && !this.getAttributions()) {
    var attributionExtent = extent !== undefined ? extent : epsg4326Projection.getExtent();
    /** @type {Object.<string, Array.<ol.TileRange>>} */
    var tileRanges = {};
    var z, zKey;
    for (z = minZoom; z <= maxZoom; ++z) {
      zKey = z.toString();
      tileRanges[zKey] = [tileGrid.getTileRangeForExtentAndZ(attributionExtent, z)];
    }
    this.setAttributions([new _attribution2.default({
      html: tileJSON.attribution,
      tileRanges: tileRanges
    })]);
  }
  this.tileJSON_ = tileJSON;
  this.setState(_state2.default.READY);
};

/**
 * @protected
 */
_ol_source_TileJSON_.prototype.handleTileJSONError = function () {
  this.setState(_state2.default.ERROR);
};
exports.default = _ol_source_TileJSON_;


},{"../attribution":45,"../extent":68,"../index":110,"../net":145,"../proj":158,"../source/state":219,"../source/tileimage":222,"../tilegrid":248,"../tileurlfunction":253}],224:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _tileurlfunction = require('../tileurlfunction');

var _tileurlfunction2 = _interopRequireDefault(_tileurlfunction);

var _tile = require('../source/tile');

var _tile2 = _interopRequireDefault(_tile);

var _tileeventtype = require('../source/tileeventtype');

var _tileeventtype2 = _interopRequireDefault(_tileeventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires ol.source.Tile.Event
 * @extends {ol.source.Tile}
 * @param {ol.SourceUrlTileOptions} options Image tile options.
 */
var _ol_source_UrlTile_ = function (options) {

  _tile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tilePixelRatio: options.tilePixelRatio,
    wrapX: options.wrapX
  });

  /**
   * @protected
   * @type {ol.TileLoadFunctionType}
   */
  this.tileLoadFunction = options.tileLoadFunction;

  /**
   * @protected
   * @type {ol.TileUrlFunctionType}
   */
  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction2.default.nullTileUrlFunction;

  /**
   * @protected
   * @type {!Array.<string>|null}
   */
  this.urls = null;

  if (options.urls) {
    this.setUrls(options.urls);
  } else if (options.url) {
    this.setUrl(options.url);
  }
  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }
};

_index2.default.inherits(_ol_source_UrlTile_, _tile2.default);

/**
 * @type {ol.TileUrlFunctionType|undefined}
 * @protected
 */
_ol_source_UrlTile_.prototype.fixedTileUrlFunction;

/**
 * Return the tile load function of the source.
 * @return {ol.TileLoadFunctionType} TileLoadFunction
 * @api
 */
_ol_source_UrlTile_.prototype.getTileLoadFunction = function () {
  return this.tileLoadFunction;
};

/**
 * Return the tile URL function of the source.
 * @return {ol.TileUrlFunctionType} TileUrlFunction
 * @api
 */
_ol_source_UrlTile_.prototype.getTileUrlFunction = function () {
  return this.tileUrlFunction;
};

/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */
_ol_source_UrlTile_.prototype.getUrls = function () {
  return this.urls;
};

/**
 * Handle tile change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */
_ol_source_UrlTile_.prototype.handleTileChange = function (event) {
  var tile = /** @type {ol.Tile} */event.target;
  switch (tile.getState()) {
    case _tilestate2.default.LOADING:
      this.dispatchEvent(new _tile2.default.Event(_tileeventtype2.default.TILELOADSTART, tile));
      break;
    case _tilestate2.default.LOADED:
      this.dispatchEvent(new _tile2.default.Event(_tileeventtype2.default.TILELOADEND, tile));
      break;
    case _tilestate2.default.ERROR:
      this.dispatchEvent(new _tile2.default.Event(_tileeventtype2.default.TILELOADERROR, tile));
      break;
    default:
    // pass
  }
};

/**
 * Set the tile load function of the source.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @api
 */
_ol_source_UrlTile_.prototype.setTileLoadFunction = function (tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};

/**
 * Set the tile URL function of the source.
 * @param {ol.TileUrlFunctionType} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */
_ol_source_UrlTile_.prototype.setTileUrlFunction = function (tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  if (typeof opt_key !== 'undefined') {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};

/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */
_ol_source_UrlTile_.prototype.setUrl = function (url) {
  var urls = this.urls = _tileurlfunction2.default.expandUrl(url);
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction2.default.createFromTemplates(urls, this.tileGrid), url);
};

/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */
_ol_source_UrlTile_.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : _tileurlfunction2.default.createFromTemplates(urls, this.tileGrid), key);
};

/**
 * @inheritDoc
 */
_ol_source_UrlTile_.prototype.useTile = function (z, x, y) {
  var tileCoordKey = this.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
exports.default = _ol_source_UrlTile_;


},{"../index":110,"../source/tile":220,"../source/tileeventtype":221,"../tilestate":252,"../tileurlfunction":253}],225:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _collection = require('../collection');

var _collection2 = _interopRequireDefault(_collection);

var _collectioneventtype = require('../collectioneventtype');

var _collectioneventtype2 = _interopRequireDefault(_collectioneventtype);

var _objecteventtype = require('../objecteventtype');

var _objecteventtype2 = _interopRequireDefault(_objecteventtype);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _event = require('../events/event');

var _event2 = _interopRequireDefault(_event);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _featureloader = require('../featureloader');

var _featureloader2 = _interopRequireDefault(_featureloader);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

var _loadingstrategy = require('../loadingstrategy');

var _loadingstrategy2 = _interopRequireDefault(_loadingstrategy);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _source = require('../source/source');

var _source2 = _interopRequireDefault(_source);

var _state = require('../source/state');

var _state2 = _interopRequireDefault(_state);

var _vectoreventtype = require('../source/vectoreventtype');

var _vectoreventtype2 = _interopRequireDefault(_vectoreventtype);

var _rbush = require('../structs/rbush');

var _rbush2 = _interopRequireDefault(_rbush);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @constructor
 * @extends {ol.source.Source}
 * @fires ol.source.Vector.Event
 * @param {olx.source.VectorOptions=} opt_options Vector source options.
 * @api
 */
// FIXME bulk feature upload - suppress events
// FIXME make change-detection more refined (notably, geometry hint)

var _ol_source_Vector_ = function (opt_options) {

  var options = opt_options || {};

  _source2.default.call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: undefined,
    state: _state2.default.READY,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });

  /**
   * @private
   * @type {ol.FeatureLoader}
   */
  this.loader_ = _index2.default.nullFunction;

  /**
   * @private
   * @type {ol.format.Feature|undefined}
   */
  this.format_ = options.format;

  /**
   * @private
   * @type {boolean}
   */
  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

  /**
   * @private
   * @type {string|ol.FeatureUrlFunction|undefined}
   */
  this.url_ = options.url;

  if (options.loader !== undefined) {
    this.loader_ = options.loader;
  } else if (this.url_ !== undefined) {
    _asserts2.default.assert(this.format_, 7); // `format` must be set when `url` is set
    // create a XHR feature loader for "url" and "format"
    this.loader_ = _featureloader2.default.xhr(this.url_, /** @type {ol.format.Feature} */this.format_);
  }

  /**
   * @private
   * @type {ol.LoadingStrategy}
   */
  this.strategy_ = options.strategy !== undefined ? options.strategy : _loadingstrategy2.default.all;

  var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

  /**
   * @private
   * @type {ol.structs.RBush.<ol.Feature>}
   */
  this.featuresRtree_ = useSpatialIndex ? new _rbush2.default() : null;

  /**
   * @private
   * @type {ol.structs.RBush.<{extent: ol.Extent}>}
   */
  this.loadedExtentsRtree_ = new _rbush2.default();

  /**
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.nullGeometryFeatures_ = {};

  /**
   * A lookup of features by id (the return from feature.getId()).
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.idIndex_ = {};

  /**
   * A lookup of features without id (keyed by ol.getUid(feature)).
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.undefIdIndex_ = {};

  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */
  this.featureChangeKeys_ = {};

  /**
   * @private
   * @type {ol.Collection.<ol.Feature>}
   */
  this.featuresCollection_ = null;

  var collection, features;
  if (options.features instanceof _collection2.default) {
    collection = options.features;
    features = collection.getArray();
  } else if (Array.isArray(options.features)) {
    features = options.features;
  }
  if (!useSpatialIndex && collection === undefined) {
    collection = new _collection2.default(features);
  }
  if (features !== undefined) {
    this.addFeaturesInternal(features);
  }
  if (collection !== undefined) {
    this.bindFeaturesCollection_(collection);
  }
};

_index2.default.inherits(_ol_source_Vector_, _source2.default);

/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead.
 * @param {ol.Feature} feature Feature to add.
 * @api
 */
_ol_source_Vector_.prototype.addFeature = function (feature) {
  this.addFeatureInternal(feature);
  this.changed();
};

/**
 * Add a feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */
_ol_source_Vector_.prototype.addFeatureInternal = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();

  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }

  this.setupChangeEvents_(featureKey, feature);

  var geometry = feature.getGeometry();
  if (geometry) {
    var extent = geometry.getExtent();
    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }

  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.ADDFEATURE, feature));
};

/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @private
 */
_ol_source_Vector_.prototype.setupChangeEvents_ = function (featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [_events2.default.listen(feature, _eventtype2.default.CHANGE, this.handleFeatureChange_, this), _events2.default.listen(feature, _objecteventtype2.default.PROPERTYCHANGE, this.handleFeatureChange_, this)];
};

/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */
_ol_source_Vector_.prototype.addToIndex_ = function (featureKey, feature) {
  var valid = true;
  var id = feature.getId();
  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    _asserts2.default.assert(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source
    this.undefIdIndex_[featureKey] = feature;
  }
  return valid;
};

/**
 * Add a batch of features to the source.
 * @param {Array.<ol.Feature>} features Features to add.
 * @api
 */
_ol_source_Vector_.prototype.addFeatures = function (features) {
  this.addFeaturesInternal(features);
  this.changed();
};

/**
 * Add features without firing a `change` event.
 * @param {Array.<ol.Feature>} features Features.
 * @protected
 */
_ol_source_Vector_.prototype.addFeaturesInternal = function (features) {
  var this$1 = this;

  var featureKey, i, length, feature;

  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];

  for (i = 0, length = features.length; i < length; i++) {
    feature = features[i];
    featureKey = _index2.default.getUid(feature).toString();
    if (this$1.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    feature = newFeatures[i];
    featureKey = _index2.default.getUid(feature).toString();
    this$1.setupChangeEvents_(featureKey, feature);

    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature);
    } else {
      this$1.nullGeometryFeatures_[featureKey] = feature;
    }
  }
  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    this$1.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.ADDFEATURE, newFeatures[i]));
  }
};

/**
 * @param {!ol.Collection.<ol.Feature>} collection Collection.
 * @private
 */
_ol_source_Vector_.prototype.bindFeaturesCollection_ = function (collection) {
  var modifyingCollection = false;
  _events2.default.listen(this, _vectoreventtype2.default.ADDFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.push(evt.feature);
      modifyingCollection = false;
    }
  });
  _events2.default.listen(this, _vectoreventtype2.default.REMOVEFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.remove(evt.feature);
      modifyingCollection = false;
    }
  });
  _events2.default.listen(collection, _collectioneventtype2.default.ADD, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.addFeature( /** @type {ol.Feature} */evt.element);
      modifyingCollection = false;
    }
  }, this);
  _events2.default.listen(collection, _collectioneventtype2.default.REMOVE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.removeFeature( /** @type {ol.Feature} */evt.element);
      modifyingCollection = false;
    }
  }, this);
  this.featuresCollection_ = collection;
};

/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.
 * @api
 */
_ol_source_Vector_.prototype.clear = function (opt_fast) {
  var this$1 = this;

  if (opt_fast) {
    for (var featureId in this$1.featureChangeKeys_) {
      var keys = this$1.featureChangeKeys_[featureId];
      keys.forEach(_events2.default.unlistenByKey);
    }
    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);
      for (var id in this$1.nullGeometryFeatures_) {
        this$1.removeFeatureInternal(this$1.nullGeometryFeatures_[id]);
      }
    }
  }
  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }
  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};

  var clearEvent = new _ol_source_Vector_.Event(_vectoreventtype2.default.CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};

/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 *
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
_ol_source_Vector_.prototype.forEachFeature = function (callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};

/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 */
_ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback, opt_this) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function (feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsCoordinate(coordinate)) {
      return callback.call(opt_this, feature);
    } else {
      return undefined;
    }
  });
};

/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link ol.source.Vector#forEachFeature}.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
_ol_source_Vector_.prototype.forEachFeatureInExtent = function (extent, callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};

/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
_ol_source_Vector_.prototype.forEachFeatureIntersectingExtent = function (extent, callback, opt_this) {
  return this.forEachFeatureInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   * @return {S|undefined} The return value from the last call to the callback.
   * @template S
   */
  function (feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsExtent(extent)) {
      var result = callback.call(opt_this, feature);
      if (result) {
        return result;
      }
    }
  });
};

/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link ol.Collection} as `features`.
 * @return {ol.Collection.<ol.Feature>} The collection of features.
 * @api
 */
_ol_source_Vector_.prototype.getFeaturesCollection = function () {
  return this.featuresCollection_;
};

/**
 * Get all features on the source in random order.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
_ol_source_Vector_.prototype.getFeatures = function () {
  var features;
  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else if (this.featuresRtree_) {
    features = this.featuresRtree_.getAll();
    if (!_obj2.default.isEmpty(this.nullGeometryFeatures_)) {
      _array2.default.extend(features, _obj2.default.getValues(this.nullGeometryFeatures_));
    }
  }
  return (/** @type {Array.<ol.Feature>} */features
  );
};

/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
_ol_source_Vector_.prototype.getFeaturesAtCoordinate = function (coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
    features.push(feature);
  });
  return features;
};

/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
_ol_source_Vector_.prototype.getFeaturesInExtent = function (extent) {
  return this.featuresRtree_.getInExtent(extent);
};

/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {ol.Feature} Closest feature.
 * @api
 */
_ol_source_Vector_.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
  // Find the closest feature using branch and bound.  We start searching an
  // infinite extent, and find the distance from the first feature found.  This
  // becomes the closest feature.  We then compute a smaller extent which any
  // closer feature must intersect.  We continue searching with this smaller
  // extent, trying to find a closer feature.  Every time we find a closer
  // feature, we update the extent being searched so that any even closer
  // feature must intersect it.  We continue until we run out of features.
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : _functions2.default.TRUE;
  this.featuresRtree_.forEachInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   */
  function (feature) {
    if (filter(feature)) {
      var geometry = feature.getGeometry();
      var previousMinSquaredDistance = minSquaredDistance;
      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
      if (minSquaredDistance < previousMinSquaredDistance) {
        closestFeature = feature;
        // This is sneaky.  Reduce the extent that it is currently being
        // searched while the R-Tree traversal using this same extent object
        // is still in progress.  This is safe because the new extent is
        // strictly contained by the old extent.
        var minDistance = Math.sqrt(minSquaredDistance);
        extent[0] = x - minDistance;
        extent[1] = y - minDistance;
        extent[2] = x + minDistance;
        extent[3] = y + minDistance;
      }
    }
  });
  return closestFeature;
};

/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {!ol.Extent} Extent.
 * @api
 */
_ol_source_Vector_.prototype.getExtent = function (opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};

/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {ol.Feature} The feature (or `null` if not found).
 * @api
 */
_ol_source_Vector_.prototype.getFeatureById = function (id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};

/**
 * Get the format associated with this source.
 *
 * @return {ol.format.Feature|undefined} The feature format.
 * @api
 */
_ol_source_Vector_.prototype.getFormat = function () {
  return this.format_;
};

/**
 * @return {boolean} The source can have overlapping geometries.
 */
_ol_source_Vector_.prototype.getOverlaps = function () {
  return this.overlaps_;
};

/**
 * @override
 */
_ol_source_Vector_.prototype.getResolutions = function () {};

/**
 * Get the url associated with this source.
 *
 * @return {string|ol.FeatureUrlFunction|undefined} The url.
 * @api
 */
_ol_source_Vector_.prototype.getUrl = function () {
  return this.url_;
};

/**
 * @param {ol.events.Event} event Event.
 * @private
 */
_ol_source_Vector_.prototype.handleFeatureChange_ = function (event) {
  var feature = /** @type {ol.Feature} */event.target;
  var featureKey = _index2.default.getUid(feature).toString();
  var geometry = feature.getGeometry();
  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }
  var id = feature.getId();
  if (id !== undefined) {
    var sid = id.toString();
    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }
  this.changed();
  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.CHANGEFEATURE, feature));
};

/**
 * @return {boolean} Is empty.
 */
_ol_source_Vector_.prototype.isEmpty = function () {
  return this.featuresRtree_.isEmpty() && _obj2.default.isEmpty(this.nullGeometryFeatures_);
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 */
_ol_source_Vector_.prototype.loadFeatures = function (extent, resolution, projection) {
  var this$1 = this;

  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var i, ii;
  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
    /**
     * @param {{extent: ol.Extent}} object Object.
     * @return {boolean} Contains.
     */
    function (object) {
      return _extent2.default.containsExtent(object.extent, extentToLoad);
    });
    if (!alreadyLoaded) {
      this$1.loader_.call(this$1, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
    }
  }
};

/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link ol.source.Vector#clear source.clear()} method
 * instead.
 * @param {ol.Feature} feature Feature to remove.
 * @api
 */
_ol_source_Vector_.prototype.removeFeature = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();
  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }
  this.removeFeatureInternal(feature);
  this.changed();
};

/**
 * Remove feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */
_ol_source_Vector_.prototype.removeFeatureInternal = function (feature) {
  var featureKey = _index2.default.getUid(feature).toString();
  this.featureChangeKeys_[featureKey].forEach(_events2.default.unlistenByKey);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();
  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }
  this.dispatchEvent(new _ol_source_Vector_.Event(_vectoreventtype2.default.REMOVEFEATURE, feature));
};

/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */
_ol_source_Vector_.prototype.removeFromIdIndex_ = function (feature) {
  var this$1 = this;

  var removed = false;
  for (var id in this$1.idIndex_) {
    if (this$1.idIndex_[id] === feature) {
      delete this$1.idIndex_[id];
      removed = true;
      break;
    }
  }
  return removed;
};

/**
 * @classdesc
 * Events emitted by {@link ol.source.Vector} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Vector.Event}
 * @param {string} type Type.
 * @param {ol.Feature=} opt_feature Feature.
 */
_ol_source_Vector_.Event = function (type, opt_feature) {

  _event2.default.call(this, type);

  /**
   * The feature being added or removed.
   * @type {ol.Feature|undefined}
   * @api
   */
  this.feature = opt_feature;
};
_index2.default.inherits(_ol_source_Vector_.Event, _event2.default);
exports.default = _ol_source_Vector_;


},{"../array":42,"../asserts":44,"../collection":47,"../collectioneventtype":48,"../events":62,"../events/event":64,"../events/eventtype":66,"../extent":68,"../featureloader":72,"../functions":78,"../index":110,"../loadingstrategy":135,"../obj":146,"../objecteventtype":148,"../source/source":218,"../source/state":219,"../source/vectoreventtype":226,"../structs/rbush":236}],226:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_source_VectorEventType_ = {
  /**
   * Triggered when a feature is added to the source.
   * @event ol.source.Vector.Event#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol.source.Vector.Event#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol.source.Vector.Event#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link ol.source.Vector#clear source.clear()} for exceptions.
   * @event ol.source.Vector.Event#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
};

exports.default = _ol_source_VectorEventType_;


},{}],227:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _tilestate = require('../tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _vectortile = require('../vectortile');

var _vectortile2 = _interopRequireDefault(_vectortile);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('../events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _size = require('../size');

var _size2 = _interopRequireDefault(_size);

var _urltile = require('../source/urltile');

var _urltile2 = _interopRequireDefault(_urltile);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Class for layer sources providing vector data divided into a tile grid, to be
 * used with {@link ol.layer.VectorTile}. Although this source receives tiles
 * with vector features from the server, it is not meant for feature editing.
 * Features are optimized for rendering, their geometries are clipped at or near
 * tile boundaries and simplified for a view resolution. See
 * {@link ol.source.Vector} for vector sources that are suitable for feature
 * editing.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.VectorTileOptions} options Vector tile options.
 * @api
 */
var _ol_source_VectorTile_ = function (options) {

  _urltile2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize !== undefined ? options.cacheSize : 128,
    extent: options.extent,
    logo: options.logo,
    opaque: false,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _vectortile2.default.defaultLoadFunction,
    tileUrlFunction: options.tileUrlFunction,
    tilePixelRatio: options.tilePixelRatio,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX === undefined ? true : options.wrapX
  });

  /**
   * @private
   * @type {ol.format.Feature}
   */
  this.format_ = options.format ? options.format : null;

  /**
   * @private
   * @type {boolean}
   */
  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

  /**
   * @protected
   * @type {function(new: ol.VectorTile, ol.TileCoord, ol.TileState, string,
   *        ol.format.Feature, ol.TileLoadFunctionType)}
   */
  this.tileClass = options.tileClass ? options.tileClass : _vectortile2.default;
};

_index2.default.inherits(_ol_source_VectorTile_, _urltile2.default);

/**
 * @return {boolean} The source can have overlapping geometries.
 */
_ol_source_VectorTile_.prototype.getOverlaps = function () {
  return this.overlaps_;
};

/**
 * @inheritDoc
 */
_ol_source_VectorTile_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var tileCoordKey = this.getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    return (/** @type {!ol.Tile} */this.tileCache.get(tileCoordKey)
    );
  } else {
    var tileCoord = [z, x, y];
    var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
    var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
    var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? _tilestate2.default.IDLE : _tilestate2.default.EMPTY, tileUrl !== undefined ? tileUrl : '', this.format_, this.tileLoadFunction);
    _events2.default.listen(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);

    this.tileCache.set(tileCoordKey, tile);
    return tile;
  }
};

/**
 * @inheritDoc
 */
_ol_source_VectorTile_.prototype.getTilePixelRatio = function (opt_pixelRatio) {
  return opt_pixelRatio == undefined ? _urltile2.default.prototype.getTilePixelRatio.call(this, opt_pixelRatio) : opt_pixelRatio;
};

/**
 * @inheritDoc
 */
_ol_source_VectorTile_.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileSize = _size2.default.toSize(this.tileGrid.getTileSize(z));
  return [Math.round(tileSize[0] * pixelRatio), Math.round(tileSize[1] * pixelRatio)];
};
exports.default = _ol_source_VectorTile_;


},{"../events":62,"../events/eventtype":66,"../index":110,"../size":217,"../source/urltile":224,"../tilestate":252,"../vectortile":256}],228:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _tileimage = require('../source/tileimage');

var _tileimage2 = _interopRequireDefault(_tileimage);

var _tilegrid = require('../tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link ol.source.TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.XYZOptions=} opt_options XYZ options.
 * @api
 */
var _ol_source_XYZ_ = function (opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';

  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : _tilegrid2.default.createXYZ({
    extent: _tilegrid2.default.extentFromProjection(projection),
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileSize: options.tileSize
  });

  _tileimage2.default.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    opaque: options.opaque,
    projection: projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });
};

_index2.default.inherits(_ol_source_XYZ_, _tileimage2.default);
exports.default = _ol_source_XYZ_;


},{"../index":110,"../source/tileimage":222,"../tilegrid":248}],229:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Class to create objects that can be used with {@link
 * ol.geom.Polygon.circular}.
 *
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 *
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 *
 * @constructor
 * @param {number} radius Radius.
 * @api
 */
var _ol_Sphere_ = function (radius) {

  /**
   * @type {number}
   */
  this.radius = radius;
};

/**
 * Returns the geodesic area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @return {number} Area.
 * @api
 */
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */

_ol_Sphere_.prototype.geodesicArea = function (coordinates) {
  var area = 0,
      len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0],
        y2 = coordinates[i][1];
    area += _math2.default.toRadians(x2 - x1) * (2 + Math.sin(_math2.default.toRadians(y1)) + Math.sin(_math2.default.toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * this.radius * this.radius / 2.0;
};

/**
 * Returns the distance from c1 to c2 using the haversine formula.
 *
 * @param {ol.Coordinate} c1 Coordinate 1.
 * @param {ol.Coordinate} c2 Coordinate 2.
 * @return {number} Haversine distance.
 * @api
 */
_ol_Sphere_.prototype.haversineDistance = function (c1, c2) {
  var lat1 = _math2.default.toRadians(c1[1]);
  var lat2 = _math2.default.toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = _math2.default.toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * this.radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @return {ol.Coordinate} The target point.
 */
_ol_Sphere_.prototype.offset = function (c1, distance, bearing) {
  var lat1 = _math2.default.toRadians(c1[1]);
  var lon1 = _math2.default.toRadians(c1[0]);
  var dByR = distance / this.radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [_math2.default.toDegrees(lon), _math2.default.toDegrees(lat)];
};
exports.default = _ol_Sphere_;


},{"./math":144}],230:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sphere = require('../sphere');

var _sphere2 = _interopRequireDefault(_sphere);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * The normal sphere.
 * @const
 * @type {ol.Sphere}
 */
var _ol_sphere_NORMAL_ = new _sphere2.default(6370997);

exports.default = _ol_sphere_NORMAL_;


},{"../sphere":229}],231:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _sphere = require('../sphere');

var _sphere2 = _interopRequireDefault(_sphere);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * A sphere with radius equal to the semi-major axis of the WGS84 ellipsoid.
 * @const
 * @type {ol.Sphere}
 */
var _ol_sphere_WGS84_ = new _sphere2.default(6378137);

exports.default = _ol_sphere_WGS84_;


},{"../sphere":229}],232:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_string_ = {};

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
*/
_ol_string_.padNumber = function (number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
};

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
_ol_string_.compareVersions = function (v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
};
exports.default = _ol_string_;


},{}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Creates an empty linked list structure.
 *
 * @constructor
 * @struct
 * @param {boolean=} opt_circular The last item is connected to the first one,
 * and the first item to the last one. Default is true.
 */
var _ol_structs_LinkedList_ = function (opt_circular) {

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.first_ = undefined;

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.last_ = undefined;

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.head_ = undefined;

  /**
   * @private
   * @type {boolean}
   */
  this.circular_ = opt_circular === undefined ? true : opt_circular;

  /**
   * @private
   * @type {number}
   */
  this.length_ = 0;
};

/**
 * Inserts an item into the linked list right after the current one.
 *
 * @param {?} data Item data.
 */
_ol_structs_LinkedList_.prototype.insertItem = function (data) {

  /** @type {ol.LinkedListItem} */
  var item = {
    prev: undefined,
    next: undefined,
    data: data
  };

  var head = this.head_;

  //Initialize the list.
  if (!head) {
    this.first_ = item;
    this.last_ = item;
    if (this.circular_) {
      item.next = item;
      item.prev = item;
    }
  } else {
    //Link the new item to the adjacent ones.
    var next = head.next;
    item.prev = head;
    item.next = next;
    head.next = item;
    if (next) {
      next.prev = item;
    }

    if (head === this.last_) {
      this.last_ = item;
    }
  }
  this.head_ = item;
  this.length_++;
};

/**
 * Removes the current item from the list. Sets the cursor to the next item,
 * if possible.
 */
_ol_structs_LinkedList_.prototype.removeItem = function () {
  var head = this.head_;
  if (head) {
    var next = head.next;
    var prev = head.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    this.head_ = next || prev;

    if (this.first_ === this.last_) {
      this.head_ = undefined;
      this.first_ = undefined;
      this.last_ = undefined;
    } else if (this.first_ === head) {
      this.first_ = this.head_;
    } else if (this.last_ === head) {
      this.last_ = prev ? this.head_.prev : this.head_;
    }
    this.length_--;
  }
};

/**
 * Sets the cursor to the first item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.firstItem = function () {
  this.head_ = this.first_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
* Sets the cursor to the last item, and returns the associated data.
*
* @return {?} Item data.
*/
_ol_structs_LinkedList_.prototype.lastItem = function () {
  this.head_ = this.last_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
 * Sets the cursor to the next item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.nextItem = function () {
  if (this.head_ && this.head_.next) {
    this.head_ = this.head_.next;
    return this.head_.data;
  }
  return undefined;
};

/**
 * Returns the next item's data without moving the cursor.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getNextItem = function () {
  if (this.head_ && this.head_.next) {
    return this.head_.next.data;
  }
  return undefined;
};

/**
 * Sets the cursor to the previous item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.prevItem = function () {
  if (this.head_ && this.head_.prev) {
    this.head_ = this.head_.prev;
    return this.head_.data;
  }
  return undefined;
};

/**
 * Returns the previous item's data without moving the cursor.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getPrevItem = function () {
  if (this.head_ && this.head_.prev) {
    return this.head_.prev.data;
  }
  return undefined;
};

/**
 * Returns the current item's data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getCurrItem = function () {
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
 * Sets the first item of the list. This only works for circular lists, and sets
 * the last item accordingly.
 */
_ol_structs_LinkedList_.prototype.setFirstItem = function () {
  if (this.circular_ && this.head_) {
    this.first_ = this.head_;
    this.last_ = this.head_.prev;
  }
};

/**
 * Concatenates two lists.
 * @param {ol.structs.LinkedList} list List to merge into the current list.
 */
_ol_structs_LinkedList_.prototype.concat = function (list) {
  if (list.head_) {
    if (this.head_) {
      var end = this.head_.next;
      this.head_.next = list.first_;
      list.first_.prev = this.head_;
      end.prev = list.last_;
      list.last_.next = end;
      this.length_ += list.length_;
    } else {
      this.head_ = list.head_;
      this.first_ = list.first_;
      this.last_ = list.last_;
      this.length_ = list.length_;
    }
    list.head_ = undefined;
    list.first_ = undefined;
    list.last_ = undefined;
    list.length_ = 0;
  }
};

/**
 * Returns the current length of the list.
 *
 * @return {number} Length.
 */
_ol_structs_LinkedList_.prototype.getLength = function () {
  return this.length_;
};
exports.default = _ol_structs_LinkedList_;


},{}],234:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @struct
 * @template T
 */
var _ol_structs_LRUCache_ = function () {

  /**
   * @private
   * @type {number}
   */
  this.count_ = 0;

  /**
   * @private
   * @type {!Object.<string, ol.LRUCacheEntry>}
   */
  this.entries_ = {};

  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */
  this.oldest_ = null;

  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */
  this.newest_ = null;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_LRUCache_.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
};

/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */
_ol_structs_LRUCache_.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};

/**
 * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */
_ol_structs_LRUCache_.prototype.forEach = function (f, opt_this) {
  var this$1 = this;

  var entry = this.oldest_;
  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this$1);
    entry = entry.newer;
  }
};

/**
 * @param {string} key Key.
 * @return {T} Value.
 */
_ol_structs_LRUCache_.prototype.get = function (key) {
  var entry = this.entries_[key];
  _asserts2.default.assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {ol.LRUCacheEntry} */this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};

/**
 * @return {number} Count.
 */
_ol_structs_LRUCache_.prototype.getCount = function () {
  return this.count_;
};

/**
 * @return {Array.<string>} Keys.
 */
_ol_structs_LRUCache_.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }
  return keys;
};

/**
 * @return {Array.<T>} Values.
 */
_ol_structs_LRUCache_.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }
  return values;
};

/**
 * @return {T} Last value.
 */
_ol_structs_LRUCache_.prototype.peekLast = function () {
  return this.oldest_.value_;
};

/**
 * @return {string} Last key.
 */
_ol_structs_LRUCache_.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};

/**
 * @return {T} value Value.
 */
_ol_structs_LRUCache_.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];
  if (entry.newer) {
    entry.newer.older = null;
  }
  this.oldest_ = /** @type {ol.LRUCacheEntry} */entry.newer;
  if (!this.oldest_) {
    this.newest_ = null;
  }
  --this.count_;
  return entry.value_;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
_ol_structs_LRUCache_.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`
  this.entries_[key].value_ = value;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
_ol_structs_LRUCache_.prototype.set = function (key, value) {
  _asserts2.default.assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
  var entry = /** @type {ol.LRUCacheEntry} */{
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };
  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }
  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};
exports.default = _ol_structs_LRUCache_;


},{"../asserts":44}],235:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py
 *
 * @constructor
 * @param {function(T): number} priorityFunction Priority function.
 * @param {function(T): string} keyFunction Key function.
 * @struct
 * @template T
 */
var _ol_structs_PriorityQueue_ = function (priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array.<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array.<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {Object.<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};
};

/**
 * @const
 * @type {number}
 */
_ol_structs_PriorityQueue_.DROP = Infinity;

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_PriorityQueue_.prototype.clear = function () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  _obj2.default.clear(this.queuedElements_);
};

/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
_ol_structs_PriorityQueue_.prototype.dequeue = function () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};

/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
_ol_structs_PriorityQueue_.prototype.enqueue = function (element) {
  _asserts2.default.assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != _ol_structs_PriorityQueue_.DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};

/**
 * @return {number} Count.
 */
_ol_structs_PriorityQueue_.prototype.getCount = function () {
  return this.elements_.length;
};

/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getLeftChildIndex_ = function (index) {
  return index * 2 + 1;
};

/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getRightChildIndex_ = function (index) {
  return index * 2 + 2;
};

/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getParentIndex_ = function (index) {
  return index - 1 >> 1;
};

/**
 * Make this a heap. O(N).
 * @private
 */
_ol_structs_PriorityQueue_.prototype.heapify_ = function () {
  var this$1 = this;

  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this$1.siftUp_(i);
  }
};

/**
 * @return {boolean} Is empty.
 */
_ol_structs_PriorityQueue_.prototype.isEmpty = function () {
  return this.elements_.length === 0;
};

/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
_ol_structs_PriorityQueue_.prototype.isKeyQueued = function (key) {
  return key in this.queuedElements_;
};

/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
_ol_structs_PriorityQueue_.prototype.isQueued = function (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};

/**
 * @param {number} index The index of the node to move down.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.siftUp_ = function (index) {
  var this$1 = this;

  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < count >> 1) {
    var lIndex = this$1.getLeftChildIndex_(index);
    var rIndex = this$1.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};

/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.siftDown_ = function (startIndex, index) {
  var this$1 = this;

  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this$1.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_PriorityQueue_.prototype.reprioritize = function () {
  var this$1 = this;

  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == _ol_structs_PriorityQueue_.DROP) {
      delete this$1.queuedElements_[this$1.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};
exports.default = _ol_structs_PriorityQueue_;


},{"../asserts":44,"../obj":146}],236:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _rbush = require('rbush');

var _rbush2 = _interopRequireDefault(_rbush);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */
var _ol_structs_RBush_ = function (opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = (0, _rbush2.default)(opt_maxEntries);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, ol.RBushEntry>}
   */
  this.items_ = {};
};

/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */
_ol_structs_RBush_.prototype.insert = function (extent, value) {
  /** @type {ol.RBushEntry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[_index2.default.getUid(value)] = item;
};

/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */
_ol_structs_RBush_.prototype.load = function (extents, values) {
  var this$1 = this;

  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {ol.RBushEntry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this$1.items_[_index2.default.getUid(value)] = item;
  }
  this.rbush_.load(items);
};

/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
_ol_structs_RBush_.prototype.remove = function (value) {
  var uid = _index2.default.getUid(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};

/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */
_ol_structs_RBush_.prototype.update = function (extent, value) {
  var item = this.items_[_index2.default.getUid(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!_extent2.default.equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};

/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */
_ol_structs_RBush_.prototype.getAll = function () {
  var items = this.rbush_.all();
  return items.map(function (item) {
    return item.value;
  });
};

/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */
_ol_structs_RBush_.prototype.getInExtent = function (extent) {
  /** @type {ol.RBushEntry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function (item) {
    return item.value;
  });
};

/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEach = function (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};

/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEachInExtent = function (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};

/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEach_ = function (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};

/**
 * @return {boolean} Is empty.
 */
_ol_structs_RBush_.prototype.isEmpty = function () {
  return _obj2.default.isEmpty(this.items_);
};

/**
 * Remove all values from the RBush.
 */
_ol_structs_RBush_.prototype.clear = function () {
  this.rbush_.clear();
  this.items_ = {};
};

/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {!ol.Extent} Extent.
 */
_ol_structs_RBush_.prototype.getExtent = function (opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return _extent2.default.createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};
exports.default = _ol_structs_RBush_;


},{"../extent":68,"../index":110,"../obj":146,"rbush":272}],237:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _iconimagecache = require('./style/iconimagecache');

var _iconimagecache2 = _interopRequireDefault(_iconimagecache);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_style_ = {};

_ol_style_.iconImageCache = new _iconimagecache2.default();
exports.default = _ol_style_;


},{"./style/iconimagecache":240}],238:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _regularshape = require('../style/regularshape');

var _regularshape2 = _interopRequireDefault(_regularshape);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */
var _ol_style_Circle_ = function (opt_options) {

  var options = opt_options || {};

  _regularshape2.default.call(this, {
    points: Infinity,
    fill: options.fill,
    radius: options.radius,
    snapToPixel: options.snapToPixel,
    stroke: options.stroke,
    atlasManager: options.atlasManager
  });
};

_index2.default.inherits(_ol_style_Circle_, _regularshape2.default);

/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */
_ol_style_Circle_.prototype.clone = function () {
  var style = new _ol_style_Circle_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    radius: this.getRadius(),
    snapToPixel: this.getSnapToPixel(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */
_ol_style_Circle_.prototype.setRadius = function (radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};
exports.default = _ol_style_Circle_;


},{"../index":110,"../style/regularshape":242}],239:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _color = require('../color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */
var _ol_style_Fill_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */
_ol_style_Fill_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Fill_({
    color: color && color.slice ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Fill_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Fill_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Fill_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = _index2.default.getUid(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? _color2.default.asString(this.color_) : '-');
    }
  }

  return this.checksum_;
};
exports.default = _ol_style_Fill_;


},{"../color":49,"../index":110}],240:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _color = require('../color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 */
var _ol_style_IconImageCache_ = function () {

  /**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */
  this.cache_ = {};

  /**
   * @type {number}
   * @private
   */
  this.cacheSize_ = 0;

  /**
   * @const
   * @type {number}
   * @private
   */
  this.maxCacheSize_ = 32;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */
_ol_style_IconImageCache_.getKey = function (src, crossOrigin, color) {
  var colorString = color ? _color2.default.asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.clear = function () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.expire = function () {
  var this$1 = this;

  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;
    for (key in this$1.cache_) {
      iconImage = this$1.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this$1.cache_[key];
        --this$1.cacheSize_;
      }
    }
  }
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */
_ol_style_IconImageCache_.prototype.get = function (src, crossOrigin, color) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */
_ol_style_IconImageCache_.prototype.set = function (src, crossOrigin, color, iconImage) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};
exports.default = _ol_style_IconImageCache_;


},{"../color":49}],241:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */
var _ol_style_Image_ = function (options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

  /**
   * @private
   * @type {boolean}
   */
  this.snapToPixel_ = options.snapToPixel;
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
_ol_style_Image_.prototype.getOpacity = function () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
_ol_style_Image_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
_ol_style_Image_.prototype.getRotation = function () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
_ol_style_Image_.prototype.getScale = function () {
  return this.scale_;
};

/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */
_ol_style_Image_.prototype.getSnapToPixel = function () {
  return this.snapToPixel_;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */
_ol_style_Image_.prototype.getAnchor = function () {};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getImage = function (pixelRatio) {};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getHitDetectionImage = function (pixelRatio) {};

/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */
_ol_style_Image_.prototype.getImageState = function () {};

/**
 * @abstract
 * @return {ol.Size} Image size.
 */
_ol_style_Image_.prototype.getImageSize = function () {};

/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */
_ol_style_Image_.prototype.getHitDetectionImageSize = function () {};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */
_ol_style_Image_.prototype.getOrigin = function () {};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */
_ol_style_Image_.prototype.getSize = function () {};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
_ol_style_Image_.prototype.setOpacity = function (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */
_ol_style_Image_.prototype.setRotateWithView = function (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
_ol_style_Image_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};

/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
_ol_style_Image_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};

/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */
_ol_style_Image_.prototype.setSnapToPixel = function (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */
_ol_style_Image_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * Load not yet loaded URI.
 * @abstract
 */
_ol_style_Image_.prototype.load = function () {};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
_ol_style_Image_.prototype.unlistenImageChange = function (listener, thisArg) {};
exports.default = _ol_style_Image_;


},{}],242:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _colorlike = require('../colorlike');

var _colorlike2 = _interopRequireDefault(_colorlike);

var _dom = require('../dom');

var _dom2 = _interopRequireDefault(_dom);

var _has = require('../has');

var _has2 = _interopRequireDefault(_has);

var _imagestate = require('../imagestate');

var _imagestate2 = _interopRequireDefault(_imagestate);

var _canvas = require('../render/canvas');

var _canvas2 = _interopRequireDefault(_canvas);

var _image = require('../style/image');

var _image2 = _interopRequireDefault(_image);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */
var _ol_style_RegularShape_ = function (options) {
  /**
   * @private
   * @type {Array.<string>}
   */
  this.checksums_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.hitDetectionCanvas_ = null;

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.origin_ = [0, 0];

  /**
   * @private
   * @type {number}
   */
  this.points_ = options.points;

  /**
   * @protected
   * @type {number}
   */
  this.radius_ = /** @type {number} */options.radius !== undefined ? options.radius : options.radius1;

  /**
   * @private
   * @type {number}
   */
  this.radius2_ = options.radius2 !== undefined ? options.radius2 : this.radius_;

  /**
   * @private
   * @type {number}
   */
  this.angle_ = options.angle !== undefined ? options.angle : 0;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.imageSize_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.hitDetectionImageSize_ = null;

  /**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */
  this.atlasManager_ = options.atlasManager;

  this.render_(this.atlasManager_);

  /**
   * @type {boolean}
   */
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  /**
   * @type {boolean}
   */
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  _image2.default.call(this, {
    opacity: 1,
    rotateWithView: rotateWithView,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: 1,
    snapToPixel: snapToPixel
  });
};

_index2.default.inherits(_ol_style_RegularShape_, _image2.default);

/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */
_ol_style_RegularShape_.prototype.clone = function () {
  var style = new _ol_style_RegularShape_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    points: this.getRadius2() !== this.getRadius() ? this.getPoints() / 2 : this.getPoints(),
    radius: this.getRadius(),
    radius2: this.getRadius2(),
    angle: this.getAngle(),
    snapToPixel: this.getSnapToPixel(),
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getAnchor = function () {
  return this.anchor_;
};

/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */
_ol_style_RegularShape_.prototype.getAngle = function () {
  return this.angle_;
};

/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_RegularShape_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.hitDetectionCanvas_;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getImageSize = function () {
  return this.imageSize_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getHitDetectionImageSize = function () {
  return this.hitDetectionImageSize_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.getImageState = function () {
  return _imagestate2.default.LOADED;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getOrigin = function () {
  return this.origin_;
};

/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */
_ol_style_RegularShape_.prototype.getPoints = function () {
  return this.points_;
};

/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */
_ol_style_RegularShape_.prototype.getRadius = function () {
  return this.radius_;
};

/**
 * Get the secondary radius for the shape.
 * @return {number} Radius2.
 * @api
 */
_ol_style_RegularShape_.prototype.getRadius2 = function () {
  return this.radius2_;
};

/**
 * @inheritDoc
 * @api
 */
_ol_style_RegularShape_.prototype.getSize = function () {
  return this.size_;
};

/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_RegularShape_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.load = function () {};

/**
 * @inheritDoc
 */
_ol_style_RegularShape_.prototype.unlistenImageChange = function (listener, thisArg) {};

/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */
_ol_style_RegularShape_.prototype.render_ = function (atlasManager) {
  var imageSize;
  var lineCap = '';
  var lineJoin = '';
  var miterLimit = 0;
  var lineDash = null;
  var strokeStyle;
  var strokeWidth = 0;

  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();
    if (strokeStyle === null) {
      strokeStyle = _canvas2.default.defaultStrokeStyle;
    }
    strokeStyle = _colorlike2.default.asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();
    if (strokeWidth === undefined) {
      strokeWidth = _canvas2.default.defaultLineWidth;
    }
    lineDash = this.stroke_.getLineDash();
    if (!_has2.default.CANVAS_LINE_DASH) {
      lineDash = null;
    }
    lineJoin = this.stroke_.getLineJoin();
    if (lineJoin === undefined) {
      lineJoin = _canvas2.default.defaultLineJoin;
    }
    lineCap = this.stroke_.getLineCap();
    if (lineCap === undefined) {
      lineCap = _canvas2.default.defaultLineCap;
    }
    miterLimit = this.stroke_.getMiterLimit();
    if (miterLimit === undefined) {
      miterLimit = _canvas2.default.defaultMiterLimit;
    }
  }

  var size = 2 * (this.radius_ + strokeWidth) + 1;

  /** @type {ol.RegularShapeRenderOptions} */
  var renderOptions = {
    strokeStyle: strokeStyle,
    strokeWidth: strokeWidth,
    size: size,
    lineCap: lineCap,
    lineDash: lineDash,
    lineJoin: lineJoin,
    miterLimit: miterLimit
  };

  if (atlasManager === undefined) {
    // no atlas manager is used, create a new canvas
    var context = _dom2.default.createCanvasContext2D(size, size);
    this.canvas_ = context.canvas;

    // canvas.width and height are rounded to the closest integer
    size = this.canvas_.width;
    imageSize = size;

    this.draw_(renderOptions, context, 0, 0);

    this.createHitDetectionCanvas_(renderOptions);
  } else {
    // an atlas manager is used, add the symbol to an atlas
    size = Math.round(size);

    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;
    if (hasCustomHitDetectionImage) {
      // render the hit-detection image into a separate atlas image
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }

    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);

    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;

    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }

  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
_ol_style_RegularShape_.prototype.draw_ = function (renderOptions, context, x, y) {
  var this$1 = this;

  var i, angle0, radiusC;
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  if (this.points_ === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    if (this.radius2_ !== this.radius_) {
      this.points_ = 2 * this.points_;
    }
    for (i = 0; i <= this.points_; i++) {
      angle0 = i * 2 * Math.PI / this$1.points_ - Math.PI / 2 + this$1.angle_;
      radiusC = i % 2 === 0 ? this$1.radius_ : this$1.radius2_;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  if (this.fill_) {
    var color = this.fill_.getColor();
    if (color === null) {
      color = _canvas2.default.defaultFillStyle;
    }
    context.fillStyle = _colorlike2.default.asColorLike(color);
    context.fill();
  }
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
    }
    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }
  context.closePath();
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */
_ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function (renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  }

  // if no fill style is set, create an extra hit-detection image with a
  // default fill style
  var context = _dom2.default.createCanvasContext2D(renderOptions.size, renderOptions.size);
  this.hitDetectionCanvas_ = context.canvas;

  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
_ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
  var this$1 = this;

  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  if (this.points_ === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    if (this.radius2_ !== this.radius_) {
      this.points_ = 2 * this.points_;
    }
    var i, radiusC, angle0;
    for (i = 0; i <= this.points_; i++) {
      angle0 = i * 2 * Math.PI / this$1.points_ - Math.PI / 2 + this$1.angle_;
      radiusC = i % 2 === 0 ? this$1.radius_ : this$1.radius2_;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  context.fillStyle = _canvas2.default.defaultFillStyle;
  context.fill();
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
    }
    context.stroke();
  }
  context.closePath();
};

/**
 * @return {string} The checksum.
 */
_ol_style_RegularShape_.prototype.getChecksum = function () {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';

  var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];

  if (recalculate) {
    var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }

  return this.checksums_[0];
};
exports.default = _ol_style_RegularShape_;


},{"../colorlike":50,"../dom":60,"../has":107,"../imagestate":108,"../index":110,"../render/canvas":167,"../style/image":241}],243:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */
var _ol_style_Stroke_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */
_ol_style_Stroke_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Stroke_({
    color: color && color.slice ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Stroke_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.getLineCap = function () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDash = function () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDashOffset = function () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
_ol_style_Stroke_.prototype.getLineJoin = function () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.getMiterLimit = function () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
_ol_style_Stroke_.prototype.getWidth = function () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Stroke_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.setLineCap = function (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDash = function (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDashOffset = function (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
_ol_style_Stroke_.prototype.setLineJoin = function (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.setMiterLimit = function (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
_ol_style_Stroke_.prototype.setWidth = function (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Stroke_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += _index2.default.getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');
  }

  return this.checksum_;
};
exports.default = _ol_style_Stroke_;


},{"../index":110}],244:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _geometrytype = require('../geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _circle = require('../style/circle');

var _circle2 = _interopRequireDefault(_circle);

var _fill = require('../style/fill');

var _fill2 = _interopRequireDefault(_fill);

var _stroke = require('../style/stroke');

var _stroke2 = _interopRequireDefault(_stroke);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */
var _ol_style_Style_ = function (opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */
  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {ol.style.Image}
   */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {ol.style.Text}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;
};

/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */
_ol_style_Style_.prototype.clone = function () {
  var geometry = this.getGeometry();
  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }
  return new _ol_style_Style_({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
_ol_style_Style_.prototype.getGeometry = function () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
_ol_style_Style_.prototype.getGeometryFunction = function () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_Style_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */
_ol_style_Style_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */
_ol_style_Style_.prototype.getImage = function () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */
_ol_style_Style_.prototype.setImage = function (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_Style_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */
_ol_style_Style_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */
_ol_style_Style_.prototype.getText = function () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */
_ol_style_Style_.prototype.setText = function (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
_ol_style_Style_.prototype.getZIndex = function () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */
_ol_style_Style_.prototype.setGeometry = function (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function (feature) {
      return (/** @type {ol.geom.Geometry} */feature.get(geometry)
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function () {
      return (/** @type {ol.geom.Geometry} */geometry
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
_ol_style_Style_.prototype.setZIndex = function (zIndex) {
  this.zIndex_ = zIndex;
};

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */
_ol_style_Style_.createFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      _asserts2.default.assert(obj instanceof _ol_style_Style_, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`
      styles = [obj];
    }
    styleFunction = function () {
      return styles;
    };
  }
  return styleFunction;
};

/**
 * @type {Array.<ol.style.Style>}
 * @private
 */
_ol_style_Style_.default_ = null;

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */
_ol_style_Style_.defaultFunction = function (feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (ol.style.Circle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!_ol_style_Style_.default_) {
    var fill = new _fill2.default({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new _stroke2.default({
      color: '#3399CC',
      width: 1.25
    });
    _ol_style_Style_.default_ = [new _ol_style_Style_({
      image: new _circle2.default({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }
  return _ol_style_Style_.default_;
};

/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */
_ol_style_Style_.createDefaultEditing = function () {
  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[_geometrytype2.default.POLYGON] = [new _ol_style_Style_({
    fill: new _fill2.default({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[_geometrytype2.default.MULTI_POLYGON] = styles[_geometrytype2.default.POLYGON];

  styles[_geometrytype2.default.LINE_STRING] = [new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: white,
      width: width + 2
    })
  }), new _ol_style_Style_({
    stroke: new _stroke2.default({
      color: blue,
      width: width
    })
  })];
  styles[_geometrytype2.default.MULTI_LINE_STRING] = styles[_geometrytype2.default.LINE_STRING];

  styles[_geometrytype2.default.CIRCLE] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING]);

  styles[_geometrytype2.default.POINT] = [new _ol_style_Style_({
    image: new _circle2.default({
      radius: width * 2,
      fill: new _fill2.default({
        color: blue
      }),
      stroke: new _stroke2.default({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[_geometrytype2.default.MULTI_POINT] = styles[_geometrytype2.default.POINT];

  styles[_geometrytype2.default.GEOMETRY_COLLECTION] = styles[_geometrytype2.default.POLYGON].concat(styles[_geometrytype2.default.LINE_STRING], styles[_geometrytype2.default.POINT]);

  return styles;
};

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */
_ol_style_Style_.defaultGeometryFunction = function (feature) {
  return feature.getGeometry();
};
exports.default = _ol_style_Style_;


},{"../asserts":44,"../geom/geometrytype":98,"../style/circle":238,"../style/fill":239,"../style/stroke":243}],245:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _tilestate = require('./tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _eventtarget = require('./events/eventtarget');

var _eventtarget2 = _interopRequireDefault(_eventtarget);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 */
var _ol_Tile_ = function (tileCoord, state) {

  _eventtarget2.default.call(this);

  /**
   * @type {ol.TileCoord}
   */
  this.tileCoord = tileCoord;

  /**
   * @protected
   * @type {ol.TileState}
   */
  this.state = state;

  /**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {ol.Tile}
   */
  this.interimTile = null;

  /**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */
  this.key = '';
};

_index2.default.inherits(_ol_Tile_, _eventtarget2.default);

/**
 * @protected
 */
_ol_Tile_.prototype.changed = function () {
  this.dispatchEvent(_eventtype2.default.CHANGE);
};

/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @abstract
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 */
_ol_Tile_.prototype.getImage = function () {};

/**
 * @return {string} Key.
 */
_ol_Tile_.prototype.getKey = function () {
  return this.key + '/' + this.tileCoord;
};

/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!ol.Tile} Best tile for rendering.
 */
_ol_Tile_.prototype.getInterimTile = function () {
  if (!this.interimTile) {
    //empty chain
    return this;
  }
  var tile = this.interimTile;

  // find the first loaded tile and return it. Since the chain is sorted in
  // decreasing order of creation time, there is no need to search the remainder
  // of the list (all those tiles correspond to older requests and will be
  // cleaned up by refreshInterimChain)
  do {
    if (tile.getState() == _tilestate2.default.LOADED) {
      return tile;
    }
    tile = tile.interimTile;
  } while (tile);

  // we can not find a better tile
  return this;
};

/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */
_ol_Tile_.prototype.refreshInterimChain = function () {
  if (!this.interimTile) {
    return;
  }

  var tile = this.interimTile;
  var prev = this;

  do {
    if (tile.getState() == _tilestate2.default.LOADED) {
      //we have a loaded tile, we can discard the rest of the list
      //we would could abort any LOADING tile request
      //older than this tile (i.e. any LOADING tile following this entry in the chain)
      tile.interimTile = null;
      break;
    } else if (tile.getState() == _tilestate2.default.LOADING) {
      //keep this LOADING tile any loaded tiles later in the chain are
      //older than this tile, so we're still interested in the request
      prev = tile;
    } else if (tile.getState() == _tilestate2.default.IDLE) {
      //the head of the list is the most current tile, we don't need
      //to start any other requests for this chain
      prev.interimTile = tile.interimTile;
    } else {
      prev = tile;
    }
    tile = prev.interimTile;
  } while (tile);
};

/**
 * Get the tile coordinate for this tile.
 * @return {ol.TileCoord} The tile coordinate.
 * @api
 */
_ol_Tile_.prototype.getTileCoord = function () {
  return this.tileCoord;
};

/**
 * @return {ol.TileState} State.
 */
_ol_Tile_.prototype.getState = function () {
  return this.state;
};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */
_ol_Tile_.prototype.load = function () {};
exports.default = _ol_Tile_;


},{"./events/eventtarget":65,"./events/eventtype":66,"./index":110,"./tilestate":252}],246:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _lrucache = require('./structs/lrucache');

var _lrucache2 = _interopRequireDefault(_lrucache);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.structs.LRUCache.<ol.Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */
var _ol_TileCache_ = function (opt_highWaterMark) {

  _lrucache2.default.call(this);

  /**
   * @type {number}
   */
  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
};

_index2.default.inherits(_ol_TileCache_, _lrucache2.default);

/**
 * @return {boolean} Can expire cache.
 */
_ol_TileCache_.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};

/**
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */
_ol_TileCache_.prototype.expireCache = function (usedTiles) {
  var this$1 = this;

  var tile, zKey;
  while (this.canExpireCache()) {
    tile = this$1.peekLast();
    zKey = tile.tileCoord[0].toString();
    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this$1.pop().dispose();
    }
  }
};
exports.default = _ol_TileCache_;


},{"./index":110,"./structs/lrucache":234}],247:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_tilecoord_ = {};

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.
 * @return {ol.TileCoord} Tile coordinate.
 */
_ol_tilecoord_.createOrUpdate = function (z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
};

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
_ol_tilecoord_.getKeyZXY = function (z, x, y) {
  return z + '/' + x + '/' + y;
};

/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
_ol_tilecoord_.hash = function (tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
};

/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
_ol_tilecoord_.quadKey = function (tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
_ol_tilecoord_.withinExtentAndZ = function (tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
};
exports.default = _ol_tilecoord_;


},{}],248:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _size = require('./size');

var _size2 = _interopRequireDefault(_size);

var _extent = require('./extent');

var _extent2 = _interopRequireDefault(_extent);

var _corner = require('./extent/corner');

var _corner2 = _interopRequireDefault(_corner);

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

var _proj = require('./proj');

var _proj2 = _interopRequireDefault(_proj);

var _units = require('./proj/units');

var _units2 = _interopRequireDefault(_units);

var _tilegrid = require('./tilegrid/tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_tilegrid_ = {};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.
 */
_ol_tilegrid_.getForProjection = function (projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = _ol_tilegrid_.createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
};

/**
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCoord} Tile coordinate.
 */
_ol_tilegrid_.wrapX = function (tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = _ol_tilegrid_.extentFromProjection(projection);
  if (!_extent2.default.containsCoordinate(projectionExtent, center)) {
    var worldWidth = _extent2.default.getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.TOP_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */
_ol_tilegrid_.createForExtent = function (extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : _corner2.default.TOP_LEFT;

  var resolutions = _ol_tilegrid_.resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new _tilegrid2.default({
    extent: extent,
    origin: _extent2.default.getCorner(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
};

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.
 * @return {ol.tilegrid.TileGrid} Tile grid instance.
 * @api
 */
_ol_tilegrid_.createXYZ = function (opt_options) {
  var options = /** @type {olx.tilegrid.TileGridOptions} */{};
  _obj2.default.assign(options, opt_options !== undefined ? opt_options : /** @type {olx.tilegrid.XYZOptions} */{});
  if (options.extent === undefined) {
    options.extent = _proj2.default.get('EPSG:3857').getExtent();
  }
  options.resolutions = _ol_tilegrid_.resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;

  return new _tilegrid2.default(options);
};

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */
_ol_tilegrid_.resolutionsFromExtent = function (extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : _index2.default.DEFAULT_MAX_ZOOM;

  var height = _extent2.default.getHeight(extent);
  var width = _extent2.default.getWidth(extent);

  var tileSize = _size2.default.toSize(opt_tileSize !== undefined ? opt_tileSize : _index2.default.DEFAULT_TILE_SIZE);
  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
};

/**
 * @param {ol.ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {ol.Size=} opt_tileSize Tile size (default uses ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.BOTTOM_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */
_ol_tilegrid_.createForProjection = function (projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = _ol_tilegrid_.extentFromProjection(projection);
  return _ol_tilegrid_.createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
};

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {ol.ProjectionLike} projection Projection.
 * @return {ol.Extent} Extent.
 */
_ol_tilegrid_.extentFromProjection = function (projection) {
  projection = _proj2.default.get(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * _proj2.default.METERS_PER_UNIT[_units2.default.DEGREES] / projection.getMetersPerUnit();
    extent = _extent2.default.createOrUpdate(-half, -half, half, half);
  }
  return extent;
};
exports.default = _ol_tilegrid_;


},{"./extent":68,"./extent/corner":69,"./index":110,"./obj":146,"./proj":158,"./proj/units":165,"./size":217,"./tilegrid/tilegrid":249}],249:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _asserts = require('../asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _tilerange = require('../tilerange');

var _tilerange2 = _interopRequireDefault(_tilerange);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _extent = require('../extent');

var _extent2 = _interopRequireDefault(_extent);

var _math = require('../math');

var _math2 = _interopRequireDefault(_math);

var _size = require('../size');

var _size2 = _interopRequireDefault(_size);

var _tilecoord = require('../tilecoord');

var _tilecoord2 = _interopRequireDefault(_tilecoord);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {olx.tilegrid.TileGridOptions} options Tile grid options.
 * @struct
 * @api
 */
var _ol_tilegrid_TileGrid_ = function (options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array.<number>}
   */
  this.resolutions_ = options.resolutions;
  _asserts2.default.assert(_array2.default.isSorted(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order

  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array.<ol.Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    _asserts2.default.assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = _extent2.default.getTopLeft(extent);
  }

  _asserts2.default.assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|ol.Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    _asserts2.default.assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|ol.Size}
   */
  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? _index2.default.DEFAULT_TILE_SIZE : null;
  _asserts2.default.assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;

  /**
   * @private
   * @type {Array.<ol.TileRange>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new _tilerange2.default(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};

/**
 * @private
 * @type {ol.TileCoord}
 */
_ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} zoom Zoom level.
 * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
_ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var this$1 = this;

  var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  var z = tileCoord[0] - 1;
  while (z >= this.minZoom) {
    if (callback.call(opt_this, z, this$1.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange))) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {ol.Extent} Extent.
 */
_ol_tilegrid_TileGrid_.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getMaxZoom = function () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getMinZoom = function () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Z.
 * @return {ol.Coordinate} Origin.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Z.
 * @return {number} Resolution.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.TileRange} Tile range.
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  } else {
    return null;
  }
};

/**
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.Extent} Extent.
 */
_ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = _size2.default.toSize(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return _extent2.default.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */
_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndResolution = function (extent, resolution, opt_tileRange) {
  var tileCoord = _ol_tilegrid_TileGrid_.tmpTileCoord_;
  this.getTileCoordForXYAndResolution_(extent[0], extent[1], resolution, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndResolution_(extent[2], extent[3], resolution, true, tileCoord);
  return _tilerange2.default.createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} z Z.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */
_ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var resolution = this.getResolution(z);
  return this.getTileRangeForExtentAndResolution(extent, resolution, opt_tileRange);
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {ol.Coordinate} Tile center.
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = _size2.default.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Extent=} opt_extent Temporary extent object.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = _size2.default.toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return _extent2.default.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = _size2.default.toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return _tilecoord2.default.createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  var resolution = this.getResolution(z);
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
_ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * @param {number} z Z.
 * @return {number|ol.Size} Tile size.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {ol.TileRange} Extent tile range for the specified zoom level.
 */
_ol_tilegrid_TileGrid_.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
_ol_tilegrid_TileGrid_.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = _array2.default.linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
  return _math2.default.clamp(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!ol.Extent} extent Extent for this tile grid.
 * @private
 */
_ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function (extent) {
  var this$1 = this;

  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this$1.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};
exports.default = _ol_tilegrid_TileGrid_;


},{"../array":42,"../asserts":44,"../extent":68,"../index":110,"../math":144,"../size":217,"../tilecoord":247,"../tilerange":251}],250:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _tilestate = require('./tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _events = require('./events');

var _events2 = _interopRequireDefault(_events);

var _eventtype = require('./events/eventtype');

var _eventtype2 = _interopRequireDefault(_eventtype);

var _priorityqueue = require('./structs/priorityqueue');

var _priorityqueue2 = _interopRequireDefault(_priorityqueue);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.structs.PriorityQueue.<Array>}
 * @param {ol.TilePriorityFunction} tilePriorityFunction
 *     Tile priority function.
 * @param {function(): ?} tileChangeCallback
 *     Function called on each tile change event.
 * @struct
 */
var _ol_TileQueue_ = function (tilePriorityFunction, tileChangeCallback) {

  _priorityqueue2.default.call(this,
  /**
   * @param {Array} element Element.
   * @return {number} Priority.
   */
  function (element) {
    return tilePriorityFunction.apply(null, element);
  },
  /**
   * @param {Array} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (/** @type {ol.Tile} */element[0].getKey()
    );
  });

  /**
   * @private
   * @type {function(): ?}
   */
  this.tileChangeCallback_ = tileChangeCallback;

  /**
   * @private
   * @type {number}
   */
  this.tilesLoading_ = 0;

  /**
   * @private
   * @type {!Object.<string,boolean>}
   */
  this.tilesLoadingKeys_ = {};
};

_index2.default.inherits(_ol_TileQueue_, _priorityqueue2.default);

/**
 * @inheritDoc
 */
_ol_TileQueue_.prototype.enqueue = function (element) {
  var added = _priorityqueue2.default.prototype.enqueue.call(this, element);
  if (added) {
    var tile = element[0];
    _events2.default.listen(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);
  }
  return added;
};

/**
 * @return {number} Number of tiles loading.
 */
_ol_TileQueue_.prototype.getTilesLoading = function () {
  return this.tilesLoading_;
};

/**
 * @param {ol.events.Event} event Event.
 * @protected
 */
_ol_TileQueue_.prototype.handleTileChange = function (event) {
  var tile = /** @type {ol.Tile} */event.target;
  var state = tile.getState();
  if (state === _tilestate2.default.LOADED || state === _tilestate2.default.ERROR || state === _tilestate2.default.EMPTY || state === _tilestate2.default.ABORT) {
    _events2.default.unlisten(tile, _eventtype2.default.CHANGE, this.handleTileChange, this);
    var tileKey = tile.getKey();
    if (tileKey in this.tilesLoadingKeys_) {
      delete this.tilesLoadingKeys_[tileKey];
      --this.tilesLoading_;
    }
    this.tileChangeCallback_();
  }
};

/**
 * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
 * @param {number} maxNewLoads Maximum number of new tiles to load.
 */
_ol_TileQueue_.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
  var this$1 = this;

  var newLoads = 0;
  var tile, tileKey;
  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
    tile = /** @type {ol.Tile} */this$1.dequeue()[0];
    tileKey = tile.getKey();
    if (tile.getState() === _tilestate2.default.IDLE && !(tileKey in this$1.tilesLoadingKeys_)) {
      this$1.tilesLoadingKeys_[tileKey] = true;
      ++this$1.tilesLoading_;
      ++newLoads;
      tile.load();
    }
  }
};
exports.default = _ol_TileQueue_;


},{"./events":62,"./events/eventtype":66,"./index":110,"./structs/priorityqueue":235,"./tilestate":252}],251:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var _ol_TileRange_ = function (minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;
};

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {ol.TileRange|undefined} tileRange TileRange.
 * @return {ol.TileRange} Tile range.
 */
_ol_TileRange_.createOrUpdate = function (minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new _ol_TileRange_(minX, maxX, minY, maxY);
  }
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
_ol_TileRange_.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
_ol_TileRange_.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
_ol_TileRange_.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
_ol_TileRange_.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 */
_ol_TileRange_.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
_ol_TileRange_.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {ol.Size} Size.
 */
_ol_TileRange_.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
_ol_TileRange_.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
_ol_TileRange_.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};
exports.default = _ol_TileRange_;


},{}],252:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 */
var _ol_TileState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};

exports.default = _ol_TileState_;


},{}],253:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _math = require('./math');

var _math2 = _interopRequireDefault(_math);

var _tilecoord = require('./tilecoord');

var _tilecoord2 = _interopRequireDefault(_tilecoord);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_TileUrlFunction_ = {};

/**
 * @param {string} template Template.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTemplate = function (template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {
          var y = -tileCoord[2] - 1;
          return y.toString();
        }).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          _asserts2.default.assert(range, 55); // The {-y} placeholder requires a tile grid with extent
          var y = range.getHeight() + tileCoord[2];
          return y.toString();
        });
      }
    }
  );
};

/**
 * @param {Array.<string>} templates Templates.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTemplates = function (templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = _ol_TileUrlFunction_.createFromTemplate(templates[i], tileGrid);
  }
  return _ol_TileUrlFunction_.createFromTileUrlFunctions(tileUrlFunctions);
};

/**
 * @param {Array.<ol.TileUrlFunctionType>} tileUrlFunctions Tile URL Functions.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTileUrlFunctions = function (tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = _tilecoord2.default.hash(tileCoord);
        var index = _math2.default.modulo(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */
_ol_TileUrlFunction_.nullTileUrlFunction = function (tileCoord, pixelRatio, projection) {
  return undefined;
};

/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */
_ol_TileUrlFunction_.expandUrl = function (url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
};
exports.default = _ol_TileUrlFunction_;


},{"./asserts":44,"./math":144,"./tilecoord":247}],254:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_transform_ = {};

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3x3 martrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {ol.Transform}
 */
_ol_transform_.tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!ol.Transform} Identity transform.
 */
_ol_transform_.create = function () {
  return [1, 0, 0, 1, 0, 0];
};

/**
 * Resets the given transform to an identity transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Transform.
 */
_ol_transform_.reset = function (transform) {
  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);
};

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!ol.Transform} transform1 Transform parameters of matrix 1.
 * @param {!ol.Transform} transform2 Transform parameters of matrix 2.
 * @return {!ol.Transform} transform1 multiplied with transform2.
 */
_ol_transform_.multiply = function (transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
};

/**
 * Set the transform components a-f on a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!ol.Transform} Matrix with transform applied.
 */
_ol_transform_.set = function (transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
};

/**
 * Set transform on one matrix from another matrix.
 * @param {!ol.Transform} transform1 Matrix to set transform to.
 * @param {!ol.Transform} transform2 Matrix to set transform from.
 * @return {!ol.Transform} transform1 with transform from transform2 applied.
 */
_ol_transform_.setFromArray = function (transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
};

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {ol.Transform} transform The transformation.
 * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.
 * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be
 *     chained together.
 */
_ol_transform_.apply = function (transform, coordinate) {
  var x = coordinate[0],
      y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
};

/**
 * Applies rotation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!ol.Transform} The rotated transform.
 */
_ol_transform_.rotate = function (transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));
};

/**
 * Applies scale to a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!ol.Transform} The scaled transform.
 */
_ol_transform_.scale = function (transform, x, y) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));
};

/**
 * Applies translation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!ol.Transform} The translated transform.
 */
_ol_transform_.translate = function (transform, dx, dy) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));
};

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!ol.Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!ol.Transform} The composite transform.
 */
_ol_transform_.compose = function (transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
};

/**
 * Invert the given transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Inverse of the transform.
 */
_ol_transform_.invert = function (transform) {
  var det = _ol_transform_.determinant(transform);
  _asserts2.default.assert(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
};

/**
 * Returns the determinant of the given matrix.
 * @param {!ol.Transform} mat Matrix.
 * @return {number} Determinant.
 */
_ol_transform_.determinant = function (mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
};
exports.default = _ol_transform_;


},{"./asserts":44}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _ol_vec_Mat4_ = {};

/**
 * @return {Array.<number>} 4x4 matrix representing a 3D identity transform.
 */
_ol_vec_Mat4_.create = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

/**
 * @param {Array.<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {ol.Transform} transform Transformation matrix.
 * @return {Array.<number>} 2D transformation matrix as flattened 4x4 matrix.
 */
_ol_vec_Mat4_.fromTransform = function (mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
};
exports.default = _ol_vec_Mat4_;


},{}],256:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _tile = require('./tile');

var _tile2 = _interopRequireDefault(_tile);

var _tilestate = require('./tilestate');

var _tilestate2 = _interopRequireDefault(_tilestate);

var _dom = require('./dom');

var _dom2 = _interopRequireDefault(_dom);

var _featureloader = require('./featureloader');

var _featureloader2 = _interopRequireDefault(_featureloader);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Data source url.
 * @param {ol.format.Feature} format Feature format.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 */
var _ol_VectorTile_ = function (tileCoord, state, src, format, tileLoadFunction) {

  _tile2.default.call(this, tileCoord, state);

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = null;

  /**
   * @private
   * @type {ol.format.Feature}
   */
  this.format_ = format;

  /**
   * @private
   * @type {Array.<ol.Feature>}
   */
  this.features_ = null;

  /**
   * @private
   * @type {ol.FeatureLoader}
   */
  this.loader_;

  /**
   * Data projection
   * @private
   * @type {ol.proj.Projection}
   */
  this.projection_;

  /**
   * @private
   * @type {ol.TileReplayState}
   */
  this.replayState_ = {
    dirty: false,
    renderedRenderOrder: null,
    renderedRevision: -1,
    renderedTileRevision: -1,
    replayGroup: null
  };

  /**
   * @private
   * @type {ol.TileLoadFunctionType}
   */
  this.tileLoadFunction_ = tileLoadFunction;

  /**
   * @private
   * @type {string}
   */
  this.url_ = src;
};

_index2.default.inherits(_ol_VectorTile_, _tile2.default);

/**
 * @return {CanvasRenderingContext2D} The rendering context.
 */
_ol_VectorTile_.prototype.getContext = function () {
  if (!this.context_) {
    this.context_ = _dom2.default.createCanvasContext2D();
  }
  return this.context_;
};

/**
 * @override
 */
_ol_VectorTile_.prototype.getImage = function () {
  return this.replayState_.renderedTileRevision == -1 ? null : this.context_.canvas;
};

/**
 * Get the feature format assigned for reading this tile's features.
 * @return {ol.format.Feature} Feature format.
 * @api
 */
_ol_VectorTile_.prototype.getFormat = function () {
  return this.format_;
};

/**
 * @return {Array.<ol.Feature>} Features.
 */
_ol_VectorTile_.prototype.getFeatures = function () {
  return this.features_;
};

/**
 * @return {ol.TileReplayState} The replay state.
 */
_ol_VectorTile_.prototype.getReplayState = function () {
  return this.replayState_;
};

/**
 * @inheritDoc
 */
_ol_VectorTile_.prototype.getKey = function () {
  return this.url_;
};

/**
 * @return {ol.proj.Projection} Feature projection.
 */
_ol_VectorTile_.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * @inheritDoc
 */
_ol_VectorTile_.prototype.load = function () {
  if (this.state == _tilestate2.default.IDLE) {
    this.setState(_tilestate2.default.LOADING);
    this.tileLoadFunction_(this, this.url_);
    this.loader_(null, NaN, null);
  }
};

/**
 * Handler for successful tile load.
 * @param {Array.<ol.Feature>} features The loaded features.
 * @param {ol.proj.Projection} dataProjection Data projection.
 */
_ol_VectorTile_.prototype.onLoad_ = function (features, dataProjection) {
  this.setProjection(dataProjection);
  this.setFeatures(features);
};

/**
 * Handler for tile load errors.
 */
_ol_VectorTile_.prototype.onError_ = function () {
  this.setState(_tilestate2.default.ERROR);
};

/**
 * @param {Array.<ol.Feature>} features Features.
 * @api
 */
_ol_VectorTile_.prototype.setFeatures = function (features) {
  this.features_ = features;
  this.setState(_tilestate2.default.LOADED);
};

/**
 * Set the projection of the features that were added with {@link #setFeatures}.
 * @param {ol.proj.Projection} projection Feature projection.
 * @api
 */
_ol_VectorTile_.prototype.setProjection = function (projection) {
  this.projection_ = projection;
};

/**
 * @param {ol.TileState} tileState Tile state.
 */
_ol_VectorTile_.prototype.setState = function (tileState) {
  this.state = tileState;
  this.changed();
};

/**
 * Set the feature loader for reading this tile's features.
 * @param {ol.FeatureLoader} loader Feature loader.
 * @api
 */
_ol_VectorTile_.prototype.setLoader = function (loader) {
  this.loader_ = loader;
};

/**
 * Sets the loader for a tile.
 * @param {ol.VectorTile} tile Vector tile.
 * @param {string} url URL.
 */
_ol_VectorTile_.defaultLoadFunction = function (tile, url) {
  var loader = _featureloader2.default.loadFeaturesXhr(url, tile.getFormat(), tile.onLoad_.bind(tile), tile.onError_.bind(tile));

  tile.setLoader(loader);
};
exports.default = _ol_VectorTile_;


},{"./dom":60,"./featureloader":72,"./index":110,"./tile":245,"./tilestate":252}],257:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

var _centerconstraint = require('./centerconstraint');

var _centerconstraint2 = _interopRequireDefault(_centerconstraint);

var _constraints = require('./constraints');

var _constraints2 = _interopRequireDefault(_constraints);

var _object = require('./object');

var _object2 = _interopRequireDefault(_object);

var _resolutionconstraint = require('./resolutionconstraint');

var _resolutionconstraint2 = _interopRequireDefault(_resolutionconstraint);

var _rotationconstraint = require('./rotationconstraint');

var _rotationconstraint2 = _interopRequireDefault(_rotationconstraint);

var _viewhint = require('./viewhint');

var _viewhint2 = _interopRequireDefault(_viewhint);

var _viewproperty = require('./viewproperty');

var _viewproperty2 = _interopRequireDefault(_viewproperty);

var _array = require('./array');

var _array2 = _interopRequireDefault(_array);

var _asserts = require('./asserts');

var _asserts2 = _interopRequireDefault(_asserts);

var _coordinate = require('./coordinate');

var _coordinate2 = _interopRequireDefault(_coordinate);

var _easing = require('./easing');

var _easing2 = _interopRequireDefault(_easing);

var _extent = require('./extent');

var _extent2 = _interopRequireDefault(_extent);

var _geometrytype = require('./geom/geometrytype');

var _geometrytype2 = _interopRequireDefault(_geometrytype);

var _polygon = require('./geom/polygon');

var _polygon2 = _interopRequireDefault(_polygon);

var _simplegeometry = require('./geom/simplegeometry');

var _simplegeometry2 = _interopRequireDefault(_simplegeometry);

var _obj = require('./obj');

var _obj2 = _interopRequireDefault(_obj);

var _proj = require('./proj');

var _proj2 = _interopRequireDefault(_proj);

var _units = require('./proj/units');

var _units2 = _interopRequireDefault(_units);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

/**
 * @classdesc
 * An ol.View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.ViewOptions=} opt_options View options.
 * @api
 */
var _ol_View_ = function (opt_options) {
  _object2.default.call(this);

  var options = _obj2.default.assign({}, opt_options);

  /**
   * @private
   * @type {Array.<number>}
   */
  this.hints_ = [0, 0];

  /**
   * @private
   * @type {Array.<Array.<ol.ViewAnimation>>}
   */
  this.animations_ = [];

  /**
   * @private
   * @type {number|undefined}
   */
  this.updateAnimationKey_;

  this.updateAnimations_ = this.updateAnimations_.bind(this);

  /**
   * @private
   * @const
   * @type {ol.proj.Projection}
   */
  this.projection_ = _proj2.default.createProjection(options.projection, 'EPSG:3857');

  this.applyOptions_(options);
};

_index2.default.inherits(_ol_View_, _object2.default);

/**
 * Set up the view with the given options.
 * @param {olx.ViewOptions} options View options.
 */
_ol_View_.prototype.applyOptions_ = function (options) {

  /**
   * @type {Object.<string, *>}
   */
  var properties = {};
  properties[_viewproperty2.default.CENTER] = options.center !== undefined ? options.center : null;

  var resolutionConstraintInfo = _ol_View_.createResolutionConstraint_(options);

  /**
   * @private
   * @type {number}
   */
  this.maxResolution_ = resolutionConstraintInfo.maxResolution;

  /**
   * @private
   * @type {number}
   */
  this.minResolution_ = resolutionConstraintInfo.minResolution;

  /**
   * @private
   * @type {number}
   */
  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

  /**
   * @private
   * @type {Array.<number>|undefined}
   */
  this.resolutions_ = options.resolutions;

  /**
   * @private
   * @type {number}
   */
  this.minZoom_ = resolutionConstraintInfo.minZoom;

  var centerConstraint = _ol_View_.createCenterConstraint_(options);
  var resolutionConstraint = resolutionConstraintInfo.constraint;
  var rotationConstraint = _ol_View_.createRotationConstraint_(options);

  /**
   * @private
   * @type {ol.Constraints}
   */
  this.constraints_ = new _constraints2.default(centerConstraint, resolutionConstraint, rotationConstraint);

  if (options.resolution !== undefined) {
    properties[_viewproperty2.default.RESOLUTION] = options.resolution;
  } else if (options.zoom !== undefined) {
    properties[_viewproperty2.default.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);
  }
  properties[_viewproperty2.default.ROTATION] = options.rotation !== undefined ? options.rotation : 0;
  this.setProperties(properties);

  /**
   * @private
   * @type {olx.ViewOptions}
   */
  this.options_ = options;
};

/**
 * Get an updated version of the view options used to construct the view.  The
 * current resolution (or zoom), center, and rotation are applied to any stored
 * options.  The provided options can be uesd to apply new min/max zoom or
 * resolution limits.
 * @param {olx.ViewOptions} newOptions New options to be applied.
 * @return {olx.ViewOptions} New options updated with the current view state.
 */
_ol_View_.prototype.getUpdatedOptions_ = function (newOptions) {
  var options = _obj2.default.assign({}, this.options_);

  // preserve resolution (or zoom)
  if (options.resolution !== undefined) {
    options.resolution = this.getResolution();
  } else {
    options.zoom = this.getZoom();
  }

  // preserve center
  options.center = this.getCenter();

  // preserve rotation
  options.rotation = this.getRotation();

  return _obj2.default.assign({}, options, newOptions);
};

/**
 * Animate the view.  The view's center, zoom (or resolution), and rotation
 * can be animated for smooth transitions between view states.  For example,
 * to animate the view to a new zoom level:
 *
 *     view.animate({zoom: view.getZoom() + 1});
 *
 * By default, the animation lasts one second and uses in-and-out easing.  You
 * can customize this behavior by including `duration` (in milliseconds) and
 * `easing` options (see {@link ol.easing}).
 *
 * To chain together multiple animations, call the method with multiple
 * animation objects.  For example, to first zoom and then pan:
 *
 *     view.animate({zoom: 10}, {center: [0, 0]});
 *
 * If you provide a function as the last argument to the animate method, it
 * will get called at the end of an animation series.  The callback will be
 * called with `true` if the animation series completed on its own or `false`
 * if it was cancelled.
 *
 * Animations are cancelled by user interactions (e.g. dragging the map) or by
 * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
 * (or another method that calls one of these).
 *
 * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation
 *     options.  Multiple animations can be run in series by passing multiple
 *     options objects.  To run multiple animations in parallel, call the method
 *     multiple times.  An optional callback can be provided as a final
 *     argument.  The callback will be called with a boolean indicating whether
 *     the animation completed without being cancelled.
 * @api
 */
_ol_View_.prototype.animate = function (var_args) {
  var arguments$1 = arguments;
  var this$1 = this;

  var start = Date.now();
  var center = this.getCenter().slice();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  var animationCount = arguments.length;
  var callback;
  if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
    callback = arguments[animationCount - 1];
    --animationCount;
  }
  var series = [];
  for (var i = 0; i < animationCount; ++i) {
    var options = /** @type {olx.AnimationOptions} */arguments$1[i];

    var animation = /** @type {ol.ViewAnimation} */{
      start: start,
      complete: false,
      anchor: options.anchor,
      duration: options.duration !== undefined ? options.duration : 1000,
      easing: options.easing || _easing2.default.inAndOut
    };

    if (options.center) {
      animation.sourceCenter = center;
      animation.targetCenter = options.center;
      center = animation.targetCenter;
    }

    if (options.zoom !== undefined) {
      animation.sourceResolution = resolution;
      animation.targetResolution = this$1.constrainResolution(this$1.maxResolution_, options.zoom - this$1.minZoom_, 0);
      resolution = animation.targetResolution;
    } else if (options.resolution) {
      animation.sourceResolution = resolution;
      animation.targetResolution = options.resolution;
      resolution = animation.targetResolution;
    }

    if (options.rotation !== undefined) {
      animation.sourceRotation = rotation;
      animation.targetRotation = options.rotation;
      rotation = animation.targetRotation;
    }

    animation.callback = callback;
    start += animation.duration;
    series.push(animation);
  }
  this.animations_.push(series);
  this.setHint(_viewhint2.default.ANIMATING, 1);
  this.updateAnimations_();
};

/**
 * Determine if the view is being animated.
 * @return {boolean} The view is being animated.
 * @api
 */
_ol_View_.prototype.getAnimating = function () {
  return this.getHints()[_viewhint2.default.ANIMATING] > 0;
};

/**
 * Cancel any ongoing animations.
 * @api
 */
_ol_View_.prototype.cancelAnimations = function () {
  var this$1 = this;

  this.setHint(_viewhint2.default.ANIMATING, -this.getHints()[_viewhint2.default.ANIMATING]);
  for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
    var series = this$1.animations_[i];
    if (series[0].callback) {
      series[0].callback(false);
    }
  }
  this.animations_.length = 0;
};

/**
 * Update all animations.
 */
_ol_View_.prototype.updateAnimations_ = function () {
  var this$1 = this;

  if (this.updateAnimationKey_ !== undefined) {
    cancelAnimationFrame(this.updateAnimationKey_);
    this.updateAnimationKey_ = undefined;
  }
  if (!this.getAnimating()) {
    return;
  }
  var now = Date.now();
  var more = false;
  for (var i = this.animations_.length - 1; i >= 0; --i) {
    var series = this$1.animations_[i];
    var seriesComplete = true;
    for (var j = 0, jj = series.length; j < jj; ++j) {
      var animation = series[j];
      if (animation.complete) {
        continue;
      }
      var elapsed = now - animation.start;
      var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
      if (fraction >= 1) {
        animation.complete = true;
        fraction = 1;
      } else {
        seriesComplete = false;
      }
      var progress = animation.easing(fraction);
      if (animation.sourceCenter) {
        var x0 = animation.sourceCenter[0];
        var y0 = animation.sourceCenter[1];
        var x1 = animation.targetCenter[0];
        var y1 = animation.targetCenter[1];
        var x = x0 + progress * (x1 - x0);
        var y = y0 + progress * (y1 - y0);
        this$1.set(_viewproperty2.default.CENTER, [x, y]);
      }
      if (animation.sourceResolution && animation.targetResolution) {
        var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
        if (animation.anchor) {
          this$1.set(_viewproperty2.default.CENTER, this$1.calculateCenterZoom(resolution, animation.anchor));
        }
        this$1.set(_viewproperty2.default.RESOLUTION, resolution);
      }
      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
        var rotation = progress === 1 ? animation.targetRotation : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
        if (animation.anchor) {
          this$1.set(_viewproperty2.default.CENTER, this$1.calculateCenterRotate(rotation, animation.anchor));
        }
        this$1.set(_viewproperty2.default.ROTATION, rotation);
      }
      more = true;
      if (!animation.complete) {
        break;
      }
    }
    if (seriesComplete) {
      this$1.animations_[i] = null;
      this$1.setHint(_viewhint2.default.ANIMATING, -1);
      var callback = series[0].callback;
      if (callback) {
        callback(true);
      }
    }
  }
  // prune completed series
  this.animations_ = this.animations_.filter(Boolean);
  if (more && this.updateAnimationKey_ === undefined) {
    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
  }
};

/**
 * @param {number} rotation Target rotation.
 * @param {ol.Coordinate} anchor Rotation anchor.
 * @return {ol.Coordinate|undefined} Center for rotation and anchor.
 */
_ol_View_.prototype.calculateCenterRotate = function (rotation, anchor) {
  var center;
  var currentCenter = this.getCenter();
  if (currentCenter !== undefined) {
    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
    _coordinate2.default.rotate(center, rotation - this.getRotation());
    _coordinate2.default.add(center, anchor);
  }
  return center;
};

/**
 * @param {number} resolution Target resolution.
 * @param {ol.Coordinate} anchor Zoom anchor.
 * @return {ol.Coordinate|undefined} Center for resolution and anchor.
 */
_ol_View_.prototype.calculateCenterZoom = function (resolution, anchor) {
  var center;
  var currentCenter = this.getCenter();
  var currentResolution = this.getResolution();
  if (currentCenter !== undefined && currentResolution !== undefined) {
    var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
    var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
    center = [x, y];
  }
  return center;
};

/**
 * @private
 * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.
 */
_ol_View_.prototype.getSizeFromViewport_ = function () {
  var size = [100, 100];
  var selector = '.ol-viewport[data-view="' + _index2.default.getUid(this) + '"]';
  var element = document.querySelector(selector);
  if (element) {
    var metrics = getComputedStyle(element);
    size[0] = parseInt(metrics.width, 10);
    size[1] = parseInt(metrics.height, 10);
  }
  return size;
};

/**
 * Get the constrained center of this view.
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Constrained center.
 * @api
 */
_ol_View_.prototype.constrainCenter = function (center) {
  return this.constraints_.center(center);
};

/**
 * Get the constrained resolution of this view.
 * @param {number|undefined} resolution Resolution.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @param {number=} opt_direction Direction. Default is `0`.
 * @return {number|undefined} Constrained resolution.
 * @api
 */
_ol_View_.prototype.constrainResolution = function (resolution, opt_delta, opt_direction) {
  var delta = opt_delta || 0;
  var direction = opt_direction || 0;
  return this.constraints_.resolution(resolution, delta, direction);
};

/**
 * Get the constrained rotation of this view.
 * @param {number|undefined} rotation Rotation.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @return {number|undefined} Constrained rotation.
 * @api
 */
_ol_View_.prototype.constrainRotation = function (rotation, opt_delta) {
  var delta = opt_delta || 0;
  return this.constraints_.rotation(rotation, delta);
};

/**
 * Get the view center.
 * @return {ol.Coordinate|undefined} The center of the view.
 * @observable
 * @api
 */
_ol_View_.prototype.getCenter = function () {
  return (/** @type {ol.Coordinate|undefined} */this.get(_viewproperty2.default.CENTER)
  );
};

/**
 * @param {Array.<number>=} opt_hints Destination array.
 * @return {Array.<number>} Hint.
 */
_ol_View_.prototype.getHints = function (opt_hints) {
  if (opt_hints !== undefined) {
    opt_hints[0] = this.hints_[0];
    opt_hints[1] = this.hints_[1];
    return opt_hints;
  } else {
    return this.hints_.slice();
  }
};

/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the
 * first map that uses this view will be used.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_View_.prototype.calculateExtent = function (opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var center = /** @type {!ol.Coordinate} */this.getCenter();
  _asserts2.default.assert(center, 1); // The view center is not defined
  var resolution = /** @type {!number} */this.getResolution();
  _asserts2.default.assert(resolution !== undefined, 2); // The view resolution is not defined
  var rotation = /** @type {!number} */this.getRotation();
  _asserts2.default.assert(rotation !== undefined, 3); // The view rotation is not defined

  return _extent2.default.getForViewAndSize(center, resolution, rotation, size);
};

/**
 * Get the maximum resolution of the view.
 * @return {number} The maximum resolution of the view.
 * @api
 */
_ol_View_.prototype.getMaxResolution = function () {
  return this.maxResolution_;
};

/**
 * Get the minimum resolution of the view.
 * @return {number} The minimum resolution of the view.
 * @api
 */
_ol_View_.prototype.getMinResolution = function () {
  return this.minResolution_;
};

/**
 * Get the maximum zoom level for the view.
 * @return {number} The maximum zoom level.
 * @api
 */
_ol_View_.prototype.getMaxZoom = function () {
  return (/** @type {number} */this.getZoomForResolution(this.minResolution_)
  );
};

/**
 * Set a new maximum zoom level for the view.
 * @param {number} zoom The maximum zoom level.
 * @api
 */
_ol_View_.prototype.setMaxZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
};

/**
 * Get the minimum zoom level for the view.
 * @return {number} The minimum zoom level.
 * @api
 */
_ol_View_.prototype.getMinZoom = function () {
  return (/** @type {number} */this.getZoomForResolution(this.maxResolution_)
  );
};

/**
 * Set a new minimum zoom level for the view.
 * @param {number} zoom The minimum zoom level.
 * @api
 */
_ol_View_.prototype.setMinZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
};

/**
 * Get the view projection.
 * @return {ol.proj.Projection} The projection of the view.
 * @api
 */
_ol_View_.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * Get the view resolution.
 * @return {number|undefined} The resolution of the view.
 * @observable
 * @api
 */
_ol_View_.prototype.getResolution = function () {
  return (/** @type {number|undefined} */this.get(_viewproperty2.default.RESOLUTION)
  );
};

/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * @return {Array.<number>|undefined} The resolutions of the view.
 * @api
 */
_ol_View_.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * Get the resolution for a provided extent (in map units) and size (in pixels).
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size} size Box pixel size.
 * @return {number} The resolution at which the provided extent will render at
 *     the given size.
 */
_ol_View_.prototype.getResolutionForExtent = function (extent, size) {
  var xResolution = _extent2.default.getWidth(extent) / size[0];
  var yResolution = _extent2.default.getHeight(extent) / size[1];
  return Math.max(xResolution, yResolution);
};

/**
 * Return a function that returns a value between 0 and 1 for a
 * resolution. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Resolution for value function.
 */
_ol_View_.prototype.getResolutionForValueFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} value Value.
     * @return {number} Resolution.
     */
    function (value) {
      var resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    }
  );
};

/**
 * Get the view rotation.
 * @return {number} The rotation of the view in radians.
 * @observable
 * @api
 */
_ol_View_.prototype.getRotation = function () {
  return (/** @type {number} */this.get(_viewproperty2.default.ROTATION)
  );
};

/**
 * Return a function that returns a resolution for a value between
 * 0 and 1. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Value for resolution function.
 */
_ol_View_.prototype.getValueForResolutionFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} resolution Resolution.
     * @return {number} Value.
     */
    function (resolution) {
      var value = Math.log(maxResolution / resolution) / Math.log(power) / max;
      return value;
    }
  );
};

/**
 * @return {olx.ViewState} View state.
 */
_ol_View_.prototype.getState = function () {
  var center = /** @type {ol.Coordinate} */this.getCenter();
  var projection = this.getProjection();
  var resolution = /** @type {number} */this.getResolution();
  var rotation = this.getRotation();
  return (/** @type {olx.ViewState} */{
      center: center.slice(),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation
    }
  );
};

/**
 * Get the current zoom level. Return undefined if the current
 * resolution is undefined or not within the "resolution constraints".
 * @return {number|undefined} Zoom.
 * @api
 */
_ol_View_.prototype.getZoom = function () {
  var zoom;
  var resolution = this.getResolution();
  if (resolution !== undefined) {
    zoom = this.getZoomForResolution(resolution);
  }
  return zoom;
};

/**
 * Get the zoom level for a resolution.
 * @param {number} resolution The resolution.
 * @return {number|undefined} The zoom level for the provided resolution.
 * @api
 */
_ol_View_.prototype.getZoomForResolution = function (resolution) {
  var zoom;
  if (resolution >= this.minResolution_ && resolution <= this.maxResolution_) {
    var offset = this.minZoom_ || 0;
    var max, zoomFactor;
    if (this.resolutions_) {
      var nearest = _array2.default.linearFindNearest(this.resolutions_, resolution, 1);
      offset += nearest;
      if (nearest == this.resolutions_.length - 1) {
        return offset;
      }
      max = this.resolutions_[nearest];
      zoomFactor = max / this.resolutions_[nearest + 1];
    } else {
      max = this.maxResolution_;
      zoomFactor = this.zoomFactor_;
    }
    zoom = offset + Math.log(max / resolution) / Math.log(zoomFactor);
  }
  return zoom;
};

/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or
 *     extent to fit the view to.
 * @param {olx.view.FitOptions=} opt_options Options.
 * @api
 */
_ol_View_.prototype.fit = function (geometryOrExtent, opt_options) {
  var options = opt_options || {};
  var size = options.size;
  if (!size) {
    size = this.getSizeFromViewport_();
  }
  /** @type {ol.geom.SimpleGeometry} */
  var geometry;
  if (!(geometryOrExtent instanceof _simplegeometry2.default)) {
    _asserts2.default.assert(Array.isArray(geometryOrExtent), 24); // Invalid extent or geometry provided as `geometry`
    _asserts2.default.assert(!_extent2.default.isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
    geometry = _polygon2.default.fromExtent(geometryOrExtent);
  } else if (geometryOrExtent.getType() === _geometrytype2.default.CIRCLE) {
    geometryOrExtent = geometryOrExtent.getExtent();
    geometry = _polygon2.default.fromExtent(geometryOrExtent);
    geometry.rotate(this.getRotation(), _extent2.default.getCenter(geometryOrExtent));
  } else {
    geometry = geometryOrExtent;
  }

  var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
  var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;
  var nearest = options.nearest !== undefined ? options.nearest : false;
  var minResolution;
  if (options.minResolution !== undefined) {
    minResolution = options.minResolution;
  } else if (options.maxZoom !== undefined) {
    minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);
  } else {
    minResolution = 0;
  }
  var coords = geometry.getFlatCoordinates();

  // calculate rotated extent
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var minRotX = +Infinity;
  var minRotY = +Infinity;
  var maxRotX = -Infinity;
  var maxRotY = -Infinity;
  var stride = geometry.getStride();
  for (var i = 0, ii = coords.length; i < ii; i += stride) {
    var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
    var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
    minRotX = Math.min(minRotX, rotX);
    minRotY = Math.min(minRotY, rotY);
    maxRotX = Math.max(maxRotX, rotX);
    maxRotY = Math.max(maxRotY, rotY);
  }

  // calculate resolution
  var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
  resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
  if (constrainResolution) {
    var constrainedResolution = this.constrainResolution(resolution, 0, 0);
    if (!nearest && constrainedResolution < resolution) {
      constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);
    }
    resolution = constrainedResolution;
  }

  // calculate center
  sinAngle = -sinAngle; // go back to original rotation
  var centerRotX = (minRotX + maxRotX) / 2;
  var centerRotY = (minRotY + maxRotY) / 2;
  centerRotX += (padding[1] - padding[3]) / 2 * resolution;
  centerRotY += (padding[0] - padding[2]) / 2 * resolution;
  var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
  var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
  var center = [centerX, centerY];

  if (options.duration !== undefined) {
    this.animate({
      resolution: resolution,
      center: center,
      duration: options.duration,
      easing: options.easing
    });
  } else {
    this.setResolution(resolution);
    this.setCenter(center);
  }
};

/**
 * Center on coordinate and view position.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Size} size Box pixel size.
 * @param {ol.Pixel} position Position on the view to center on.
 * @api
 */
_ol_View_.prototype.centerOn = function (coordinate, size, position) {
  // calculate rotated position
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  var resolution = this.getResolution();
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;

  // go back to original angle
  sinAngle = -sinAngle; // go back to original rotation
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;

  this.setCenter([centerX, centerY]);
};

/**
 * @return {boolean} Is defined.
 */
_ol_View_.prototype.isDef = function () {
  return !!this.getCenter() && this.getResolution() !== undefined;
};

/**
 * Rotate the view around a given coordinate.
 * @param {number} rotation New rotation value for the view.
 * @param {ol.Coordinate=} opt_anchor The rotation center.
 * @api
 */
_ol_View_.prototype.rotate = function (rotation, opt_anchor) {
  if (opt_anchor !== undefined) {
    var center = this.calculateCenterRotate(rotation, opt_anchor);
    this.setCenter(center);
  }
  this.setRotation(rotation);
};

/**
 * Set the center of the current view.
 * @param {ol.Coordinate|undefined} center The center of the view.
 * @observable
 * @api
 */
_ol_View_.prototype.setCenter = function (center) {
  this.set(_viewproperty2.default.CENTER, center);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * @param {ol.ViewHint} hint Hint.
 * @param {number} delta Delta.
 * @return {number} New value.
 */
_ol_View_.prototype.setHint = function (hint, delta) {
  this.hints_[hint] += delta;
  this.changed();
  return this.hints_[hint];
};

/**
 * Set the resolution for this view.
 * @param {number|undefined} resolution The resolution of the view.
 * @observable
 * @api
 */
_ol_View_.prototype.setResolution = function (resolution) {
  this.set(_viewproperty2.default.RESOLUTION, resolution);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * Set the rotation for this view.
 * @param {number} rotation The rotation of the view in radians.
 * @observable
 * @api
 */
_ol_View_.prototype.setRotation = function (rotation) {
  this.set(_viewproperty2.default.ROTATION, rotation);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * Zoom to a specific zoom level.
 * @param {number} zoom Zoom level.
 * @api
 */
_ol_View_.prototype.setZoom = function (zoom) {
  var resolution = this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0);
  this.setResolution(resolution);
};

/**
 * @param {olx.ViewOptions} options View options.
 * @private
 * @return {ol.CenterConstraintType} The constraint.
 */
_ol_View_.createCenterConstraint_ = function (options) {
  if (options.extent !== undefined) {
    return _centerconstraint2.default.createExtent(options.extent);
  } else {
    return _centerconstraint2.default.none;
  }
};

/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,
 *     minResolution: number, zoomFactor: number}} The constraint.
 */
_ol_View_.createResolutionConstraint_ = function (options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;

  var minZoom = options.minZoom !== undefined ? options.minZoom : _index2.default.DEFAULT_MIN_ZOOM;

  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;

  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[0];
    minResolution = resolutions[resolutions.length - 1];
    resolutionConstraint = _resolutionconstraint2.default.createSnapToResolutions(resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = _proj2.default.createProjection(options.projection, 'EPSG:3857');
    var extent = projection.getExtent();
    var size = !extent ?
    // use an extent that can fit the whole world if need be
    360 * _proj2.default.METERS_PER_UNIT[_units2.default.DEGREES] / projection.getMetersPerUnit() : Math.max(_extent2.default.getWidth(extent), _extent2.default.getHeight(extent));

    var defaultMaxResolution = size / _index2.default.DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, _index2.default.DEFAULT_MIN_ZOOM);

    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - _index2.default.DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    resolutionConstraint = _resolutionconstraint2.default.createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return { constraint: resolutionConstraint, maxResolution: maxResolution,
    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor };
};

/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
_ol_View_.createRotationConstraint_ = function (options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return _rotationconstraint2.default.createSnapToZero();
    } else if (constrainRotation === false) {
      return _rotationconstraint2.default.none;
    } else if (typeof constrainRotation === 'number') {
      return _rotationconstraint2.default.createSnapToN(constrainRotation);
    } else {
      return _rotationconstraint2.default.none;
    }
  } else {
    return _rotationconstraint2.default.disable;
  }
};
exports.default = _ol_View_;


},{"./array":42,"./asserts":44,"./centerconstraint":46,"./constraints":51,"./coordinate":57,"./easing":61,"./extent":68,"./geom/geometrytype":98,"./geom/polygon":105,"./geom/simplegeometry":106,"./index":110,"./obj":146,"./object":147,"./proj":158,"./proj/units":165,"./resolutionconstraint":215,"./rotationconstraint":216,"./viewhint":258,"./viewproperty":259}],258:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {number}
 */
var _ol_ViewHint_ = {
  ANIMATING: 0,
  INTERACTING: 1
};

exports.default = _ol_ViewHint_;


},{}],259:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_ViewProperty_ = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};

exports.default = _ol_ViewProperty_;


},{}],260:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('./index');

var _index2 = _interopRequireDefault(_index);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_webgl_ = {};

if (false) {

  /** Constants taken from goog.webgl
   */

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ONE = 1;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.SRC_ALPHA = 0x0302;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TRIANGLES = 0x0004;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TRIANGLE_STRIP = 0x0005;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ARRAY_BUFFER = 0x8892;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STREAM_DRAW = 0x88E0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STATIC_DRAW = 0x88E4;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.DYNAMIC_DRAW = 0x88E8;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.CULL_FACE = 0x0B44;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.BLEND = 0x0BE2;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.STENCIL_TEST = 0x0B90;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.DEPTH_TEST = 0x0B71;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.SCISSOR_TEST = 0x0C11;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_BYTE = 0x1401;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_SHORT = 0x1403;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.UNSIGNED_INT = 0x1405;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FLOAT = 0x1406;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.RGBA = 0x1908;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FRAGMENT_SHADER = 0x8B30;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.VERTEX_SHADER = 0x8B31;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.LINK_STATUS = 0x8B82;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.LINEAR = 0x2601;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_WRAP_S = 0x2802;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_WRAP_T = 0x2803;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE_2D = 0x0DE1;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.TEXTURE0 = 0x84C0;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.CLAMP_TO_EDGE = 0x812F;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.COMPILE_STATUS = 0x8B81;

  /**
   * @const
   * @type {number}
   */
  _ol_webgl_.FRAMEBUFFER = 0x8D40;

  /** end of goog.webgl constants
   */

  /**
   * @const
   * @private
   * @type {Array.<string>}
   */
  _ol_webgl_.CONTEXT_IDS_ = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

  /**
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {Object=} opt_attributes Attributes.
   * @return {WebGLRenderingContext} WebGL rendering context.
   */
  _ol_webgl_.getContext = function (canvas, opt_attributes) {
    var context,
        i,
        ii = _ol_webgl_.CONTEXT_IDS_.length;
    for (i = 0; i < ii; ++i) {
      try {
        context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);
        if (context) {
          return (/** @type {!WebGLRenderingContext} */context
          );
        }
      } catch (e) {
        // pass
      }
    }
    return null;
  };
}
exports.default = _ol_webgl_;


},{"./index":110}],261:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @param {Array.<number>=} opt_arr Array.
   * @param {number=} opt_usage Usage.
   * @struct
   */
  var _ol_webgl_Buffer_ = function (opt_arr, opt_usage) {

    /**
     * @private
     * @type {Array.<number>}
     */
    this.arr_ = opt_arr !== undefined ? opt_arr : [];

    /**
     * @private
     * @type {number}
     */
    this.usage_ = opt_usage !== undefined ? opt_usage : _ol_webgl_Buffer_.Usage_.STATIC_DRAW;
  };

  /**
   * @return {Array.<number>} Array.
   */
  _ol_webgl_Buffer_.prototype.getArray = function () {
    return this.arr_;
  };

  /**
   * @return {number} Usage.
   */
  _ol_webgl_Buffer_.prototype.getUsage = function () {
    return this.usage_;
  };

  /**
   * @enum {number}
   * @private
   */
  _ol_webgl_Buffer_.Usage_ = {
    STATIC_DRAW: _webgl2.default.STATIC_DRAW,
    STREAM_DRAW: _webgl2.default.STREAM_DRAW,
    DYNAMIC_DRAW: _webgl2.default.DYNAMIC_DRAW
  };
}
exports.default = _ol_webgl_Buffer_;


},{"../index":110,"../webgl":260}],262:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _disposable = require('../disposable');

var _disposable2 = _interopRequireDefault(_disposable);

var _array = require('../array');

var _array2 = _interopRequireDefault(_array);

var _events = require('../events');

var _events2 = _interopRequireDefault(_events);

var _obj = require('../obj');

var _obj2 = _interopRequireDefault(_obj);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _contexteventtype = require('../webgl/contexteventtype');

var _contexteventtype2 = _interopRequireDefault(_contexteventtype);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @classdesc
   * A WebGL context for accessing low-level WebGL capabilities.
   *
   * @constructor
   * @extends {ol.Disposable}
   * @param {HTMLCanvasElement} canvas Canvas.
   * @param {WebGLRenderingContext} gl GL.
   */
  var _ol_webgl_Context_ = function (canvas, gl) {

    /**
     * @private
     * @type {HTMLCanvasElement}
     */
    this.canvas_ = canvas;

    /**
     * @private
     * @type {WebGLRenderingContext}
     */
    this.gl_ = gl;

    /**
     * @private
     * @type {Object.<string, ol.WebglBufferCacheEntry>}
     */
    this.bufferCache_ = {};

    /**
     * @private
     * @type {Object.<string, WebGLShader>}
     */
    this.shaderCache_ = {};

    /**
     * @private
     * @type {Object.<string, WebGLProgram>}
     */
    this.programCache_ = {};

    /**
     * @private
     * @type {WebGLProgram}
     */
    this.currentProgram_ = null;

    /**
     * @private
     * @type {WebGLFramebuffer}
     */
    this.hitDetectionFramebuffer_ = null;

    /**
     * @private
     * @type {WebGLTexture}
     */
    this.hitDetectionTexture_ = null;

    /**
     * @private
     * @type {WebGLRenderbuffer}
     */
    this.hitDetectionRenderbuffer_ = null;

    /**
     * @type {boolean}
     */
    this.hasOESElementIndexUint = _array2.default.includes(_index2.default.WEBGL_EXTENSIONS, 'OES_element_index_uint');

    // use the OES_element_index_uint extension if available
    if (this.hasOESElementIndexUint) {
      gl.getExtension('OES_element_index_uint');
    }

    _events2.default.listen(this.canvas_, _contexteventtype2.default.LOST, this.handleWebGLContextLost, this);
    _events2.default.listen(this.canvas_, _contexteventtype2.default.RESTORED, this.handleWebGLContextRestored, this);
  };

  _index2.default.inherits(_ol_webgl_Context_, _disposable2.default);

  /**
   * Just bind the buffer if it's in the cache. Otherwise create
   * the WebGL buffer, bind it, populate it, and add an entry to
   * the cache.
   * @param {number} target Target.
   * @param {ol.webgl.Buffer} buf Buffer.
   */
  _ol_webgl_Context_.prototype.bindBuffer = function (target, buf) {
    var gl = this.getGL();
    var arr = buf.getArray();
    var bufferKey = String(_index2.default.getUid(buf));
    if (bufferKey in this.bufferCache_) {
      var bufferCacheEntry = this.bufferCache_[bufferKey];
      gl.bindBuffer(target, bufferCacheEntry.buffer);
    } else {
      var buffer = gl.createBuffer();
      gl.bindBuffer(target, buffer);
      var /** @type {ArrayBufferView} */arrayBuffer;
      if (target == _webgl2.default.ARRAY_BUFFER) {
        arrayBuffer = new Float32Array(arr);
      } else if (target == _webgl2.default.ELEMENT_ARRAY_BUFFER) {
        arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);
      }
      gl.bufferData(target, arrayBuffer, buf.getUsage());
      this.bufferCache_[bufferKey] = {
        buf: buf,
        buffer: buffer
      };
    }
  };

  /**
   * @param {ol.webgl.Buffer} buf Buffer.
   */
  _ol_webgl_Context_.prototype.deleteBuffer = function (buf) {
    var gl = this.getGL();
    var bufferKey = String(_index2.default.getUid(buf));
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    if (!gl.isContextLost()) {
      gl.deleteBuffer(bufferCacheEntry.buffer);
    }
    delete this.bufferCache_[bufferKey];
  };

  /**
   * @inheritDoc
   */
  _ol_webgl_Context_.prototype.disposeInternal = function () {
    var this$1 = this;

    _events2.default.unlistenAll(this.canvas_);
    var gl = this.getGL();
    if (!gl.isContextLost()) {
      var key;
      for (key in this$1.bufferCache_) {
        gl.deleteBuffer(this$1.bufferCache_[key].buffer);
      }
      for (key in this$1.programCache_) {
        gl.deleteProgram(this$1.programCache_[key]);
      }
      for (key in this$1.shaderCache_) {
        gl.deleteShader(this$1.shaderCache_[key]);
      }
      // delete objects for hit-detection
      gl.deleteFramebuffer(this.hitDetectionFramebuffer_);
      gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);
      gl.deleteTexture(this.hitDetectionTexture_);
    }
  };

  /**
   * @return {HTMLCanvasElement} Canvas.
   */
  _ol_webgl_Context_.prototype.getCanvas = function () {
    return this.canvas_;
  };

  /**
   * Get the WebGL rendering context
   * @return {WebGLRenderingContext} The rendering context.
   * @api
   */
  _ol_webgl_Context_.prototype.getGL = function () {
    return this.gl_;
  };

  /**
   * Get the frame buffer for hit detection.
   * @return {WebGLFramebuffer} The hit detection frame buffer.
   */
  _ol_webgl_Context_.prototype.getHitDetectionFramebuffer = function () {
    if (!this.hitDetectionFramebuffer_) {
      this.initHitDetectionFramebuffer_();
    }
    return this.hitDetectionFramebuffer_;
  };

  /**
   * Get shader from the cache if it's in the cache. Otherwise, create
   * the WebGL shader, compile it, and add entry to cache.
   * @param {ol.webgl.Shader} shaderObject Shader object.
   * @return {WebGLShader} Shader.
   */
  _ol_webgl_Context_.prototype.getShader = function (shaderObject) {
    var shaderKey = String(_index2.default.getUid(shaderObject));
    if (shaderKey in this.shaderCache_) {
      return this.shaderCache_[shaderKey];
    } else {
      var gl = this.getGL();
      var shader = gl.createShader(shaderObject.getType());
      gl.shaderSource(shader, shaderObject.getSource());
      gl.compileShader(shader);
      this.shaderCache_[shaderKey] = shader;
      return shader;
    }
  };

  /**
   * Get the program from the cache if it's in the cache. Otherwise create
   * the WebGL program, attach the shaders to it, and add an entry to the
   * cache.
   * @param {ol.webgl.Fragment} fragmentShaderObject Fragment shader.
   * @param {ol.webgl.Vertex} vertexShaderObject Vertex shader.
   * @return {WebGLProgram} Program.
   */
  _ol_webgl_Context_.prototype.getProgram = function (fragmentShaderObject, vertexShaderObject) {
    var programKey = _index2.default.getUid(fragmentShaderObject) + '/' + _index2.default.getUid(vertexShaderObject);
    if (programKey in this.programCache_) {
      return this.programCache_[programKey];
    } else {
      var gl = this.getGL();
      var program = gl.createProgram();
      gl.attachShader(program, this.getShader(fragmentShaderObject));
      gl.attachShader(program, this.getShader(vertexShaderObject));
      gl.linkProgram(program);
      this.programCache_[programKey] = program;
      return program;
    }
  };

  /**
   * FIXME empy description for jsdoc
   */
  _ol_webgl_Context_.prototype.handleWebGLContextLost = function () {
    _obj2.default.clear(this.bufferCache_);
    _obj2.default.clear(this.shaderCache_);
    _obj2.default.clear(this.programCache_);
    this.currentProgram_ = null;
    this.hitDetectionFramebuffer_ = null;
    this.hitDetectionTexture_ = null;
    this.hitDetectionRenderbuffer_ = null;
  };

  /**
   * FIXME empy description for jsdoc
   */
  _ol_webgl_Context_.prototype.handleWebGLContextRestored = function () {};

  /**
   * Creates a 1x1 pixel framebuffer for the hit-detection.
   * @private
   */
  _ol_webgl_Context_.prototype.initHitDetectionFramebuffer_ = function () {
    var gl = this.gl_;
    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

    var texture = _ol_webgl_Context_.createEmptyTexture(gl, 1, 1);
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    this.hitDetectionFramebuffer_ = framebuffer;
    this.hitDetectionTexture_ = texture;
    this.hitDetectionRenderbuffer_ = renderbuffer;
  };

  /**
   * Use a program.  If the program is already in use, this will return `false`.
   * @param {WebGLProgram} program Program.
   * @return {boolean} Changed.
   * @api
   */
  _ol_webgl_Context_.prototype.useProgram = function (program) {
    if (program == this.currentProgram_) {
      return false;
    } else {
      var gl = this.getGL();
      gl.useProgram(program);
      this.currentProgram_ = program;
      return true;
    }
  };

  /**
   * @param {WebGLRenderingContext} gl WebGL rendering context.
   * @param {number=} opt_wrapS wrapS.
   * @param {number=} opt_wrapT wrapT.
   * @return {WebGLTexture} The texture.
   * @private
   */
  _ol_webgl_Context_.createTexture_ = function (gl, opt_wrapS, opt_wrapT) {
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

    if (opt_wrapS !== undefined) {
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_S, opt_wrapS);
    }
    if (opt_wrapT !== undefined) {
      gl.texParameteri(_webgl2.default.TEXTURE_2D, _webgl2.default.TEXTURE_WRAP_T, opt_wrapT);
    }

    return texture;
  };

  /**
   * @param {WebGLRenderingContext} gl WebGL rendering context.
   * @param {number} width Width.
   * @param {number} height Height.
   * @param {number=} opt_wrapS wrapS.
   * @param {number=} opt_wrapT wrapT.
   * @return {WebGLTexture} The texture.
   */
  _ol_webgl_Context_.createEmptyTexture = function (gl, width, height, opt_wrapS, opt_wrapT) {
    var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    return texture;
  };

  /**
   * @param {WebGLRenderingContext} gl WebGL rendering context.
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
   * @param {number=} opt_wrapS wrapS.
   * @param {number=} opt_wrapT wrapT.
   * @return {WebGLTexture} The texture.
   */
  _ol_webgl_Context_.createTexture = function (gl, image, opt_wrapS, opt_wrapT) {
    var texture = _ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    return texture;
  };
}
exports.default = _ol_webgl_Context_;


},{"../array":42,"../disposable":59,"../events":62,"../index":110,"../obj":146,"../webgl":260,"../webgl/contexteventtype":263}],263:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @enum {string}
 */
var _ol_webgl_ContextEventType_ = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};

exports.default = _ol_webgl_ContextEventType_;


},{}],264:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _shader = require('../webgl/shader');

var _shader2 = _interopRequireDefault(_shader);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.webgl.Shader}
   * @param {string} source Source.
   * @struct
   */
  var _ol_webgl_Fragment_ = function (source) {
    _shader2.default.call(this, source);
  };

  _index2.default.inherits(_ol_webgl_Fragment_, _shader2.default);

  /**
   * @inheritDoc
   */
  _ol_webgl_Fragment_.prototype.getType = function () {
    return _webgl2.default.FRAGMENT_SHADER;
  };
}
exports.default = _ol_webgl_Fragment_;


},{"../index":110,"../webgl":260,"../webgl/shader":265}],265:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _functions = require('../functions');

var _functions2 = _interopRequireDefault(_functions);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @abstract
   * @param {string} source Source.
   * @struct
   */
  var _ol_webgl_Shader_ = function (source) {

    /**
     * @private
     * @type {string}
     */
    this.source_ = source;
  };

  /**
   * @abstract
   * @return {number} Type.
   */
  _ol_webgl_Shader_.prototype.getType = function () {};

  /**
   * @return {string} Source.
   */
  _ol_webgl_Shader_.prototype.getSource = function () {
    return this.source_;
  };

  /**
   * @return {boolean} Is animated?
   */
  _ol_webgl_Shader_.prototype.isAnimated = _functions2.default.FALSE;
}
exports.default = _ol_webgl_Shader_;


},{"../functions":78,"../index":110}],266:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require('../index');

var _index2 = _interopRequireDefault(_index);

var _webgl = require('../webgl');

var _webgl2 = _interopRequireDefault(_webgl);

var _shader = require('../webgl/shader');

var _shader2 = _interopRequireDefault(_shader);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

if (false) {
  /**
   * @constructor
   * @extends {ol.webgl.Shader}
   * @param {string} source Source.
   * @struct
   */
  var _ol_webgl_Vertex_ = function (source) {
    _shader2.default.call(this, source);
  };

  _index2.default.inherits(_ol_webgl_Vertex_, _shader2.default);

  /**
   * @inheritDoc
   */
  _ol_webgl_Vertex_.prototype.getType = function () {
    return _webgl2.default.VERTEX_SHADER;
  };
}
exports.default = _ol_webgl_Vertex_;


},{"../index":110,"../webgl":260,"../webgl/shader":265}],267:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _array = require('./array');

var _array2 = _interopRequireDefault(_array);

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}

var _ol_xml_ = {};

/**
 * This document should be used when creating nodes for XML serializations. This
 * document is also used by {@link ol.xml.createElementNS} and
 * {@link ol.xml.setAttributeNS}
 * @const
 * @type {Document}
 */
_ol_xml_.DOCUMENT = document.implementation.createDocument('', '', null);

/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Node} Node.
 */
_ol_xml_.createElementNS = function (namespaceURI, qualifiedName) {
  return _ol_xml_.DOCUMENT.createElementNS(namespaceURI, qualifiedName);
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
_ol_xml_.getAllTextContent = function (node, normalizeWhitespace) {
  return _ol_xml_.getAllTextContent_(node, normalizeWhitespace, []).join('');
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<string>} accumulator Accumulator.
 * @private
 * @return {Array.<string>} Accumulator.
 */
_ol_xml_.getAllTextContent_ = function (node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      _ol_xml_.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
};

/**
 * @param {?} value Value.
 * @return {boolean} Is document.
 */
_ol_xml_.isDocument = function (value) {
  return value instanceof Document;
};

/**
 * @param {?} value Value.
 * @return {boolean} Is node.
 */
_ol_xml_.isNode = function (value) {
  return value instanceof Node;
};

/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */
_ol_xml_.getAttributeNS = function (node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
};

/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @param {string|number} value Value.
 */
_ol_xml_.setAttributeNS = function (node, namespaceURI, name, value) {
  node.setAttributeNS(namespaceURI, name, value);
};

/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */
_ol_xml_.parse = function (xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
};

/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}
 *     valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeArrayExtender = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this, node, objectStack);
      if (value !== undefined) {
        var array = /** @type {Array.<*>} */
        objectStack[objectStack.length - 1];
        _array2.default.extend(array, value);
      }
    }
  );
};

/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeArrayPusher = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    }
  );
};

/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeReplacer = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
};

/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeObjectPropertyPusher = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var object = /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        var array;
        if (property in object) {
          array = object[property];
        } else {
          array = object[property] = [];
        }
        array.push(value);
      }
    }
  );
};

/**
 * Make an object property setter function.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeObjectPropertySetter = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var object = /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        object[property] = value;
      }
    }
  );
};

/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */
_ol_xml_.makeChildAppender = function (nodeWriter, opt_this) {
  return function (node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
};

/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link ol.xml.serialize}. This can be used by the parent writer to have the
 * 'nodeWriter' called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */
_ol_xml_.makeArraySerializer = function (nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = _ol_xml_.makeSimpleNodeFactory(node.localName);
    }
    _ol_xml_.serialize(serializersNS, nodeFactory, value, objectStack);
  };
};

/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string=} opt_nodeName Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.
 */
_ol_xml_.makeSimpleNodeFactory = function (opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return (
    /**
     * @param {*} value Value.
     * @param {Array.<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
      var context = objectStack[objectStack.length - 1];
      var node = context.node;
      var nodeName = fixedNodeName;
      if (nodeName === undefined) {
        nodeName = opt_nodeName;
      }
      var namespaceURI = opt_namespaceURI;
      if (opt_namespaceURI === undefined) {
        namespaceURI = node.namespaceURI;
      }
      return _ol_xml_.createElementNS(namespaceURI, /** @type {string} */nodeName);
    }
  );
};

/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 */
_ol_xml_.OBJECT_PROPERTY_NODE_FACTORY = _ol_xml_.makeSimpleNodeFactory();

/**
 * Create an array of `values` to be used with {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array.<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array.<V>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 * @template V
 */
_ol_xml_.makeSequence = function (object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);
  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
};

/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */
_ol_xml_.makeStructureNS = function (namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
};

/**
 * Parse a node using the parsers and object stack.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 */
_ol_xml_.parseNode = function (parsersNS, node, objectStack, opt_this) {
  var n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];
    if (parsers !== undefined) {
      var parser = parsers[n.localName];
      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
};

/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 * @return {T} Object.
 * @template T
 */
_ol_xml_.pushParseAndPop = function (object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);
  _ol_xml_.parseNode(parsersNS, node, objectStack, opt_this);
  return objectStack.pop();
};

/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */
_ol_xml_.serialize = function (serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;
  for (var i = 0; i < length; ++i) {
    value = values[i];
    if (value !== undefined) {
      node = nodeFactory.call(opt_this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);
      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
};

/**
 * @param {O} object Object.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */
_ol_xml_.pushSerializeAndPop = function (object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  _ol_xml_.serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
  return objectStack.pop();
};
exports.default = _ol_xml_;


},{"./array":42}],268:[function(require,module,exports){
'use strict';

module.exports = Pbf;

var ieee754 = require('ieee754');

function Pbf(buf) {
    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
    this.pos = 0;
    this.type = 0;
    this.length = this.buf.length;
}

Pbf.Varint = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum
Pbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64
Pbf.Bytes = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields
Pbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32

var SHIFT_LEFT_32 = (1 << 16) * (1 << 16),
    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;

Pbf.prototype = {

    destroy: function () {
        this.buf = null;
    },

    // === READING =================================================================

    readFields: function (readField, result, end) {
        var this$1 = this;

        end = end || this.length;

        while (this.pos < end) {
            var val = this$1.readVarint(),
                tag = val >> 3,
                startPos = this$1.pos;

            this$1.type = val & 0x7;
            readField(tag, result, this$1);

            if (this$1.pos === startPos) { this$1.skip(val); }
        }
        return result;
    },

    readMessage: function (readField, result) {
        return this.readFields(readField, result, this.readVarint() + this.pos);
    },

    readFixed32: function () {
        var val = readUInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    readSFixed32: function () {
        var val = readInt32(this.buf, this.pos);
        this.pos += 4;
        return val;
    },

    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)

    readFixed64: function () {
        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readSFixed64: function () {
        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
        this.pos += 8;
        return val;
    },

    readFloat: function () {
        var val = ieee754.read(this.buf, this.pos, true, 23, 4);
        this.pos += 4;
        return val;
    },

    readDouble: function () {
        var val = ieee754.read(this.buf, this.pos, true, 52, 8);
        this.pos += 8;
        return val;
    },

    readVarint: function (isSigned) {
        var buf = this.buf,
            val,
            b;

        b = buf[this.pos++];val = b & 0x7f;if (b < 0x80) { return val; }
        b = buf[this.pos++];val |= (b & 0x7f) << 7;if (b < 0x80) { return val; }
        b = buf[this.pos++];val |= (b & 0x7f) << 14;if (b < 0x80) { return val; }
        b = buf[this.pos++];val |= (b & 0x7f) << 21;if (b < 0x80) { return val; }
        b = buf[this.pos];val |= (b & 0x0f) << 28;

        return readVarintRemainder(val, isSigned, this);
    },

    readVarint64: function () {
        // for compatibility with v2.0.1
        return this.readVarint(true);
    },

    readSVarint: function () {
        var num = this.readVarint();
        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding
    },

    readBoolean: function () {
        return Boolean(this.readVarint());
    },

    readString: function () {
        var end = this.readVarint() + this.pos,
            str = readUtf8(this.buf, this.pos, end);
        this.pos = end;
        return str;
    },

    readBytes: function () {
        var end = this.readVarint() + this.pos,
            buffer = this.buf.subarray(this.pos, end);
        this.pos = end;
        return buffer;
    },

    // verbose for performance reasons; doesn't affect gzipped size

    readPackedVarint: function (arr, isSigned) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readVarint(isSigned)); }
        return arr;
    },
    readPackedSVarint: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSVarint()); }
        return arr;
    },
    readPackedBoolean: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readBoolean()); }
        return arr;
    },
    readPackedFloat: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFloat()); }
        return arr;
    },
    readPackedDouble: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readDouble()); }
        return arr;
    },
    readPackedFixed32: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed32()); }
        return arr;
    },
    readPackedSFixed32: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed32()); }
        return arr;
    },
    readPackedFixed64: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readFixed64()); }
        return arr;
    },
    readPackedSFixed64: function (arr) {
        var this$1 = this;

        var end = readPackedEnd(this);
        arr = arr || [];
        while (this.pos < end) { arr.push(this$1.readSFixed64()); }
        return arr;
    },

    skip: function (val) {
        var type = val & 0x7;
        if (type === Pbf.Varint) { while (this.buf[this.pos++] > 0x7f) {} } else if (type === Pbf.Bytes) { this.pos = this.readVarint() + this.pos; }else if (type === Pbf.Fixed32) { this.pos += 4; }else if (type === Pbf.Fixed64) { this.pos += 8; }else { throw new Error('Unimplemented type: ' + type); }
    },

    // === WRITING =================================================================

    writeTag: function (tag, type) {
        this.writeVarint(tag << 3 | type);
    },

    realloc: function (min) {
        var length = this.length || 16;

        while (length < this.pos + min) { length *= 2; }

        if (length !== this.length) {
            var buf = new Uint8Array(length);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length;
        }
    },

    finish: function () {
        this.length = this.pos;
        this.pos = 0;
        return this.buf.subarray(0, this.length);
    },

    writeFixed32: function (val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeSFixed32: function (val) {
        this.realloc(4);
        writeInt32(this.buf, val, this.pos);
        this.pos += 4;
    },

    writeFixed64: function (val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeSFixed64: function (val) {
        this.realloc(8);
        writeInt32(this.buf, val & -1, this.pos);
        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
        this.pos += 8;
    },

    writeVarint: function (val) {
        val = +val || 0;

        if (val > 0xfffffff || val < 0) {
            writeBigVarint(val, this);
            return;
        }

        this.realloc(4);

        this.buf[this.pos++] = val & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) { return; }
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) { return; }
        this.buf[this.pos++] = (val >>>= 7) & 0x7f | (val > 0x7f ? 0x80 : 0);if (val <= 0x7f) { return; }
        this.buf[this.pos++] = val >>> 7 & 0x7f;
    },

    writeSVarint: function (val) {
        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
    },

    writeBoolean: function (val) {
        this.writeVarint(Boolean(val));
    },

    writeString: function (str) {
        str = String(str);
        this.realloc(str.length * 4);

        this.pos++; // reserve 1 byte for short string length

        var startPos = this.pos;
        // write the string directly to the buffer and see how much was written
        this.pos = writeUtf8(this.buf, str, this.pos);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeFloat: function (val) {
        this.realloc(4);
        ieee754.write(this.buf, val, this.pos, true, 23, 4);
        this.pos += 4;
    },

    writeDouble: function (val) {
        this.realloc(8);
        ieee754.write(this.buf, val, this.pos, true, 52, 8);
        this.pos += 8;
    },

    writeBytes: function (buffer) {
        var this$1 = this;

        var len = buffer.length;
        this.writeVarint(len);
        this.realloc(len);
        for (var i = 0; i < len; i++) { this$1.buf[this$1.pos++] = buffer[i]; }
    },

    writeRawMessage: function (fn, obj) {
        this.pos++; // reserve 1 byte for short message length

        // write the message directly to the buffer and see how much was written
        var startPos = this.pos;
        fn(obj, this);
        var len = this.pos - startPos;

        if (len >= 0x80) { makeRoomForExtraLength(startPos, len, this); }

        // finally, write the message length in the reserved place and restore the position
        this.pos = startPos - 1;
        this.writeVarint(len);
        this.pos += len;
    },

    writeMessage: function (tag, fn, obj) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeRawMessage(fn, obj);
    },

    writePackedVarint: function (tag, arr) {
        this.writeMessage(tag, writePackedVarint, arr);
    },
    writePackedSVarint: function (tag, arr) {
        this.writeMessage(tag, writePackedSVarint, arr);
    },
    writePackedBoolean: function (tag, arr) {
        this.writeMessage(tag, writePackedBoolean, arr);
    },
    writePackedFloat: function (tag, arr) {
        this.writeMessage(tag, writePackedFloat, arr);
    },
    writePackedDouble: function (tag, arr) {
        this.writeMessage(tag, writePackedDouble, arr);
    },
    writePackedFixed32: function (tag, arr) {
        this.writeMessage(tag, writePackedFixed32, arr);
    },
    writePackedSFixed32: function (tag, arr) {
        this.writeMessage(tag, writePackedSFixed32, arr);
    },
    writePackedFixed64: function (tag, arr) {
        this.writeMessage(tag, writePackedFixed64, arr);
    },
    writePackedSFixed64: function (tag, arr) {
        this.writeMessage(tag, writePackedSFixed64, arr);
    },

    writeBytesField: function (tag, buffer) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeBytes(buffer);
    },
    writeFixed32Field: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFixed32(val);
    },
    writeSFixed32Field: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeSFixed32(val);
    },
    writeFixed64Field: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeFixed64(val);
    },
    writeSFixed64Field: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeSFixed64(val);
    },
    writeVarintField: function (tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeVarint(val);
    },
    writeSVarintField: function (tag, val) {
        this.writeTag(tag, Pbf.Varint);
        this.writeSVarint(val);
    },
    writeStringField: function (tag, str) {
        this.writeTag(tag, Pbf.Bytes);
        this.writeString(str);
    },
    writeFloatField: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed32);
        this.writeFloat(val);
    },
    writeDoubleField: function (tag, val) {
        this.writeTag(tag, Pbf.Fixed64);
        this.writeDouble(val);
    },
    writeBooleanField: function (tag, val) {
        this.writeVarintField(tag, Boolean(val));
    }
};

function readVarintRemainder(l, s, p) {
    var buf = p.buf,
        h,
        b;

    b = buf[p.pos++];h = (b & 0x70) >> 4;if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++];h |= (b & 0x7f) << 3;if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++];h |= (b & 0x7f) << 10;if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++];h |= (b & 0x7f) << 17;if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++];h |= (b & 0x7f) << 24;if (b < 0x80) { return toNum(l, h, s); }
    b = buf[p.pos++];h |= (b & 0x01) << 31;if (b < 0x80) { return toNum(l, h, s); }

    throw new Error('Expected varint not more than 10 bytes');
}

function readPackedEnd(pbf) {
    return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
}

function toNum(low, high, isSigned) {
    if (isSigned) {
        return high * 0x100000000 + (low >>> 0);
    }

    return (high >>> 0) * 0x100000000 + (low >>> 0);
}

function writeBigVarint(val, pbf) {
    var low, high;

    if (val >= 0) {
        low = val % 0x100000000 | 0;
        high = val / 0x100000000 | 0;
    } else {
        low = ~(-val % 0x100000000);
        high = ~(-val / 0x100000000);

        if (low ^ 0xffffffff) {
            low = low + 1 | 0;
        } else {
            low = 0;
            high = high + 1 | 0;
        }
    }

    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {
        throw new Error('Given varint doesn\'t fit into 10 bytes');
    }

    pbf.realloc(10);

    writeBigVarintLow(low, high, pbf);
    writeBigVarintHigh(high, pbf);
}

function writeBigVarintLow(low, high, pbf) {
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos++] = low & 0x7f | 0x80;low >>>= 7;
    pbf.buf[pbf.pos] = low & 0x7f;
}

function writeBigVarintHigh(high, pbf) {
    var lsb = (high & 0x07) << 4;

    pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 0x80 : 0);if (!high) { return; }
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) { return; }
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) { return; }
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) { return; }
    pbf.buf[pbf.pos++] = high & 0x7f | ((high >>>= 7) ? 0x80 : 0);if (!high) { return; }
    pbf.buf[pbf.pos++] = high & 0x7f;
}

function makeRoomForExtraLength(startPos, len, pbf) {
    var extraLen = len <= 0x3fff ? 1 : len <= 0x1fffff ? 2 : len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));

    // if 1 byte isn't enough for encoding message length, shift the data to the right
    pbf.realloc(extraLen);
    for (var i = pbf.pos - 1; i >= startPos; i--) { pbf.buf[i + extraLen] = pbf.buf[i]; }
}

function writePackedVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeVarint(arr[i]); }
}
function writePackedSVarint(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeSVarint(arr[i]); }
}
function writePackedFloat(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeFloat(arr[i]); }
}
function writePackedDouble(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeDouble(arr[i]); }
}
function writePackedBoolean(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeBoolean(arr[i]); }
}
function writePackedFixed32(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeFixed32(arr[i]); }
}
function writePackedSFixed32(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeSFixed32(arr[i]); }
}
function writePackedFixed64(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeFixed64(arr[i]); }
}
function writePackedSFixed64(arr, pbf) {
    for (var i = 0; i < arr.length; i++) { pbf.writeSFixed64(arr[i]); }
}

// Buffer code below from https://github.com/feross/buffer, MIT-licensed

function readUInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 0x1000000;
}

function writeInt32(buf, val, pos) {
    buf[pos] = val;
    buf[pos + 1] = val >>> 8;
    buf[pos + 2] = val >>> 16;
    buf[pos + 3] = val >>> 24;
}

function readInt32(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
}

function readUtf8(buf, pos, end) {
    var str = '';
    var i = pos;

    while (i < end) {
        var b0 = buf[i];
        var c = null; // codepoint
        var bytesPerSequence = b0 > 0xEF ? 4 : b0 > 0xDF ? 3 : b0 > 0xBF ? 2 : 1;

        if (i + bytesPerSequence > end) { break; }

        var b1, b2, b3;

        if (bytesPerSequence === 1) {
            if (b0 < 0x80) {
                c = b0;
            }
        } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 0xC0) === 0x80) {
                c = (b0 & 0x1F) << 0x6 | b1 & 0x3F;
                if (c <= 0x7F) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | b2 & 0x3F;
                if (c <= 0x7FF || c >= 0xD800 && c <= 0xDFFF) {
                    c = null;
                }
            }
        } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | b3 & 0x3F;
                if (c <= 0xFFFF || c >= 0x110000) {
                    c = null;
                }
            }
        }

        if (c === null) {
            c = 0xFFFD;
            bytesPerSequence = 1;
        } else if (c > 0xFFFF) {
            c -= 0x10000;
            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);
            c = 0xDC00 | c & 0x3FF;
        }

        str += String.fromCharCode(c);
        i += bytesPerSequence;
    }

    return str;
}

function writeUtf8(buf, str, pos) {
    for (var i = 0, c, lead; i < str.length; i++) {
        c = str.charCodeAt(i); // code point

        if (c > 0xD7FF && c < 0xE000) {
            if (lead) {
                if (c < 0xDC00) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                    lead = c;
                    continue;
                } else {
                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;
                    lead = null;
                }
            } else {
                if (c > 0xDBFF || i + 1 === str.length) {
                    buf[pos++] = 0xEF;
                    buf[pos++] = 0xBF;
                    buf[pos++] = 0xBD;
                } else {
                    lead = c;
                }
                continue;
            }
        } else if (lead) {
            buf[pos++] = 0xEF;
            buf[pos++] = 0xBF;
            buf[pos++] = 0xBD;
            lead = null;
        }

        if (c < 0x80) {
            buf[pos++] = c;
        } else {
            if (c < 0x800) {
                buf[pos++] = c >> 0x6 | 0xC0;
            } else {
                if (c < 0x10000) {
                    buf[pos++] = c >> 0xC | 0xE0;
                } else {
                    buf[pos++] = c >> 0x12 | 0xF0;
                    buf[pos++] = c >> 0xC & 0x3F | 0x80;
                }
                buf[pos++] = c >> 0x6 & 0x3F | 0x80;
            }
            buf[pos++] = c & 0x3F | 0x80;
        }
    }
    return pos;
}


},{"ieee754":7}],269:[function(require,module,exports){
'use strict';

module.exports = Point;

function Point(x, y) {
    this.x = x;
    this.y = y;
}

Point.prototype = {
    clone: function () {
        return new Point(this.x, this.y);
    },

    add: function (p) {
        return this.clone()._add(p);
    },
    sub: function (p) {
        return this.clone()._sub(p);
    },
    mult: function (k) {
        return this.clone()._mult(k);
    },
    div: function (k) {
        return this.clone()._div(k);
    },
    rotate: function (a) {
        return this.clone()._rotate(a);
    },
    matMult: function (m) {
        return this.clone()._matMult(m);
    },
    unit: function () {
        return this.clone()._unit();
    },
    perp: function () {
        return this.clone()._perp();
    },
    round: function () {
        return this.clone()._round();
    },

    mag: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    },

    equals: function (p) {
        return this.x === p.x && this.y === p.y;
    },

    dist: function (p) {
        return Math.sqrt(this.distSqr(p));
    },

    distSqr: function (p) {
        var dx = p.x - this.x,
            dy = p.y - this.y;
        return dx * dx + dy * dy;
    },

    angle: function () {
        return Math.atan2(this.y, this.x);
    },

    angleTo: function (b) {
        return Math.atan2(this.y - b.y, this.x - b.x);
    },

    angleWith: function (b) {
        return this.angleWithSep(b.x, b.y);
    },

    // Find the angle of the two vectors, solving the formula for the cross product a x b = |a||b|sin() for .
    angleWithSep: function (x, y) {
        return Math.atan2(this.x * y - this.y * x, this.x * x + this.y * y);
    },

    _matMult: function (m) {
        var x = m[0] * this.x + m[1] * this.y,
            y = m[2] * this.x + m[3] * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _add: function (p) {
        this.x += p.x;
        this.y += p.y;
        return this;
    },

    _sub: function (p) {
        this.x -= p.x;
        this.y -= p.y;
        return this;
    },

    _mult: function (k) {
        this.x *= k;
        this.y *= k;
        return this;
    },

    _div: function (k) {
        this.x /= k;
        this.y /= k;
        return this;
    },

    _unit: function () {
        this._div(this.mag());
        return this;
    },

    _perp: function () {
        var y = this.y;
        this.y = this.x;
        this.x = -y;
        return this;
    },

    _rotate: function (angle) {
        var cos = Math.cos(angle),
            sin = Math.sin(angle),
            x = cos * this.x - sin * this.y,
            y = sin * this.x + cos * this.y;
        this.x = x;
        this.y = y;
        return this;
    },

    _round: function () {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
    }
};

// constructs Point from an array if necessary
Point.convert = function (a) {
    if (a instanceof Point) {
        return a;
    }
    if (Array.isArray(a)) {
        return new Point(a[0], a[1]);
    }
    return a;
};


},{}],270:[function(require,module,exports){
'use strict';

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var arguments$1 = arguments;

    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments$1[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};


},{}],271:[function(require,module,exports){
'use strict';

module.exports = partialSort;

// Floyd-Rivest selection algorithm:
// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];
// The k-th element will have the (k - left + 1)th smallest value in [left, right]

function partialSort(arr, k, left, right, compare) {
    left = left || 0;
    right = right || arr.length - 1;
    compare = compare || defaultCompare;

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            partialSort(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) { swap(arr, left, right); }

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) { i++; }
            while (compare(arr[j], t) > 0) { j--; }
        }

        if (compare(arr[left], t) === 0) { swap(arr, left, j); }else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) { left = j + 1; }
        if (k <= j) { right = j - 1; }
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}


},{}],272:[function(require,module,exports){
'use strict';

module.exports = rbush;

var quickselect = require('quickselect');

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) { return new rbush(maxEntries, format); }

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {
        var this$1 = this;


        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) { return result; }

        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) { result.push(child); }else if (contains(bbox, childBBox)) { this$1._all(child, result); }else { nodesToSearch.push(child); }
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) { return false; }

        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) { return true; }
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        var this$1 = this;

        if (!(data && data.length)) { return this; }

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this$1.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;
        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);
        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) { this._insert(item, this.data.height - 1); }
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        var this$1 = this;

        if (!item) { return this; }

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) {
                // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) {
                // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this$1._condense(path);
                    return this$1;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) {
                // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];
            } else if (parent) {
                // go right
                i++;
                node = parent.children[i];
                goingUp = false;
            } else { node = null; } // nothing found
        }

        return this;
    },

    toBBox: function (item) {
        return item;
    },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () {
        return this.data;
    },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) { result.push.apply(result, node.children); }else { nodesToSearch.push.apply(nodesToSearch, node.children); }

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {
        var this$1 = this;


        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this$1.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this$1._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) { break; }

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;
                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {
        var this$1 = this;


        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this$1._maxEntries) {
                this$1._split(insertPath, level);
                level--;
            } else { break; }
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) { insertPath[level - 1].children.push(newNode); }else { this._splitRoot(node, newNode); }
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {
        var this$1 = this;


        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this$1.toBBox);
            bbox2 = distBBox(node, i, M, this$1.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;
            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) { node.children.sort(compareMinX); }
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        var this$1 = this;

        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                } else { this$1.clear(); }
            } else { calcBBox(path[i], this$1.toBBox); }
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) { return items.indexOf(item); }

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) { return i; }
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) { destNode = createNode(null); }
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) {
    return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
    return a.minY - b.minY;
}

function bboxArea(a) {
    return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
    return a.maxX - a.minX + (a.maxY - a.minY);
}

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) { continue; }

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


},{"quickselect":271}],273:[function(require,module,exports){
'use strict';

var Assertion = require('should').Assertion;
var util = require('util');

Assertion.add('approximatelyDeep', function (other, delta, description) {
    this.params = {
        operator: 'to be approximately deep close to ' + util.inspect(other) + ' (' + delta + ')',
        message: description
    };
    goDeeper(this.obj, other, delta, this);
});

function goDeeper(actual, expected, maxDifference, assertion) {
    if (typeof actual === 'number') {
        return assertion.assert(actual === expected || Math.abs(actual - expected) <= maxDifference);
    } else if (Array.isArray(actual)) {
        var l = actual.length;
        assertion.assert(l === expected.length);
        for (var i = 0; i < l; i++) {
            goDeeper(actual[i], expected[i], maxDifference, assertion);
        }
    } else {
        // error for all other types
        assertion.assert(false);
    }
}


},{"should":281,"util":284}],274:[function(require,module,exports){
'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var t = _interopDefault(require('should-type'));

function format(msg) {
  var args = arguments;
  for (var i = 1, l = args.length; i < l; i++) {
    msg = msg.replace(/%s/, args[i]);
  }
  return msg;
}

var hasOwnProperty = Object.prototype.hasOwnProperty;

function EqualityFail(a, b, reason, path) {
  this.a = a;
  this.b = b;
  this.reason = reason;
  this.path = path;
}

function typeToString(tp) {
  return tp.type + (tp.cls ? '(' + tp.cls + (tp.sub ? ' ' + tp.sub : '') + ')' : '');
}

var PLUS_0_AND_MINUS_0 = '+0 is not equal to -0';
var DIFFERENT_TYPES = 'A has type %s and B has type %s';
var EQUALITY = 'A is not equal to B';
var EQUALITY_PROTOTYPE = 'A and B have different prototypes';
var WRAPPED_VALUE = 'A wrapped value is not equal to B wrapped value';
var FUNCTION_SOURCES = 'function A is not equal to B by source code value (via .toString call)';
var MISSING_KEY = '%s has no key %s';
var SET_MAP_MISSING_KEY = 'Set/Map missing key %s';

var DEFAULT_OPTIONS = {
  checkProtoEql: true,
  checkSubType: true,
  plusZeroAndMinusZeroEqual: true,
  collectAllFails: false
};

function setBooleanDefault(property, obj, opts, defaults) {
  obj[property] = typeof opts[property] !== 'boolean' ? defaults[property] : opts[property];
}

var METHOD_PREFIX = '_check_';

function EQ(opts, a, b, path) {
  opts = opts || {};

  setBooleanDefault('checkProtoEql', this, opts, DEFAULT_OPTIONS);
  setBooleanDefault('plusZeroAndMinusZeroEqual', this, opts, DEFAULT_OPTIONS);
  setBooleanDefault('checkSubType', this, opts, DEFAULT_OPTIONS);
  setBooleanDefault('collectAllFails', this, opts, DEFAULT_OPTIONS);

  this.a = a;
  this.b = b;

  this._meet = opts._meet || [];

  this.fails = opts.fails || [];

  this.path = path || [];
}

function ShortcutError(fail) {
  this.name = 'ShortcutError';
  this.message = 'fail fast';
  this.fail = fail;
}

ShortcutError.prototype = Object.create(Error.prototype);

EQ.checkStrictEquality = function (a, b) {
  this.collectFail(a !== b, EQUALITY);
};

EQ.add = function add(type, cls, sub, f) {
  var args = Array.prototype.slice.call(arguments);
  f = args.pop();
  EQ.prototype[METHOD_PREFIX + args.join('_')] = f;
};

EQ.prototype = {
  check: function () {
    try {
      this.check0();
    } catch (e) {
      if (e instanceof ShortcutError) {
        return [e.fail];
      }
      throw e;
    }
    return this.fails;
  },

  check0: function () {
    var a = this.a;
    var b = this.b;

    // equal a and b exit early
    if (a === b) {
      // check for +0 !== -0;
      return this.collectFail(a === 0 && 1 / a !== 1 / b && !this.plusZeroAndMinusZeroEqual, PLUS_0_AND_MINUS_0);
    }

    var typeA = t(a);
    var typeB = t(b);

    // if objects has different types they are not equal
    if (typeA.type !== typeB.type || typeA.cls !== typeB.cls || typeA.sub !== typeB.sub) {
      return this.collectFail(true, format(DIFFERENT_TYPES, typeToString(typeA), typeToString(typeB)));
    }

    // as types the same checks type specific things
    var name1 = typeA.type,
        name2 = typeA.type;
    if (typeA.cls) {
      name1 += '_' + typeA.cls;
      name2 += '_' + typeA.cls;
    }
    if (typeA.sub) {
      name2 += '_' + typeA.sub;
    }

    var f = this[METHOD_PREFIX + name2] || this[METHOD_PREFIX + name1] || this[METHOD_PREFIX + typeA.type] || this.defaultCheck;

    f.call(this, this.a, this.b);
  },

  collectFail: function (comparison, reason, showReason) {
    if (comparison) {
      var res = new EqualityFail(this.a, this.b, reason, this.path);
      res.showReason = !!showReason;

      this.fails.push(res);

      if (!this.collectAllFails) {
        throw new ShortcutError(res);
      }
    }
  },

  checkPlainObjectsEquality: function (a, b) {
    var this$1 = this;

    // compare deep objects and arrays
    // stacks contain references only
    //
    var meet = this._meet;
    var m = this._meet.length;
    while (m--) {
      var st = meet[m];
      if (st[0] === a && st[1] === b) {
        return;
      }
    }

    // add `a` and `b` to the stack of traversed objects
    meet.push([a, b]);

    // TODO maybe something else like getOwnPropertyNames
    var key;
    for (key in b) {
      if (hasOwnProperty.call(b, key)) {
        if (hasOwnProperty.call(a, key)) {
          this$1.checkPropertyEquality(key);
        } else {
          this$1.collectFail(true, format(MISSING_KEY, 'A', key));
        }
      }
    }

    // ensure both objects have the same number of properties
    for (key in a) {
      if (hasOwnProperty.call(a, key)) {
        this$1.collectFail(!hasOwnProperty.call(b, key), format(MISSING_KEY, 'B', key));
      }
    }

    meet.pop();

    if (this.checkProtoEql) {
      //TODO should i check prototypes for === or use eq?
      this.collectFail(Object.getPrototypeOf(a) !== Object.getPrototypeOf(b), EQUALITY_PROTOTYPE, true);
    }
  },

  checkPropertyEquality: function (propertyName) {
    var _eq = new EQ(this, this.a[propertyName], this.b[propertyName], this.path.concat([propertyName]));
    _eq.check0();
  },

  defaultCheck: EQ.checkStrictEquality
};

EQ.add(t.NUMBER, function (a, b) {
  this.collectFail(a !== a && b === b || b !== b && a === a || a !== b && a === a && b === b, EQUALITY);
});

[t.SYMBOL, t.BOOLEAN, t.STRING].forEach(function (tp) {
  EQ.add(tp, EQ.checkStrictEquality);
});

EQ.add(t.FUNCTION, function (a, b) {
  // functions are compared by their source code
  this.collectFail(a.toString() !== b.toString(), FUNCTION_SOURCES);
  // check user properties
  this.checkPlainObjectsEquality(a, b);
});

EQ.add(t.OBJECT, t.REGEXP, function (a, b) {
  var this$1 = this;

  // check regexp flags
  var flags = ['source', 'global', 'multiline', 'lastIndex', 'ignoreCase', 'sticky', 'unicode'];
  while (flags.length) {
    this$1.checkPropertyEquality(flags.shift());
  }
  // check user properties
  this.checkPlainObjectsEquality(a, b);
});

EQ.add(t.OBJECT, t.DATE, function (a, b) {
  //check by timestamp only (using .valueOf)
  this.collectFail(+a !== +b, EQUALITY);
  // check user properties
  this.checkPlainObjectsEquality(a, b);
});

[t.NUMBER, t.BOOLEAN, t.STRING].forEach(function (tp) {
  EQ.add(t.OBJECT, tp, function (a, b) {
    //primitive type wrappers
    this.collectFail(a.valueOf() !== b.valueOf(), WRAPPED_VALUE);
    // check user properties
    this.checkPlainObjectsEquality(a, b);
  });
});

EQ.add(t.OBJECT, function (a, b) {
  this.checkPlainObjectsEquality(a, b);
});

[t.ARRAY, t.ARGUMENTS, t.TYPED_ARRAY].forEach(function (tp) {
  EQ.add(t.OBJECT, tp, function (a, b) {
    this.checkPropertyEquality('length');

    this.checkPlainObjectsEquality(a, b);
  });
});

EQ.add(t.OBJECT, t.ARRAY_BUFFER, function (a, b) {
  this.checkPropertyEquality('byteLength');

  this.checkPlainObjectsEquality(a, b);
});

EQ.add(t.OBJECT, t.ERROR, function (a, b) {
  this.checkPropertyEquality('name');
  this.checkPropertyEquality('message');

  this.checkPlainObjectsEquality(a, b);
});

EQ.add(t.OBJECT, t.BUFFER, function (a) {
  var this$1 = this;

  this.checkPropertyEquality('length');

  var l = a.length;
  while (l--) {
    this$1.checkPropertyEquality(l);
  }

  //we do not check for user properties because
  //node Buffer have some strange hidden properties
});

[t.MAP, t.SET, t.WEAK_MAP, t.WEAK_SET].forEach(function (tp) {
  EQ.add(t.OBJECT, tp, function (a, b) {
    var this$1 = this;

    this._meet.push([a, b]);

    var iteratorA = a.entries();
    for (var nextA = iteratorA.next(); !nextA.done; nextA = iteratorA.next()) {

      var iteratorB = b.entries();
      var keyFound = false;
      for (var nextB = iteratorB.next(); !nextB.done; nextB = iteratorB.next()) {
        // try to check keys first
        var r = eq(nextA.value[0], nextB.value[0], { collectAllFails: false, _meet: this$1._meet });

        if (r.length === 0) {
          keyFound = true;

          // check values also
          eq(nextA.value[1], nextB.value[1], this$1);
        }
      }

      if (!keyFound) {
        // no such key at all
        this$1.collectFail(true, format(SET_MAP_MISSING_KEY, nextA.value[0]));
      }
    }

    this._meet.pop();

    this.checkPlainObjectsEquality(a, b);
  });
});

function eq(a, b, opts) {
  return new EQ(opts, a, b).check();
}

eq.EQ = EQ;

module.exports = eq;


},{"should-type":277}],275:[function(require,module,exports){
'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var t = _interopDefault(require('should-type'));
var shouldTypeAdaptors = require('should-type-adaptors');

function looksLikeANumber(n) {
  return !!n.match(/\d+/);
}

function keyCompare(a, b) {
  var aNum = looksLikeANumber(a);
  var bNum = looksLikeANumber(b);
  if (aNum && bNum) {
    return 1 * a - 1 * b;
  } else if (aNum && !bNum) {
    return -1;
  } else if (!aNum && bNum) {
    return 1;
  } else {
    return a.localeCompare(b);
  }
}

function genKeysFunc(f) {
  return function (value) {
    var k = f(value);
    k.sort(keyCompare);
    return k;
  };
}

function Formatter(opts) {
  opts = opts || {};

  this.seen = [];

  var keysFunc;
  if (typeof opts.keysFunc === 'function') {
    keysFunc = opts.keysFunc;
  } else if (opts.keys === false) {
    keysFunc = Object.getOwnPropertyNames;
  } else {
    keysFunc = Object.keys;
  }

  this.getKeys = genKeysFunc(keysFunc);

  this.maxLineLength = typeof opts.maxLineLength === 'number' ? opts.maxLineLength : 60;
  this.propSep = opts.propSep || ',';

  this.isUTCdate = !!opts.isUTCdate;
}

Formatter.prototype = {
  constructor: Formatter,

  format: function (value) {
    var this$1 = this;

    var tp = t(value);

    if (this.alreadySeen(value)) {
      return '[Circular]';
    }

    var tries = tp.toTryTypes();
    var f = this.defaultFormat;
    while (tries.length) {
      var toTry = tries.shift();
      var name = Formatter.formatterFunctionName(toTry);
      if (this$1[name]) {
        f = this$1[name];
        break;
      }
    }
    return f.call(this, value).trim();
  },

  defaultFormat: function (obj) {
    return String(obj);
  },

  alreadySeen: function (value) {
    return this.seen.indexOf(value) >= 0;
  }

};

Formatter.addType = function addType(tp, f) {
  Formatter.prototype[Formatter.formatterFunctionName(tp)] = f;
};

Formatter.formatterFunctionName = function formatterFunctionName(tp) {
  return '_format_' + tp.toString('_');
};

var EOL = '\n';

function indent(v, indentation) {
  return v.split(EOL).map(function (vv) {
    return indentation + vv;
  }).join(EOL);
}

function pad(str, value, filler) {
  str = String(str);
  var isRight = false;

  if (value < 0) {
    isRight = true;
    value = -value;
  }

  if (str.length < value) {
    var padding = new Array(value - str.length + 1).join(filler);
    return isRight ? str + padding : padding + str;
  } else {
    return str;
  }
}

function pad0(str, value) {
  return pad(str, value, '0');
}

var functionNameRE = /^\s*function\s*(\S*)\s*\(/;

function functionName(f) {
  if (f.name) {
    return f.name;
  }
  var matches = f.toString().match(functionNameRE);
  if (matches === null) {
    // `functionNameRE` doesn't match arrow functions.
    return '';
  }
  var name = matches[1];
  return name;
}

function constructorName(obj) {
  while (obj) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined && typeof descriptor.value === 'function') {
      var name = functionName(descriptor.value);
      if (name !== '') {
        return name;
      }
    }

    obj = Object.getPrototypeOf(obj);
  }
}

var INDENT = '  ';

function addSpaces(str) {
  return indent(str, INDENT);
}

function typeAdaptorForEachFormat(obj, opts) {
  opts = opts || {};
  var filterKey = opts.filterKey || function () {
    return true;
  };

  var formatKey = opts.formatKey || this.format;
  var formatValue = opts.formatValue || this.format;

  var keyValueSep = typeof opts.keyValueSep !== 'undefined' ? opts.keyValueSep : ': ';

  this.seen.push(obj);

  var formatLength = 0;
  var pairs = [];

  shouldTypeAdaptors.forEach(obj, function (value, key) {
    if (!filterKey(key)) {
      return;
    }

    var formattedKey = formatKey.call(this, key);
    var formattedValue = formatValue.call(this, value, key);

    var pair = formattedKey ? formattedKey + keyValueSep + formattedValue : formattedValue;

    formatLength += pair.length;
    pairs.push(pair);
  }, this);

  this.seen.pop();

  (opts.additionalKeys || []).forEach(function (keyValue) {
    var pair = keyValue[0] + keyValueSep + this.format(keyValue[1]);
    formatLength += pair.length;
    pairs.push(pair);
  }, this);

  var prefix = opts.prefix || constructorName(obj) || '';
  if (prefix.length > 0) {
    prefix += ' ';
  }

  var lbracket, rbracket;
  if (Array.isArray(opts.brackets)) {
    lbracket = opts.brackets[0];
    rbracket = opts.brackets[1];
  } else {
    lbracket = '{';
    rbracket = '}';
  }

  var rootValue = opts.value || '';

  if (pairs.length === 0) {
    return rootValue || prefix + lbracket + rbracket;
  }

  if (formatLength <= this.maxLineLength) {
    return prefix + lbracket + ' ' + (rootValue ? rootValue + ' ' : '') + pairs.join(this.propSep + ' ') + ' ' + rbracket;
  } else {
    return prefix + lbracket + '\n' + (rootValue ? '  ' + rootValue + '\n' : '') + pairs.map(addSpaces).join(this.propSep + '\n') + '\n' + rbracket;
  }
}

function formatPlainObjectKey(key) {
  return typeof key === 'string' && key.match(/^[a-zA-Z_$][a-zA-Z_$0-9]*$/) ? key : this.format(key);
}

function getPropertyDescriptor(obj, key) {
  var desc;
  try {
    desc = Object.getOwnPropertyDescriptor(obj, key) || { value: obj[key] };
  } catch (e) {
    desc = { value: e };
  }
  return desc;
}

function formatPlainObjectValue(obj, key) {
  var desc = getPropertyDescriptor(obj, key);
  if (desc.get && desc.set) {
    return '[Getter/Setter]';
  }
  if (desc.get) {
    return '[Getter]';
  }
  if (desc.set) {
    return '[Setter]';
  }

  return this.format(desc.value);
}

function formatPlainObject(obj, opts) {
  opts = opts || {};
  opts.keyValueSep = ': ';
  opts.formatKey = opts.formatKey || formatPlainObjectKey;
  opts.formatValue = opts.formatValue || function (value, key) {
    return formatPlainObjectValue.call(this, obj, key);
  };
  return typeAdaptorForEachFormat.call(this, obj, opts);
}

function formatWrapper1(value) {
  return formatPlainObject.call(this, value, {
    additionalKeys: [['[[PrimitiveValue]]', value.valueOf()]]
  });
}

function formatWrapper2(value) {
  var realValue = value.valueOf();

  return formatPlainObject.call(this, value, {
    filterKey: function (key) {
      //skip useless indexed properties
      return !(key.match(/\d+/) && parseInt(key, 10) < realValue.length);
    },
    additionalKeys: [['[[PrimitiveValue]]', realValue]]
  });
}

function formatRegExp(value) {
  return formatPlainObject.call(this, value, {
    value: String(value)
  });
}

function formatFunction(value) {
  return formatPlainObject.call(this, value, {
    prefix: 'Function',
    additionalKeys: [['name', functionName(value)]]
  });
}

function formatArray(value) {
  return formatPlainObject.call(this, value, {
    formatKey: function (key) {
      if (!key.match(/\d+/)) {
        return formatPlainObjectKey.call(this, key);
      }
    },
    brackets: ['[', ']']
  });
}

function formatArguments(value) {
  return formatPlainObject.call(this, value, {
    formatKey: function (key) {
      if (!key.match(/\d+/)) {
        return formatPlainObjectKey.call(this, key);
      }
    },
    brackets: ['[', ']'],
    prefix: 'Arguments'
  });
}

function _formatDate(value, isUTC) {
  var prefix = isUTC ? 'UTC' : '';

  var date = value['get' + prefix + 'FullYear']() + '-' + pad0(value['get' + prefix + 'Month']() + 1, 2) + '-' + pad0(value['get' + prefix + 'Date'](), 2);

  var time = pad0(value['get' + prefix + 'Hours'](), 2) + ':' + pad0(value['get' + prefix + 'Minutes'](), 2) + ':' + pad0(value['get' + prefix + 'Seconds'](), 2) + '.' + pad0(value['get' + prefix + 'Milliseconds'](), 3);

  var to = value.getTimezoneOffset();
  var absTo = Math.abs(to);
  var hours = Math.floor(absTo / 60);
  var minutes = absTo - hours * 60;
  var tzFormat = (to < 0 ? '+' : '-') + pad0(hours, 2) + pad0(minutes, 2);

  return date + ' ' + time + (isUTC ? '' : ' ' + tzFormat);
}

function formatDate(value) {
  return formatPlainObject.call(this, value, { value: _formatDate(value, this.isUTCdate) });
}

function formatError(value) {
  return formatPlainObject.call(this, value, {
    prefix: value.name,
    additionalKeys: [['message', value.message]]
  });
}

function generateFormatForNumberArray(lengthProp, name, padding) {
  return function (value) {
    var max = this.byteArrayMaxLength || 50;
    var length = value[lengthProp];
    var formattedValues = [];
    var len = 0;
    for (var i = 0; i < max && i < length; i++) {
      var b = value[i] || 0;
      var v = pad0(b.toString(16), padding);
      len += v.length;
      formattedValues.push(v);
    }
    var prefix = value.constructor.name || name || '';
    if (prefix) {
      prefix += ' ';
    }

    if (formattedValues.length === 0) {
      return prefix + '[]';
    }

    if (len <= this.maxLineLength) {
      return prefix + '[ ' + formattedValues.join(this.propSep + ' ') + ' ' + ']';
    } else {
      return prefix + '[\n' + formattedValues.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
    }
  };
}

function formatMap(obj) {
  return typeAdaptorForEachFormat.call(this, obj, {
    keyValueSep: ' => '
  });
}

function formatSet(obj) {
  return typeAdaptorForEachFormat.call(this, obj, {
    keyValueSep: '',
    formatKey: function () {
      return '';
    }
  });
}

function genSimdVectorFormat(constructorName, length) {
  return function (value) {
    var this$1 = this;

    var Constructor = value.constructor;
    var extractLane = Constructor.extractLane;

    var len = 0;
    var props = [];

    for (var i = 0; i < length; i++) {
      var key = this$1.format(extractLane(value, i));
      len += key.length;
      props.push(key);
    }

    if (len <= this.maxLineLength) {
      return constructorName + ' [ ' + props.join(this.propSep + ' ') + ' ]';
    } else {
      return constructorName + ' [\n' + props.map(addSpaces).join(this.propSep + '\n') + '\n' + ']';
    }
  };
}

function defaultFormat(value, opts) {
  return new Formatter(opts).format(value);
}

defaultFormat.Formatter = Formatter;
defaultFormat.addSpaces = addSpaces;
defaultFormat.pad0 = pad0;
defaultFormat.functionName = functionName;
defaultFormat.constructorName = constructorName;
defaultFormat.formatPlainObjectKey = formatPlainObjectKey;
defaultFormat.formatPlainObject = formatPlainObject;
defaultFormat.typeAdaptorForEachFormat = typeAdaptorForEachFormat;
// adding primitive types
Formatter.addType(new t.Type(t.UNDEFINED), function () {
  return 'undefined';
});
Formatter.addType(new t.Type(t.NULL), function () {
  return 'null';
});
Formatter.addType(new t.Type(t.BOOLEAN), function (value) {
  return value ? 'true' : 'false';
});
Formatter.addType(new t.Type(t.SYMBOL), function (value) {
  return value.toString();
});
Formatter.addType(new t.Type(t.NUMBER), function (value) {
  if (value === 0 && 1 / value < 0) {
    return '-0';
  }
  return String(value);
});

Formatter.addType(new t.Type(t.STRING), function (value) {
  return '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
});

Formatter.addType(new t.Type(t.FUNCTION), formatFunction);

// plain object
Formatter.addType(new t.Type(t.OBJECT), formatPlainObject);

// type wrappers
Formatter.addType(new t.Type(t.OBJECT, t.NUMBER), formatWrapper1);
Formatter.addType(new t.Type(t.OBJECT, t.BOOLEAN), formatWrapper1);
Formatter.addType(new t.Type(t.OBJECT, t.STRING), formatWrapper2);

Formatter.addType(new t.Type(t.OBJECT, t.REGEXP), formatRegExp);
Formatter.addType(new t.Type(t.OBJECT, t.ARRAY), formatArray);
Formatter.addType(new t.Type(t.OBJECT, t.ARGUMENTS), formatArguments);
Formatter.addType(new t.Type(t.OBJECT, t.DATE), formatDate);
Formatter.addType(new t.Type(t.OBJECT, t.ERROR), formatError);
Formatter.addType(new t.Type(t.OBJECT, t.SET), formatSet);
Formatter.addType(new t.Type(t.OBJECT, t.MAP), formatMap);
Formatter.addType(new t.Type(t.OBJECT, t.WEAK_MAP), formatMap);
Formatter.addType(new t.Type(t.OBJECT, t.WEAK_SET), formatSet);

Formatter.addType(new t.Type(t.OBJECT, t.BUFFER), generateFormatForNumberArray('length', 'Buffer', 2));

Formatter.addType(new t.Type(t.OBJECT, t.ARRAY_BUFFER), generateFormatForNumberArray('byteLength', 'ArrayBuffer', 2));

Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int8'), generateFormatForNumberArray('length', 'Int8Array', 2));
Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8'), generateFormatForNumberArray('length', 'Uint8Array', 2));
Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint8clamped'), generateFormatForNumberArray('length', 'Uint8ClampedArray', 2));

Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int16'), generateFormatForNumberArray('length', 'Int16Array', 4));
Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint16'), generateFormatForNumberArray('length', 'Uint16Array', 4));

Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'int32'), generateFormatForNumberArray('length', 'Int32Array', 8));
Formatter.addType(new t.Type(t.OBJECT, t.TYPED_ARRAY, 'uint32'), generateFormatForNumberArray('length', 'Uint32Array', 8));

Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool16x8'), genSimdVectorFormat('Bool16x8', 8));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool32x4'), genSimdVectorFormat('Bool32x4', 4));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'bool8x16'), genSimdVectorFormat('Bool8x16', 16));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'float32x4'), genSimdVectorFormat('Float32x4', 4));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int16x8'), genSimdVectorFormat('Int16x8', 8));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int32x4'), genSimdVectorFormat('Int32x4', 4));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'int8x16'), genSimdVectorFormat('Int8x16', 16));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint16x8'), genSimdVectorFormat('Uint16x8', 8));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint32x4'), genSimdVectorFormat('Uint32x4', 4));
Formatter.addType(new t.Type(t.OBJECT, t.SIMD, 'uint8x16'), genSimdVectorFormat('Uint8x16', 16));

Formatter.addType(new t.Type(t.OBJECT, t.PROMISE), function () {
  return '[Promise]'; //TODO it could be nice to inspect its state and value
});

Formatter.addType(new t.Type(t.OBJECT, t.XHR), function () {
  return '[XMLHttpRequest]'; //TODO it could be nice to inspect its state
});

Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT), function (value) {
  return value.outerHTML;
});

Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#text'), function (value) {
  return value.nodeValue;
});

Formatter.addType(new t.Type(t.OBJECT, t.HTML_ELEMENT, '#document'), function (value) {
  return value.documentElement.outerHTML;
});

Formatter.addType(new t.Type(t.OBJECT, t.HOST), function () {
  return '[Host]';
});

module.exports = defaultFormat;


},{"should-type":277,"should-type-adaptors":276}],276:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var shouldUtil = require('should-util');
var t = _interopDefault(require('should-type'));

// TODO in future add generators instead of forEach and iterator implementation


function ObjectIterator(obj) {
  this._obj = obj;
}

ObjectIterator.prototype = {
  __shouldIterator__: true, // special marker

  next: function () {
    if (this._done) {
      throw new Error('Iterator already reached the end');
    }

    if (!this._keys) {
      this._keys = Object.keys(this._obj);
      this._index = 0;
    }

    var key = this._keys[this._index];
    this._done = this._index === this._keys.length;
    this._index += 1;

    return {
      value: this._done ? void 0 : [key, this._obj[key]],
      done: this._done
    };
  }
};

if (typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol') {
  ObjectIterator.prototype[Symbol.iterator] = function () {
    return this;
  };
}

function TypeAdaptorStorage() {
  this._typeAdaptors = [];
  this._iterableTypes = {};
}

TypeAdaptorStorage.prototype = {
  add: function (type, cls, sub, adaptor) {
    return this.addType(new t.Type(type, cls, sub), adaptor);
  },

  addType: function (type, adaptor) {
    this._typeAdaptors[type.toString()] = adaptor;
  },

  getAdaptor: function (tp, funcName) {
    var this$1 = this;

    var tries = tp.toTryTypes();
    while (tries.length) {
      var toTry = tries.shift();
      var ad = this$1._typeAdaptors[toTry];
      if (ad && ad[funcName]) {
        return ad[funcName];
      }
    }
  },

  requireAdaptor: function (tp, funcName) {
    var a = this.getAdaptor(tp, funcName);
    if (!a) {
      throw new Error('There is no type adaptor `' + funcName + '` for ' + tp.toString());
    }
    return a;
  },

  addIterableType: function (tp) {
    this._iterableTypes[tp.toString()] = true;
  },

  isIterableType: function (tp) {
    return !!this._iterableTypes[tp.toString()];
  }
};

var defaultTypeAdaptorStorage = new TypeAdaptorStorage();

var objectAdaptor = {
  forEach: function (obj, f, context) {
    for (var prop in obj) {
      if (shouldUtil.hasOwnProperty(obj, prop) && shouldUtil.propertyIsEnumerable(obj, prop)) {
        if (f.call(context, obj[prop], prop, obj) === false) {
          return;
        }
      }
    }
  },

  has: function (obj, prop) {
    return shouldUtil.hasOwnProperty(obj, prop);
  },

  get: function (obj, prop) {
    return obj[prop];
  },

  iterator: function (obj) {
    return new ObjectIterator(obj);
  }
};

// default for objects
defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT), objectAdaptor);
defaultTypeAdaptorStorage.addType(new t.Type(t.FUNCTION), objectAdaptor);

var mapAdaptor = {
  has: function (obj, key) {
    return obj.has(key);
  },

  get: function (obj, key) {
    return obj.get(key);
  },

  forEach: function (obj, f, context) {
    var iter = obj.entries();
    forEach(iter, function (value) {
      return f.call(context, value[1], value[0], obj);
    });
  },

  size: function (obj) {
    return obj.size;
  },

  isEmpty: function (obj) {
    return obj.size === 0;
  },

  iterator: function (obj) {
    return obj.entries();
  }
};

var setAdaptor = shouldUtil.merge({}, mapAdaptor);
setAdaptor.get = function (obj, key) {
  if (obj.has(key)) {
    return key;
  }
};

defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.MAP), mapAdaptor);
defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.SET), setAdaptor);
defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_SET), setAdaptor);
defaultTypeAdaptorStorage.addType(new t.Type(t.OBJECT, t.WEAK_MAP), mapAdaptor);

defaultTypeAdaptorStorage.addType(new t.Type(t.STRING), {
  isEmpty: function (obj) {
    return obj === '';
  },

  size: function (obj) {
    return obj.length;
  }
});

defaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARRAY));
defaultTypeAdaptorStorage.addIterableType(new t.Type(t.OBJECT, t.ARGUMENTS));

function forEach(obj, f, context) {
  if (shouldUtil.isGeneratorFunction(obj)) {
    return forEach(obj(), f, context);
  } else if (shouldUtil.isIterator(obj)) {
    var value = obj.next();
    while (!value.done) {
      if (f.call(context, value.value, 'value', obj) === false) {
        return;
      }
      value = obj.next();
    }
  } else {
    var type = t(obj);
    var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'forEach');
    func(obj, f, context);
  }
}

function size(obj) {
  var type = t(obj);
  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'size');
  if (func) {
    return func(obj);
  } else {
    var len = 0;
    forEach(obj, function () {
      len += 1;
    });
    return len;
  }
}

function isEmpty(obj) {
  var type = t(obj);
  var func = defaultTypeAdaptorStorage.getAdaptor(type, 'isEmpty');
  if (func) {
    return func(obj);
  } else {
    var res = true;
    forEach(obj, function () {
      res = false;
      return false;
    });
    return res;
  }
}

// return boolean if obj has such 'key'
function has(obj, key) {
  var type = t(obj);
  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'has');
  return func(obj, key);
}

// return value for given key
function get(obj, key) {
  var type = t(obj);
  var func = defaultTypeAdaptorStorage.requireAdaptor(type, 'get');
  return func(obj, key);
}

function reduce(obj, f, initialValue) {
  var res = initialValue;
  forEach(obj, function (value, key) {
    res = f(res, value, key, obj);
  });
  return res;
}

function some(obj, f, context) {
  var res = false;
  forEach(obj, function (value, key) {
    if (f.call(context, value, key, obj)) {
      res = true;
      return false;
    }
  }, context);
  return res;
}

function every(obj, f, context) {
  var res = true;
  forEach(obj, function (value, key) {
    if (!f.call(context, value, key, obj)) {
      res = false;
      return false;
    }
  }, context);
  return res;
}

function isIterable(obj) {
  return defaultTypeAdaptorStorage.isIterableType(t(obj));
}

function iterator(obj) {
  return defaultTypeAdaptorStorage.requireAdaptor(t(obj), 'iterator')(obj);
}

exports.defaultTypeAdaptorStorage = defaultTypeAdaptorStorage;
exports.forEach = forEach;
exports.size = size;
exports.isEmpty = isEmpty;
exports.has = has;
exports.get = get;
exports.reduce = reduce;
exports.some = some;
exports.every = every;
exports.isIterable = isIterable;
exports.iterator = iterator;


},{"should-type":277,"should-util":278}],277:[function(require,module,exports){
(function (Buffer){
'use strict';

var types = {
  NUMBER: 'number',
  UNDEFINED: 'undefined',
  STRING: 'string',
  BOOLEAN: 'boolean',
  OBJECT: 'object',
  FUNCTION: 'function',
  NULL: 'null',
  ARRAY: 'array',
  REGEXP: 'regexp',
  DATE: 'date',
  ERROR: 'error',
  ARGUMENTS: 'arguments',
  SYMBOL: 'symbol',
  ARRAY_BUFFER: 'array-buffer',
  TYPED_ARRAY: 'typed-array',
  DATA_VIEW: 'data-view',
  MAP: 'map',
  SET: 'set',
  WEAK_SET: 'weak-set',
  WEAK_MAP: 'weak-map',
  PROMISE: 'promise',

  // node buffer
  BUFFER: 'buffer',

  // dom html element
  HTML_ELEMENT: 'html-element',
  HTML_ELEMENT_TEXT: 'html-element-text',
  DOCUMENT: 'document',
  WINDOW: 'window',
  FILE: 'file',
  FILE_LIST: 'file-list',
  BLOB: 'blob',

  HOST: 'host',

  XHR: 'xhr',

  // simd
  SIMD: 'simd'
};

/*
 * Simple data function to store type information
 * @param {string} type Usually what is returned from typeof
 * @param {string} cls  Sanitized @Class via Object.prototype.toString
 * @param {string} sub  If type and cls the same, and need to specify somehow
 * @private
 * @example
 *
 * //for null
 * new Type('null');
 *
 * //for Date
 * new Type('object', 'date');
 *
 * //for Uint8Array
 *
 * new Type('object', 'typed-array', 'uint8');
 */
function Type(type, cls, sub) {
  if (!type) {
    throw new Error('Type class must be initialized at least with `type` information');
  }
  this.type = type;
  this.cls = cls;
  this.sub = sub;
}

Type.prototype = {
  toString: function (sep) {
    sep = sep || ';';
    var str = [this.type];
    if (this.cls) {
      str.push(this.cls);
    }
    if (this.sub) {
      str.push(this.sub);
    }
    return str.join(sep);
  },

  toTryTypes: function () {
    var _types = [];
    if (this.sub) {
      _types.push(new Type(this.type, this.cls, this.sub));
    }
    if (this.cls) {
      _types.push(new Type(this.type, this.cls));
    }
    _types.push(new Type(this.type));

    return _types;
  }
};

var toString = Object.prototype.toString;

/**
 * Function to store type checks
 * @private
 */
function TypeChecker() {
  this.checks = [];
}

TypeChecker.prototype = {
  add: function (func) {
    this.checks.push(func);
    return this;
  },

  addBeforeFirstMatch: function (obj, func) {
    var match = this.getFirstMatch(obj);
    if (match) {
      this.checks.splice(match.index, 0, func);
    } else {
      this.add(func);
    }
  },

  addTypeOf: function (type, res) {
    return this.add(function (obj, tpeOf) {
      if (tpeOf === type) {
        return new Type(res);
      }
    });
  },

  addClass: function (cls, res, sub) {
    return this.add(function (obj, tpeOf, objCls) {
      if (objCls === cls) {
        return new Type(types.OBJECT, res, sub);
      }
    });
  },

  getFirstMatch: function (obj) {
    var this$1 = this;

    var typeOf = typeof obj;
    var cls = toString.call(obj);

    for (var i = 0, l = this.checks.length; i < l; i++) {
      var res = this$1.checks[i].call(this$1, obj, typeOf, cls);
      if (typeof res !== 'undefined') {
        return { result: res, func: this$1.checks[i], index: i };
      }
    }
  },

  getType: function (obj) {
    var match = this.getFirstMatch(obj);
    return match && match.result;
  }
};

var main = new TypeChecker();

//TODO add iterators

main.addTypeOf(types.NUMBER, types.NUMBER).addTypeOf(types.UNDEFINED, types.UNDEFINED).addTypeOf(types.STRING, types.STRING).addTypeOf(types.BOOLEAN, types.BOOLEAN).addTypeOf(types.FUNCTION, types.FUNCTION).addTypeOf(types.SYMBOL, types.SYMBOL).add(function (obj) {
  if (obj === null) {
    return new Type(types.NULL);
  }
}).addClass('[object String]', types.STRING).addClass('[object Boolean]', types.BOOLEAN).addClass('[object Number]', types.NUMBER).addClass('[object Array]', types.ARRAY).addClass('[object RegExp]', types.REGEXP).addClass('[object Error]', types.ERROR).addClass('[object Date]', types.DATE).addClass('[object Arguments]', types.ARGUMENTS).addClass('[object ArrayBuffer]', types.ARRAY_BUFFER).addClass('[object Int8Array]', types.TYPED_ARRAY, 'int8').addClass('[object Uint8Array]', types.TYPED_ARRAY, 'uint8').addClass('[object Uint8ClampedArray]', types.TYPED_ARRAY, 'uint8clamped').addClass('[object Int16Array]', types.TYPED_ARRAY, 'int16').addClass('[object Uint16Array]', types.TYPED_ARRAY, 'uint16').addClass('[object Int32Array]', types.TYPED_ARRAY, 'int32').addClass('[object Uint32Array]', types.TYPED_ARRAY, 'uint32').addClass('[object Float32Array]', types.TYPED_ARRAY, 'float32').addClass('[object Float64Array]', types.TYPED_ARRAY, 'float64').addClass('[object Bool16x8]', types.SIMD, 'bool16x8').addClass('[object Bool32x4]', types.SIMD, 'bool32x4').addClass('[object Bool8x16]', types.SIMD, 'bool8x16').addClass('[object Float32x4]', types.SIMD, 'float32x4').addClass('[object Int16x8]', types.SIMD, 'int16x8').addClass('[object Int32x4]', types.SIMD, 'int32x4').addClass('[object Int8x16]', types.SIMD, 'int8x16').addClass('[object Uint16x8]', types.SIMD, 'uint16x8').addClass('[object Uint32x4]', types.SIMD, 'uint32x4').addClass('[object Uint8x16]', types.SIMD, 'uint8x16').addClass('[object DataView]', types.DATA_VIEW).addClass('[object Map]', types.MAP).addClass('[object WeakMap]', types.WEAK_MAP).addClass('[object Set]', types.SET).addClass('[object WeakSet]', types.WEAK_SET).addClass('[object Promise]', types.PROMISE).addClass('[object Blob]', types.BLOB).addClass('[object File]', types.FILE).addClass('[object FileList]', types.FILE_LIST).addClass('[object XMLHttpRequest]', types.XHR).add(function (obj) {
  if (typeof Promise === types.FUNCTION && obj instanceof Promise || typeof obj.then === types.FUNCTION) {
    return new Type(types.OBJECT, types.PROMISE);
  }
}).add(function (obj) {
  if (typeof Buffer !== 'undefined' && obj instanceof Buffer) {
    // eslint-disable-line no-undef
    return new Type(types.OBJECT, types.BUFFER);
  }
}).add(function (obj) {
  if (typeof Node !== 'undefined' && obj instanceof Node) {
    return new Type(types.OBJECT, types.HTML_ELEMENT, obj.nodeName);
  }
}).add(function (obj) {
  // probably at the begginging should be enough these checks
  if (obj.Boolean === Boolean && obj.Number === Number && obj.String === String && obj.Date === Date) {
    return new Type(types.OBJECT, types.HOST);
  }
}).add(function () {
  return new Type(types.OBJECT);
});

/**
 * Get type information of anything
 *
 * @param  {any} obj Anything that could require type information
 * @return {Type}    type info
 * @private
 */
function getGlobalType(obj) {
  return main.getType(obj);
}

getGlobalType.checker = main;
getGlobalType.TypeChecker = TypeChecker;
getGlobalType.Type = Type;

Object.keys(types).forEach(function (typeName) {
  getGlobalType[typeName] = types[typeName];
});

module.exports = getGlobalType;


}).call(this,require("buffer").Buffer)
},{"buffer":6}],278:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

function hasOwnProperty(obj, key) {
  return _hasOwnProperty.call(obj, key);
}

function propertyIsEnumerable(obj, key) {
  return _propertyIsEnumerable.call(obj, key);
}

function merge(a, b) {
  if (a && b) {
    for (var key in b) {
      a[key] = b[key];
    }
  }
  return a;
}

function isIterator(obj) {
  if (!obj) {
    return false;
  }

  if (obj.__shouldIterator__) {
    return true;
  }

  return typeof obj.next === 'function' && typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' && typeof obj[Symbol.iterator] === 'function' && obj[Symbol.iterator]() === obj;
}

//TODO find better way
function isGeneratorFunction(f) {
  return typeof f === 'function' && /^function\s*\*\s*/.test(f.toString());
}

exports.hasOwnProperty = hasOwnProperty;
exports.propertyIsEnumerable = propertyIsEnumerable;
exports.merge = merge;
exports.isIterator = isIterator;
exports.isGeneratorFunction = isGeneratorFunction;


},{}],279:[function(require,module,exports){
'use strict';

module.exports = require('./cjs/should');


},{"./cjs/should":280}],280:[function(require,module,exports){
'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var getType = _interopDefault(require('should-type'));
var eql = _interopDefault(require('should-equal'));
var sformat = _interopDefault(require('should-format'));
var shouldTypeAdaptors = require('should-type-adaptors');
var shouldUtil = require('should-util');

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */
function isWrapperType(obj) {
  return obj instanceof Number || obj instanceof String || obj instanceof Boolean;
}

// XXX make it more strict: numbers, strings, symbols - and nothing else
function convertPropertyName(name) {
  return typeof name === 'symbol' ? name : String(name);
}

var functionName = sformat.functionName;

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var config = {
  typeAdaptors: shouldTypeAdaptors.defaultTypeAdaptorStorage,

  getFormatter: function (opts) {
    return new sformat.Formatter(opts || config);
  }
};

function format(value, opts) {
  return config.getFormatter(opts).format(value);
}

function formatProp(value) {
  var formatter = config.getFormatter();
  return sformat.formatPlainObjectKey.call(formatter, value);
}

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */
/**
 * should AssertionError
 * @param {Object} options
 * @constructor
 * @memberOf should
 * @static
 */
function AssertionError(options) {
  shouldUtil.merge(this, options);

  if (!options.message) {
    Object.defineProperty(this, 'message', {
      get: function () {
        if (!this._message) {
          this._message = this.generateMessage();
          this.generatedMessage = true;
        }
        return this._message;
      },
      configurable: true,
      enumerable: false
    });
  }

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      if (this.stackStartFunction) {
        // try to strip useless frames
        var fn_name = functionName(this.stackStartFunction);
        var idx = out.indexOf('\n' + fn_name);
        if (idx >= 0) {
          // once we have located the function frame
          // we need to strip out everything before it (and its line)
          var next_line = out.indexOf('\n', idx + 1);
          out = out.substring(next_line + 1);
        }
      }

      this.stack = out;
    }
  }
}

var indent = '    ';
function prependIndent(line) {
  return indent + line;
}

function indentLines(text) {
  return text.split('\n').map(prependIndent).join('\n');
}

// assert.AssertionError instanceof Error
AssertionError.prototype = Object.create(Error.prototype, {
  name: {
    value: 'AssertionError'
  },

  generateMessage: {
    value: function () {
      if (!this.operator && this.previous) {
        return this.previous.message;
      }
      var actual = format(this.actual);
      var expected = 'expected' in this ? ' ' + format(this.expected) : '';
      var details = 'details' in this && this.details ? ' (' + this.details + ')' : '';

      var previous = this.previous ? '\n' + indentLines(this.previous.message) : '';

      return 'expected ' + actual + (this.negate ? ' not ' : ' ') + this.operator + expected + details + previous;
    }
  }
});

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

// a bit hacky way how to get error to do not have stack
function LightAssertionError(options) {
  shouldUtil.merge(this, options);

  if (!options.message) {
    Object.defineProperty(this, 'message', {
      get: function () {
        if (!this._message) {
          this._message = this.generateMessage();
          this.generatedMessage = true;
        }
        return this._message;
      }
    });
  }
}

LightAssertionError.prototype = {
  generateMessage: AssertionError.prototype.generateMessage
};

/**
 * should Assertion
 * @param {*} obj Given object for assertion
 * @constructor
 * @memberOf should
 * @static
 */
function Assertion(obj) {
  this.obj = obj;

  this.anyOne = false;
  this.negate = false;

  this.params = { actual: obj };
}

Assertion.prototype = {
  constructor: Assertion,

  /**
   * Base method for assertions.
   *
   * Before calling this method need to fill Assertion#params object. This method usually called from other assertion methods.
   * `Assertion#params` can contain such properties:
   * * `operator` - required string containing description of this assertion
   * * `obj` - optional replacement for this.obj, it usefull if you prepare more clear object then given
   * * `message` - if this property filled with string any others will be ignored and this one used as assertion message
   * * `expected` - any object used when you need to assert relation between given object and expected. Like given == expected (== is a relation)
   * * `details` - additional string with details to generated message
   *
   * @memberOf Assertion
   * @category assertion
   * @param {*} expr Any expression that will be used as a condition for asserting.
   * @example
   *
   * var a = new should.Assertion(42);
   *
   * a.params = {
   *  operator: 'to be magic number',
   * }
   *
   * a.assert(false);
   * //throws AssertionError: expected 42 to be magic number
   */
  assert: function (expr) {
    if (expr) {
      return this;
    }

    var params = this.params;

    if ('obj' in params && !('actual' in params)) {
      params.actual = params.obj;
    } else if (!('obj' in params) && !('actual' in params)) {
      params.actual = this.obj;
    }

    params.stackStartFunction = params.stackStartFunction || this.assert;
    params.negate = this.negate;

    params.assertion = this;

    if (this.light) {
      throw new LightAssertionError(params);
    } else {
      throw new AssertionError(params);
    }
  },

  /**
   * Shortcut for `Assertion#assert(false)`.
   *
   * @memberOf Assertion
   * @category assertion
   * @example
   *
   * var a = new should.Assertion(42);
   *
   * a.params = {
   *  operator: 'to be magic number',
   * }
   *
   * a.fail();
   * //throws AssertionError: expected 42 to be magic number
   */
  fail: function () {
    return this.assert(false);
  }
};

/**
 * Assertion used to delegate calls of Assertion methods inside of Promise.
 * It has almost all methods of Assertion.prototype
 *
 * @param {Promise} obj
 */
function PromisedAssertion() /* obj */{
  Assertion.apply(this, arguments);
}

/**
 * Make PromisedAssertion to look like promise. Delegate resolve and reject to given promise.
 *
 * @private
 * @returns {Promise}
 */
PromisedAssertion.prototype.then = function (resolve, reject) {
  return this.obj.then(resolve, reject);
};

/**
 * Way to extend Assertion function. It uses some logic
 * to define only positive assertions and itself rule with negative assertion.
 *
 * All actions happen in subcontext and this method take care about negation.
 * Potentially we can add some more modifiers that does not depends from state of assertion.
 *
 * @memberOf Assertion
 * @static
 * @param {String} name Name of assertion. It will be used for defining method or getter on Assertion.prototype
 * @param {Function} func Function that will be called on executing assertion
 * @example
 *
 * Assertion.add('asset', function() {
 *      this.params = { operator: 'to be asset' }
 *
 *      this.obj.should.have.property('id').which.is.a.Number()
 *      this.obj.should.have.property('path')
 * })
 */
Assertion.add = function (name, func) {
  Object.defineProperty(Assertion.prototype, name, {
    enumerable: true,
    configurable: true,
    value: function () {
      var context = new Assertion(this.obj, this, name);
      context.anyOne = this.anyOne;
      context.onlyThis = this.onlyThis;
      // hack
      context.light = true;

      try {
        func.apply(context, arguments);
      } catch (e) {
        // check for fail
        if (e instanceof AssertionError || e instanceof LightAssertionError) {
          // negative fail
          if (this.negate) {
            this.obj = context.obj;
            this.negate = false;
            return this;
          }

          if (context !== e.assertion) {
            context.params.previous = e;
          }

          // positive fail
          context.negate = false;
          // hack
          context.light = false;
          context.fail();
        }
        // throw if it is another exception
        throw e;
      }

      // negative pass
      if (this.negate) {
        context.negate = true; // because .fail will set negate
        context.params.details = 'false negative fail';
        // hack
        context.light = false;
        context.fail();
      }

      // positive pass
      if (!this.params.operator) {
        this.params = context.params; // shortcut
      }
      this.obj = context.obj;
      this.negate = false;
      return this;
    }
  });

  Object.defineProperty(PromisedAssertion.prototype, name, {
    enumerable: true,
    configurable: true,
    value: function () {
      var args = arguments;
      this.obj = this.obj.then(function (a) {
        return a[name].apply(a, args);
      });

      return this;
    }
  });
};

/**
 * Add chaining getter to Assertion like .a, .which etc
 *
 * @memberOf Assertion
 * @static
 * @param  {string} name   name of getter
 * @param  {function} [onCall] optional function to call
 */
Assertion.addChain = function (name, onCall) {
  onCall = onCall || function () {};
  Object.defineProperty(Assertion.prototype, name, {
    get: function () {
      onCall.call(this);
      return this;
    },
    enumerable: true
  });

  Object.defineProperty(PromisedAssertion.prototype, name, {
    enumerable: true,
    configurable: true,
    get: function () {
      this.obj = this.obj.then(function (a) {
        return a[name];
      });

      return this;
    }
  });
};

/**
 * Create alias for some `Assertion` property
 *
 * @memberOf Assertion
 * @static
 * @param {String} from Name of to map
 * @param {String} to Name of alias
 * @example
 *
 * Assertion.alias('true', 'True')
 */
Assertion.alias = function (from, to) {
  var desc = Object.getOwnPropertyDescriptor(Assertion.prototype, from);
  if (!desc) {
    throw new Error('Alias ' + from + ' -> ' + to + ' could not be created as ' + from + ' not defined');
  }
  Object.defineProperty(Assertion.prototype, to, desc);

  var desc2 = Object.getOwnPropertyDescriptor(PromisedAssertion.prototype, from);
  if (desc2) {
    Object.defineProperty(PromisedAssertion.prototype, to, desc2);
  }
};
/**
 * Negation modifier. Current assertion chain become negated. Each call invert negation on current assertion.
 *
 * @name not
 * @property
 * @memberOf Assertion
 * @category assertion
 */
Assertion.addChain('not', function () {
  this.negate = !this.negate;
});

/**
 * Any modifier - it affect on execution of sequenced assertion to do not `check all`, but `check any of`.
 *
 * @name any
 * @property
 * @memberOf Assertion
 * @category assertion
 */
Assertion.addChain('any', function () {
  this.anyOne = true;
});

/**
 * Only modifier - currently used with .keys to check if object contains only exactly this .keys
 *
 * @name only
 * @property
 * @memberOf Assertion
 * @category assertion
 */
Assertion.addChain('only', function () {
  this.onlyThis = true;
});

// implement assert interface using already written peaces of should.js

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = ok;
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.
/**
 * Node.js standard [`assert.fail`](http://nodejs.org/api/assert.html#assert_assert_fail_actual_expected_message_operator).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual Actual object
 * @param {*} expected Expected object
 * @param {string} message Message for assertion
 * @param {string} operator Operator text
 */
function fail(actual, expected, message, operator, stackStartFunction) {
  var a = new Assertion(actual);
  a.params = {
    operator: operator,
    expected: expected,
    message: message,
    stackStartFunction: stackStartFunction || fail
  };

  a.fail();
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.
/**
 * Node.js standard [`assert.ok`](http://nodejs.org/api/assert.html#assert_assert_value_message_assert_ok_value_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} value
 * @param {string} [message]
 */
function ok(value, message) {
  if (!value) {
    fail(value, true, message, '==', assert.ok);
  }
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

/**
 * Node.js standard [`assert.equal`](http://nodejs.org/api/assert.html#assert_assert_equal_actual_expected_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.equal = function equal(actual, expected, message) {
  if (actual != expected) {
    fail(actual, expected, message, '==', assert.equal);
  }
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
/**
 * Node.js standard [`assert.notEqual`](http://nodejs.org/api/assert.html#assert_assert_notequal_actual_expected_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
/**
 * Node.js standard [`assert.deepEqual`](http://nodejs.org/api/assert.html#assert_assert_deepequal_actual_expected_message).
 * But uses should.js .eql implementation instead of Node.js own deepEqual.
 *
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.deepEqual = function deepEqual(actual, expected, message) {
  if (eql(actual, expected).length !== 0) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
/**
 * Node.js standard [`assert.notDeepEqual`](http://nodejs.org/api/assert.html#assert_assert_notdeepequal_actual_expected_message).
 * But uses should.js .eql implementation instead of Node.js own deepEqual.
 *
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (eql(actual, expected).result) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
/**
 * Node.js standard [`assert.strictEqual`](http://nodejs.org/api/assert.html#assert_assert_strictequal_actual_expected_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
/**
 * Node.js standard [`assert.notStrictEqual`](http://nodejs.org/api/assert.html#assert_assert_notstrictequal_actual_expected_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {*} actual
 * @param {*} expected
 * @param {string} [message]
 */
assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof expected == 'string') {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ')' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
/**
 * Node.js standard [`assert.throws`](http://nodejs.org/api/assert.html#assert_assert_throws_block_error_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {Function} block
 * @param {Function} [error]
 * @param {String} [message]
 */
assert.throws = function () /*block, error, message*/{
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
/**
 * Node.js standard [`assert.doesNotThrow`](http://nodejs.org/api/assert.html#assert_assert_doesnotthrow_block_message).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {Function} block
 * @param {String} [message]
 */
assert.doesNotThrow = function () /*block, message*/{
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

/**
 * Node.js standard [`assert.ifError`](http://nodejs.org/api/assert.html#assert_assert_iferror_value).
 * @static
 * @memberOf should
 * @category assertion assert
 * @param {Error} err
 */
assert.ifError = function (err) {
  if (err) {
    throw err;
  }
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var assertExtensions = function (should) {
  var i = should.format;

  /*
   * Expose assert to should
   *
   * This allows you to do things like below
   * without require()ing the assert module.
   *
   *    should.equal(foo.bar, undefined);
   *
   */
  shouldUtil.merge(should, assert);

  /**
   * Assert _obj_ exists, with optional message.
   *
   * @static
   * @memberOf should
   * @category assertion assert
   * @alias should.exists
   * @param {*} obj
   * @param {String} [msg]
   * @example
   *
   * should.exist(1);
   * should.exist(new Date());
   */
  should.exist = should.exists = function (obj, msg) {
    if (null == obj) {
      throw new AssertionError({
        message: msg || 'expected ' + i(obj) + ' to exist', stackStartFunction: should.exist
      });
    }
  };

  should.not = {};
  /**
   * Asserts _obj_ does not exist, with optional message.
   *
   * @name not.exist
   * @static
   * @memberOf should
   * @category assertion assert
   * @alias should.not.exists
   * @param {*} obj
   * @param {String} [msg]
   * @example
   *
   * should.not.exist(null);
   * should.not.exist(void 0);
   */
  should.not.exist = should.not.exists = function (obj, msg) {
    if (null != obj) {
      throw new AssertionError({
        message: msg || 'expected ' + i(obj) + ' to not exist', stackStartFunction: should.not.exist
      });
    }
  };
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var chainAssertions = function (should, Assertion) {
  /**
   * Simple chaining to improve readability. Does nothing.
   *
   * @memberOf Assertion
   * @name be
   * @property {should.Assertion} be
   * @alias Assertion#an
   * @alias Assertion#of
   * @alias Assertion#a
   * @alias Assertion#and
   * @alias Assertion#been
   * @alias Assertion#have
   * @alias Assertion#has
   * @alias Assertion#with
   * @alias Assertion#is
   * @alias Assertion#which
   * @alias Assertion#the
   * @alias Assertion#it
   * @category assertion chaining
   */
  ['an', 'of', 'a', 'and', 'be', 'been', 'has', 'have', 'with', 'is', 'which', 'the', 'it'].forEach(function (name) {
    Assertion.addChain(name);
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var booleanAssertions = function (should, Assertion) {
  /**
   * Assert given object is exactly `true`.
   *
   * @name true
   * @memberOf Assertion
   * @category assertion bool
   * @alias Assertion#True
   * @param {string} [message] Optional message
   * @example
   *
   * (true).should.be.true();
   * false.should.not.be.true();
   *
   * ({ a: 10}).should.not.be.true();
   */
  Assertion.add('true', function (message) {
    this.is.exactly(true, message);
  });

  Assertion.alias('true', 'True');

  /**
   * Assert given object is exactly `false`.
   *
   * @name false
   * @memberOf Assertion
   * @category assertion bool
   * @alias Assertion#False
   * @param {string} [message] Optional message
   * @example
   *
   * (true).should.not.be.false();
   * false.should.be.false();
   */
  Assertion.add('false', function (message) {
    this.is.exactly(false, message);
  });

  Assertion.alias('false', 'False');

  /**
   * Assert given object is truthy according javascript type conversions.
   *
   * @name ok
   * @memberOf Assertion
   * @category assertion bool
   * @example
   *
   * (true).should.be.ok();
   * ''.should.not.be.ok();
   * should(null).not.be.ok();
   * should(void 0).not.be.ok();
   *
   * (10).should.be.ok();
   * (0).should.not.be.ok();
   */
  Assertion.add('ok', function () {
    this.params = { operator: 'to be truthy' };

    this.assert(this.obj);
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var numberAssertions = function (should, Assertion) {

  /**
   * Assert given object is NaN
   * @name NaN
   * @memberOf Assertion
   * @category assertion numbers
   * @example
   *
   * (10).should.not.be.NaN();
   * NaN.should.be.NaN();
   */
  Assertion.add('NaN', function () {
    this.params = { operator: 'to be NaN' };

    this.assert(this.obj !== this.obj);
  });

  /**
   * Assert given object is not finite (positive or negative)
   *
   * @name Infinity
   * @memberOf Assertion
   * @category assertion numbers
   * @example
   *
   * (10).should.not.be.Infinity();
   * NaN.should.not.be.Infinity();
   */
  Assertion.add('Infinity', function () {
    this.params = { operator: 'to be Infinity' };

    this.is.a.Number().and.not.a.NaN().and.assert(!isFinite(this.obj));
  });

  /**
   * Assert given number between `start` and `finish` or equal one of them.
   *
   * @name within
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} start Start number
   * @param {number} finish Finish number
   * @param {string} [description] Optional message
   * @example
   *
   * (10).should.be.within(0, 20);
   */
  Assertion.add('within', function (start, finish, description) {
    this.params = { operator: 'to be within ' + start + '..' + finish, message: description };

    this.assert(this.obj >= start && this.obj <= finish);
  });

  /**
   * Assert given number near some other `value` within `delta`
   *
   * @name approximately
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} value Center number
   * @param {number} delta Radius
   * @param {string} [description] Optional message
   * @example
   *
   * (9.99).should.be.approximately(10, 0.1);
   */
  Assertion.add('approximately', function (value, delta, description) {
    this.params = { operator: 'to be approximately ' + value + ' ' + delta, message: description };

    this.assert(Math.abs(this.obj - value) <= delta);
  });

  /**
   * Assert given number above `n`.
   *
   * @name above
   * @alias Assertion#greaterThan
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} n Margin number
   * @param {string} [description] Optional message
   * @example
   *
   * (10).should.be.above(0);
   */
  Assertion.add('above', function (n, description) {
    this.params = { operator: 'to be above ' + n, message: description };

    this.assert(this.obj > n);
  });

  /**
   * Assert given number below `n`.
   *
   * @name below
   * @alias Assertion#lessThan
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} n Margin number
   * @param {string} [description] Optional message
   * @example
   *
   * (0).should.be.below(10);
   */
  Assertion.add('below', function (n, description) {
    this.params = { operator: 'to be below ' + n, message: description };

    this.assert(this.obj < n);
  });

  Assertion.alias('above', 'greaterThan');
  Assertion.alias('below', 'lessThan');

  /**
   * Assert given number above `n`.
   *
   * @name aboveOrEqual
   * @alias Assertion#greaterThanOrEqual
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} n Margin number
   * @param {string} [description] Optional message
   * @example
   *
   * (10).should.be.aboveOrEqual(0);
   * (10).should.be.aboveOrEqual(10);
   */
  Assertion.add('aboveOrEqual', function (n, description) {
    this.params = { operator: 'to be above or equal' + n, message: description };

    this.assert(this.obj >= n);
  });

  /**
   * Assert given number below `n`.
   *
   * @name belowOrEqual
   * @alias Assertion#lessThanOrEqual
   * @memberOf Assertion
   * @category assertion numbers
   * @param {number} n Margin number
   * @param {string} [description] Optional message
   * @example
   *
   * (0).should.be.belowOrEqual(10);
   * (0).should.be.belowOrEqual(0);
   */
  Assertion.add('belowOrEqual', function (n, description) {
    this.params = { operator: 'to be below or equal' + n, message: description };

    this.assert(this.obj <= n);
  });

  Assertion.alias('aboveOrEqual', 'greaterThanOrEqual');
  Assertion.alias('belowOrEqual', 'lessThanOrEqual');
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var typeAssertions = function (should, Assertion) {
  /**
   * Assert given object is number
   * @name Number
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Number', function () {
    this.params = { operator: 'to be a number' };

    this.have.type('number');
  });

  /**
   * Assert given object is arguments
   * @name arguments
   * @alias Assertion#Arguments
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('arguments', function () {
    this.params = { operator: 'to be arguments' };

    this.have.class('Arguments');
  });

  Assertion.alias('arguments', 'Arguments');

  /**
   * Assert given object has some type using `typeof`
   * @name type
   * @memberOf Assertion
   * @param {string} type Type name
   * @param {string} [description] Optional message
   * @category assertion types
   */
  Assertion.add('type', function (type, description) {
    this.params = { operator: 'to have type ' + type, message: description };

    should(typeof this.obj).be.exactly(type);
  });

  /**
   * Assert given object is instance of `constructor`
   * @name instanceof
   * @alias Assertion#instanceOf
   * @memberOf Assertion
   * @param {Function} constructor Constructor function
   * @param {string} [description] Optional message
   * @category assertion types
   */
  Assertion.add('instanceof', function (constructor, description) {
    this.params = { operator: 'to be an instance of ' + functionName(constructor), message: description };

    this.assert(Object(this.obj) instanceof constructor);
  });

  Assertion.alias('instanceof', 'instanceOf');

  /**
   * Assert given object is function
   * @name Function
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Function', function () {
    this.params = { operator: 'to be a function' };

    this.have.type('function');
  });

  /**
   * Assert given object is object
   * @name Object
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Object', function () {
    this.params = { operator: 'to be an object' };

    this.is.not.null().and.have.type('object');
  });

  /**
   * Assert given object is string
   * @name String
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('String', function () {
    this.params = { operator: 'to be a string' };

    this.have.type('string');
  });

  /**
   * Assert given object is array
   * @name Array
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Array', function () {
    this.params = { operator: 'to be an array' };

    this.have.class('Array');
  });

  /**
   * Assert given object is boolean
   * @name Boolean
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Boolean', function () {
    this.params = { operator: 'to be a boolean' };

    this.have.type('boolean');
  });

  /**
   * Assert given object is error
   * @name Error
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Error', function () {
    this.params = { operator: 'to be an error' };

    this.have.instanceOf(Error);
  });

  /**
   * Assert given object is a date
   * @name Date
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('Date', function () {
    this.params = { operator: 'to be a date' };

    this.have.instanceOf(Date);
  });

  /**
   * Assert given object is null
   * @name null
   * @alias Assertion#Null
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('null', function () {
    this.params = { operator: 'to be null' };

    this.assert(this.obj === null);
  });

  Assertion.alias('null', 'Null');

  /**
   * Assert given object has some internal [[Class]], via Object.prototype.toString call
   * @name class
   * @alias Assertion#Class
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('class', function (cls) {
    this.params = { operator: 'to have [[Class]] ' + cls };

    this.assert(Object.prototype.toString.call(this.obj) === '[object ' + cls + ']');
  });

  Assertion.alias('class', 'Class');

  /**
   * Assert given object is undefined
   * @name undefined
   * @alias Assertion#Undefined
   * @memberOf Assertion
   * @category assertion types
   */
  Assertion.add('undefined', function () {
    this.params = { operator: 'to be undefined' };

    this.assert(this.obj === void 0);
  });

  Assertion.alias('undefined', 'Undefined');

  /**
   * Assert given object supports es6 iterable protocol (just check
   * that object has property Symbol.iterator, which is a function)
   * @name iterable
   * @memberOf Assertion
   * @category assertion es6
   */
  Assertion.add('iterable', function () {
    this.params = { operator: 'to be iterable' };

    should(this.obj).have.property(Symbol.iterator).which.is.a.Function();
  });

  /**
   * Assert given object supports es6 iterator protocol (just check
   * that object has property next, which is a function)
   * @name iterator
   * @memberOf Assertion
   * @category assertion es6
   */
  Assertion.add('iterator', function () {
    this.params = { operator: 'to be iterator' };

    should(this.obj).have.property('next').which.is.a.Function();
  });

  /**
   * Assert given object is a generator object
   * @name generator
   * @memberOf Assertion
   * @category assertion es6
   */
  Assertion.add('generator', function () {
    this.params = { operator: 'to be generator' };

    should(this.obj).be.iterable.and.iterator.and.it.is.equal(this.obj[Symbol.iterator]());
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

function formatEqlResult(r, a, b) {
  return ((r.path.length > 0 ? 'at ' + r.path.map(formatProp).join(' -> ') : '') + (r.a === a ? '' : ', A has ' + format(r.a)) + (r.b === b ? '' : ' and B has ' + format(r.b)) + (r.showReason ? ' because ' + r.reason : '')).trim();
}

var equalityAssertions = function (should, Assertion) {

  /**
   * Deep object equality comparison. For full spec see [`should-equal tests`](https://github.com/shouldjs/equal/blob/master/test.js).
   *
   * @name eql
   * @memberOf Assertion
   * @category assertion equality
   * @alias Assertion#deepEqual
   * @param {*} val Expected value
   * @param {string} [description] Optional message
   * @example
   *
   * (10).should.be.eql(10);
   * ('10').should.not.be.eql(10);
   * (-0).should.not.be.eql(+0);
   *
   * NaN.should.be.eql(NaN);
   *
   * ({ a: 10}).should.be.eql({ a: 10 });
   * [ 'a' ].should.not.be.eql({ '0': 'a' });
   */
  Assertion.add('eql', function (val, description) {
    this.params = { operator: 'to equal', expected: val, message: description };
    var obj = this.obj;
    var fails = eql(this.obj, val, should.config);
    this.params.details = fails.map(function (fail) {
      return formatEqlResult(fail, obj, val);
    }).join(', ');

    this.params.showDiff = eql(getType(obj), getType(val)).length === 0;

    this.assert(fails.length === 0);
  });

  /**
   * Exact comparison using ===.
   *
   * @name equal
   * @memberOf Assertion
   * @category assertion equality
   * @alias Assertion#exactly
   * @param {*} val Expected value
   * @param {string} [description] Optional message
   * @example
   *
   * 10.should.be.equal(10);
   * 'a'.should.be.exactly('a');
   *
   * should(null).be.exactly(null);
   */
  Assertion.add('equal', function (val, description) {
    this.params = { operator: 'to be', expected: val, message: description };

    this.params.showDiff = eql(getType(this.obj), getType(val)).length === 0;

    this.assert(val === this.obj);
  });

  Assertion.alias('equal', 'exactly');
  Assertion.alias('eql', 'deepEqual');

  function addOneOf(name, message, method) {
    Assertion.add(name, function (vals) {
      if (arguments.length !== 1) {
        vals = Array.prototype.slice.call(arguments);
      } else {
        should(vals).be.Array();
      }

      this.params = { operator: message, expected: vals };

      var obj = this.obj;
      var found = false;

      shouldTypeAdaptors.forEach(vals, function (val) {
        try {
          should(val)[method](obj);
          found = true;
          return false;
        } catch (e) {
          if (e instanceof should.AssertionError) {
            return; //do nothing
          }
          throw e;
        }
      });

      this.assert(found);
    });
  }

  /**
   * Exact comparison using === to be one of supplied objects.
   *
   * @name equalOneOf
   * @memberOf Assertion
   * @category assertion equality
   * @param {Array|*} vals Expected values
   * @example
   *
   * 'ab'.should.be.equalOneOf('a', 10, 'ab');
   * 'ab'.should.be.equalOneOf(['a', 10, 'ab']);
   */
  addOneOf('equalOneOf', 'to be equals one of', 'equal');

  /**
   * Exact comparison using .eql to be one of supplied objects.
   *
   * @name oneOf
   * @memberOf Assertion
   * @category assertion equality
   * @param {Array|*} vals Expected values
   * @example
   *
   * ({a: 10}).should.be.oneOf('a', 10, 'ab', {a: 10});
   * ({a: 10}).should.be.oneOf(['a', 10, 'ab', {a: 10}]);
   */
  addOneOf('oneOf', 'to be one of', 'eql');
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var promiseAssertions = function (should, Assertion$$1) {
  /**
   * Assert given object is a Promise
   *
   * @name Promise
   * @memberOf Assertion
   * @category assertion promises
   * @example
   *
   * promise.should.be.Promise()
   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.a.Promise()
   * (10).should.not.be.a.Promise()
   */
  Assertion$$1.add('Promise', function () {
    this.params = { operator: 'to be promise' };

    var obj = this.obj;

    should(obj).have.property('then').which.is.a.Function();
  });

  /**
   * Assert given promise will be fulfilled. Result of assertion is still .thenable and should be handled accordingly.
   *
   * @name fulfilled
   * @memberOf Assertion
   * @returns {Promise}
   * @category assertion promises
   * @example
   *
   * // don't forget to handle async nature
   * (new Promise(function(resolve, reject) { resolve(10); })).should.be.fulfilled();
   *
   * // test example with mocha it is possible to return promise
   * it('is async', () => {
   *    return new Promise(resolve => resolve(10))
   *      .should.be.fulfilled();
   * });
   */
  Assertion$$1.prototype.fulfilled = function Assertion$fulfilled() {
    this.params = { operator: 'to be fulfilled' };

    should(this.obj).be.a.Promise();

    var that = this;
    return this.obj.then(function next$onResolve(value) {
      if (that.negate) {
        that.fail();
      }
      return value;
    }, function next$onReject(err) {
      if (!that.negate) {
        that.params.operator += ', but it was rejected with ' + should.format(err);
        that.fail();
      }
      return err;
    });
  };

  /**
   * Assert given promise will be rejected. Result of assertion is still .thenable and should be handled accordingly.
   *
   * @name rejected
   * @memberOf Assertion
   * @category assertion promises
   * @returns {Promise}
   * @example
   *
   * // don't forget to handle async nature
   * (new Promise(function(resolve, reject) { resolve(10); }))
   *    .should.not.be.rejected();
   *
   * // test example with mocha it is possible to return promise
   * it('is async', () => {
   *    return new Promise((resolve, reject) => reject(new Error('boom')))
   *      .should.be.rejected();
   * });
   */
  Assertion$$1.prototype.rejected = function () {
    this.params = { operator: 'to be rejected' };

    should(this.obj).be.a.Promise();

    var that = this;
    return this.obj.then(function (value) {
      if (!that.negate) {
        that.params.operator += ', but it was fulfilled';
        if (arguments.length != 0) {
          that.params.operator += ' with ' + should.format(value);
        }
        that.fail();
      }
      return value;
    }, function next$onError(err) {
      if (that.negate) {
        that.fail();
      }
      return err;
    });
  };

  /**
   * Assert given promise will be fulfilled with some expected value (value compared using .eql).
   * Result of assertion is still .thenable and should be handled accordingly.
   *
   * @name fulfilledWith
   * @memberOf Assertion
   * @category assertion promises
   * @returns {Promise}
   * @example
   *
   * // don't forget to handle async nature
   * (new Promise(function(resolve, reject) { resolve(10); }))
   *    .should.be.fulfilledWith(10);
   *
   * // test example with mocha it is possible to return promise
   * it('is async', () => {
   *    return new Promise((resolve, reject) => resolve(10))
   *       .should.be.fulfilledWith(10);
   * });
   */
  Assertion$$1.prototype.fulfilledWith = function (expectedValue) {
    this.params = { operator: 'to be fulfilled with ' + should.format(expectedValue) };

    should(this.obj).be.a.Promise();

    var that = this;
    return this.obj.then(function (value) {
      if (that.negate) {
        that.fail();
      }
      should(value).eql(expectedValue);
      return value;
    }, function next$onError(err) {
      if (!that.negate) {
        that.params.operator += ', but it was rejected with ' + should.format(err);
        that.fail();
      }
      return err;
    });
  };

  /**
   * Assert given promise will be rejected with some sort of error. Arguments is the same for Assertion#throw.
   * Result of assertion is still .thenable and should be handled accordingly.
   *
   * @name rejectedWith
   * @memberOf Assertion
   * @category assertion promises
   * @returns {Promise}
   * @example
   *
   * function failedPromise() {
   *   return new Promise(function(resolve, reject) {
   *     reject(new Error('boom'))
   *   })
   * }
   * failedPromise().should.be.rejectedWith(Error);
   * failedPromise().should.be.rejectedWith('boom');
   * failedPromise().should.be.rejectedWith(/boom/);
   * failedPromise().should.be.rejectedWith(Error, { message: 'boom' });
   * failedPromise().should.be.rejectedWith({ message: 'boom' });
   *
   * // test example with mocha it is possible to return promise
   * it('is async', () => {
   *    return failedPromise().should.be.rejectedWith({ message: 'boom' });
   * });
   */
  Assertion$$1.prototype.rejectedWith = function (message, properties) {
    this.params = { operator: 'to be rejected' };

    should(this.obj).be.a.Promise();

    var that = this;
    return this.obj.then(function (value) {
      if (!that.negate) {
        that.fail();
      }
      return value;
    }, function next$onError(err) {
      if (that.negate) {
        that.fail();
      }

      var errorMatched = true;
      var errorInfo = '';

      if ('string' === typeof message) {
        errorMatched = message === err.message;
      } else if (message instanceof RegExp) {
        errorMatched = message.test(err.message);
      } else if ('function' === typeof message) {
        errorMatched = err instanceof message;
      } else if (message !== null && typeof message === 'object') {
        try {
          should(err).match(message);
        } catch (e) {
          if (e instanceof should.AssertionError) {
            errorInfo = ': ' + e.message;
            errorMatched = false;
          } else {
            throw e;
          }
        }
      }

      if (!errorMatched) {
        if (typeof message === 'string' || message instanceof RegExp) {
          errorInfo = ' with a message matching ' + should.format(message) + ", but got '" + err.message + "'";
        } else if ('function' === typeof message) {
          errorInfo = ' of type ' + functionName(message) + ', but got ' + functionName(err.constructor);
        }
      } else if ('function' === typeof message && properties) {
        try {
          should(err).match(properties);
        } catch (e) {
          if (e instanceof should.AssertionError) {
            errorInfo = ': ' + e.message;
            errorMatched = false;
          } else {
            throw e;
          }
        }
      }

      that.params.operator += errorInfo;

      that.assert(errorMatched);

      return err;
    });
  };

  /**
   * Assert given object is promise and wrap it in PromisedAssertion, which has all properties of Assertion.
   * That means you can chain as with usual Assertion.
   * Result of assertion is still .thenable and should be handled accordingly.
   *
   * @name finally
   * @memberOf Assertion
   * @alias Assertion#eventually
   * @category assertion promises
   * @returns {PromisedAssertion} Like Assertion, but .then this.obj in Assertion
   * @example
   *
   * (new Promise(function(resolve, reject) { resolve(10); }))
   *    .should.be.eventually.equal(10);
   *
   * // test example with mocha it is possible to return promise
   * it('is async', () => {
   *    return new Promise(resolve => resolve(10))
   *      .should.be.finally.equal(10);
   * });
   */
  Object.defineProperty(Assertion$$1.prototype, 'finally', {
    get: function () {
      should(this.obj).be.a.Promise();

      var that = this;

      return new PromisedAssertion(this.obj.then(function (obj) {
        var a = should(obj);

        a.negate = that.negate;
        a.anyOne = that.anyOne;

        return a;
      }));
    }
  });

  Assertion$$1.alias('finally', 'eventually');
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var stringAssertions = function (should, Assertion) {
  /**
   * Assert given string starts with prefix
   * @name startWith
   * @memberOf Assertion
   * @category assertion strings
   * @param {string} str Prefix
   * @param {string} [description] Optional message
   * @example
   *
   * 'abc'.should.startWith('a');
   */
  Assertion.add('startWith', function (str, description) {
    this.params = { operator: 'to start with ' + should.format(str), message: description };

    this.assert(0 === this.obj.indexOf(str));
  });

  /**
   * Assert given string ends with prefix
   * @name endWith
   * @memberOf Assertion
   * @category assertion strings
   * @param {string} str Prefix
   * @param {string} [description] Optional message
   * @example
   *
   * 'abca'.should.endWith('a');
   */
  Assertion.add('endWith', function (str, description) {
    this.params = { operator: 'to end with ' + should.format(str), message: description };

    this.assert(this.obj.indexOf(str, this.obj.length - str.length) >= 0);
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var containAssertions = function (should, Assertion) {
  var i = should.format;

  /**
   * Assert that given object contain something that equal to `other`. It uses `should-equal` for equality checks.
   * If given object is array it search that one of elements was equal to `other`.
   * If given object is string it checks if `other` is a substring - expected that `other` is a string.
   * If given object is Object it checks that `other` is a subobject - expected that `other` is a object.
   *
   * @name containEql
   * @memberOf Assertion
   * @category assertion contain
   * @param {*} other Nested object
   * @example
   *
   * [1, 2, 3].should.containEql(1);
   * [{ a: 1 }, 'a', 10].should.containEql({ a: 1 });
   *
   * 'abc'.should.containEql('b');
   * 'ab1c'.should.containEql(1);
   *
   * ({ a: 10, c: { d: 10 }}).should.containEql({ a: 10 });
   * ({ a: 10, c: { d: 10 }}).should.containEql({ c: { d: 10 }});
   * ({ a: 10, c: { d: 10 }}).should.containEql({ b: 10 });
   * // throws AssertionError: expected { a: 10, c: { d: 10 } } to contain { b: 10 }
   * //            expected { a: 10, c: { d: 10 } } to have property b
   */
  Assertion.add('containEql', function (other) {
    this.params = { operator: 'to contain ' + i(other) };

    this.is.not.null().and.not.undefined();

    var obj = this.obj;

    if (typeof obj == 'string') {
      this.assert(obj.indexOf(String(other)) >= 0);
    } else if (shouldTypeAdaptors.isIterable(obj)) {
      this.assert(shouldTypeAdaptors.some(obj, function (v) {
        return eql(v, other).length === 0;
      }));
    } else {
      shouldTypeAdaptors.forEach(other, function (value, key) {
        should(obj).have.value(key, value);
      }, this);
    }
  });

  /**
   * Assert that given object is contain equally structured object on the same depth level.
   * If given object is an array and `other` is an array it checks that the eql elements is going in the same sequence in given array (recursive)
   * If given object is an object it checks that the same keys contain deep equal values (recursive)
   * On other cases it try to check with `.eql`
   *
   * @name containDeepOrdered
   * @memberOf Assertion
   * @category assertion contain
   * @param {*} other Nested object
   * @example
   *
   * [ 1, 2, 3].should.containDeepOrdered([1, 2]);
   * [ 1, 2, [ 1, 2, 3 ]].should.containDeepOrdered([ 1, [ 2, 3 ]]);
   *
   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({a: 10});
   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {c: 10}});
   * ({ a: 10, b: { c: 10, d: [1, 2, 3] }}).should.containDeepOrdered({b: {d: [1, 3]}});
   */
  Assertion.add('containDeepOrdered', function (other) {
    this.params = { operator: 'to contain ' + i(other) };

    var obj = this.obj;
    if (typeof obj == 'string') {
      // expect other to be string
      this.is.equal(String(other));
    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {
      var objIterator = shouldTypeAdaptors.iterator(obj);
      var otherIterator = shouldTypeAdaptors.iterator(other);

      var nextObj = objIterator.next();
      var nextOther = otherIterator.next();
      while (!nextObj.done && !nextOther.done) {
        try {
          should(nextObj.value[1]).containDeepOrdered(nextOther.value[1]);
          nextOther = otherIterator.next();
        } catch (e) {
          if (!(e instanceof should.AssertionError)) {
            throw e;
          }
        }
        nextObj = objIterator.next();
      }

      this.assert(nextOther.done);
    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {
      //TODO compare types object contains object case
      shouldTypeAdaptors.forEach(other, function (value, key) {
        should(obj[key]).containDeepOrdered(value);
      });

      // if both objects is empty means we finish traversing - and we need to compare for hidden values
      if (shouldTypeAdaptors.isEmpty(other)) {
        this.eql(other);
      }
    } else {
      this.eql(other);
    }
  });

  /**
   * The same like `Assertion#containDeepOrdered` but all checks on arrays without order.
   *
   * @name containDeep
   * @memberOf Assertion
   * @category assertion contain
   * @param {*} other Nested object
   * @example
   *
   * [ 1, 2, 3].should.containDeep([2, 1]);
   * [ 1, 2, [ 1, 2, 3 ]].should.containDeep([ 1, [ 3, 1 ]]);
   */
  Assertion.add('containDeep', function (other) {
    this.params = { operator: 'to contain ' + i(other) };

    var obj = this.obj;
    if (typeof obj == 'string') {
      // expect other to be string
      this.is.equal(String(other));
    } else if (shouldTypeAdaptors.isIterable(obj) && shouldTypeAdaptors.isIterable(other)) {
      var usedKeys = {};
      shouldTypeAdaptors.forEach(other, function (otherItem) {
        this.assert(shouldTypeAdaptors.some(obj, function (item, index) {
          if (index in usedKeys) {
            return false;
          }

          try {
            should(item).containDeep(otherItem);
            usedKeys[index] = true;
            return true;
          } catch (e) {
            if (e instanceof should.AssertionError) {
              return false;
            }
            throw e;
          }
        }));
      }, this);
    } else if (obj != null && other != null && typeof obj == 'object' && typeof other == 'object') {
      // object contains object case
      shouldTypeAdaptors.forEach(other, function (value, key) {
        should(obj[key]).containDeep(value);
      });

      // if both objects is empty means we finish traversing - and we need to compare for hidden values
      if (shouldTypeAdaptors.isEmpty(other)) {
        this.eql(other);
      }
    } else {
      this.eql(other);
    }
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var aSlice = Array.prototype.slice;

var propertyAssertions = function (should, Assertion) {
  var i = should.format;
  /**
   * Asserts given object has some descriptor. **On success it change given object to be value of property**.
   *
   * @name propertyWithDescriptor
   * @memberOf Assertion
   * @category assertion property
   * @param {string} name Name of property
   * @param {Object} desc Descriptor like used in Object.defineProperty (not required to add all properties)
   * @example
   *
   * ({ a: 10 }).should.have.propertyWithDescriptor('a', { enumerable: true });
   */
  Assertion.add('propertyWithDescriptor', function (name, desc) {
    this.params = { actual: this.obj, operator: 'to have own property with descriptor ' + i(desc) };
    var obj = this.obj;
    this.have.ownProperty(name);
    should(Object.getOwnPropertyDescriptor(Object(obj), name)).have.properties(desc);
  });

  function processPropsArgs() {
    var args = {};
    if (arguments.length > 1) {
      args.names = aSlice.call(arguments);
    } else {
      var arg = arguments[0];
      if (typeof arg === 'string') {
        args.names = [arg];
      } else if (Array.isArray(arg)) {
        args.names = arg;
      } else {
        args.names = Object.keys(arg);
        args.values = arg;
      }
    }
    return args;
  }

  Assertion.add('enumerable', function (name, val) {
    name = convertPropertyName(name);

    this.params = {
      operator: "to have enumerable property " + formatProp(name) + (arguments.length > 1 ? " equal to " + i(val) : "")
    };

    var desc = { enumerable: true };
    if (arguments.length > 1) {
      desc.value = val;
    }
    this.have.propertyWithDescriptor(name, desc);
  });

  Assertion.add('enumerables', function () /*names*/{
    var args = processPropsArgs.apply(null, arguments);

    this.params = {
      operator: "to have enumerables " + args.names.map(formatProp)
    };

    var obj = this.obj;
    args.names.forEach(function (name) {
      should(obj).have.enumerable(name);
    });
  });

  /**
   * Asserts given object has property with optionally value. **On success it change given object to be value of property**.
   *
   * @name property
   * @memberOf Assertion
   * @category assertion property
   * @param {string} name Name of property
   * @param {*} [val] Optional property value to check
   * @example
   *
   * ({ a: 10 }).should.have.property('a');
   */
  Assertion.add('property', function (name, val) {
    name = convertPropertyName(name);
    if (arguments.length > 1) {
      var p = {};
      p[name] = val;
      this.have.properties(p);
    } else {
      this.have.properties(name);
    }
    this.obj = this.obj[name];
  });

  /**
   * Asserts given object has properties. On this method affect .any modifier, which allow to check not all properties.
   *
   * @name properties
   * @memberOf Assertion
   * @category assertion property
   * @param {Array|...string|Object} names Names of property
   * @example
   *
   * ({ a: 10 }).should.have.properties('a');
   * ({ a: 10, b: 20 }).should.have.properties([ 'a' ]);
   * ({ a: 10, b: 20 }).should.have.properties({ b: 20 });
   */
  Assertion.add('properties', function (names) {
    var values = {};
    if (arguments.length > 1) {
      names = aSlice.call(arguments);
    } else if (!Array.isArray(names)) {
      if (typeof names == 'string' || typeof names == 'symbol') {
        names = [names];
      } else {
        values = names;
        names = Object.keys(names);
      }
    }

    var obj = Object(this.obj),
        missingProperties = [];

    //just enumerate properties and check if they all present
    names.forEach(function (name) {
      if (!(name in obj)) {
        missingProperties.push(formatProp(name));
      }
    });

    var props = missingProperties;
    if (props.length === 0) {
      props = names.map(formatProp);
    } else if (this.anyOne) {
      props = names.filter(function (name) {
        return missingProperties.indexOf(formatProp(name)) < 0;
      }).map(formatProp);
    }

    var operator = (props.length === 1 ? 'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');

    this.params = { obj: this.obj, operator: operator };

    //check that all properties presented
    //or if we request one of them that at least one them presented
    this.assert(missingProperties.length === 0 || this.anyOne && missingProperties.length != names.length);

    // check if values in object matched expected
    var valueCheckNames = Object.keys(values);
    if (valueCheckNames.length) {
      var wrongValues = [];
      props = [];

      // now check values, as there we have all properties
      valueCheckNames.forEach(function (name) {
        var value = values[name];
        if (eql(obj[name], value).length !== 0) {
          wrongValues.push(formatProp(name) + ' of ' + i(value) + ' (got ' + i(obj[name]) + ')');
        } else {
          props.push(formatProp(name) + ' of ' + i(value));
        }
      });

      if (wrongValues.length !== 0 && !this.anyOne || this.anyOne && props.length === 0) {
        props = wrongValues;
      }

      operator = (props.length === 1 ? 'to have property ' : 'to have ' + (this.anyOne ? 'any of ' : '') + 'properties ') + props.join(', ');

      this.params = { obj: this.obj, operator: operator };

      //if there is no not matched values
      //or there is at least one matched
      this.assert(wrongValues.length === 0 || this.anyOne && wrongValues.length != valueCheckNames.length);
    }
  });

  /**
   * Asserts given object has property `length` with given value `n`
   *
   * @name length
   * @alias Assertion#lengthOf
   * @memberOf Assertion
   * @category assertion property
   * @param {number} n Expected length
   * @param {string} [description] Optional message
   * @example
   *
   * [1, 2].should.have.length(2);
   */
  Assertion.add('length', function (n, description) {
    this.have.property('length', n, description);
  });

  Assertion.alias('length', 'lengthOf');

  /**
   * Asserts given object has own property. **On success it change given object to be value of property**.
   *
   * @name ownProperty
   * @alias Assertion#hasOwnProperty
   * @memberOf Assertion
   * @category assertion property
   * @param {string} name Name of property
   * @param {string} [description] Optional message
   * @example
   *
   * ({ a: 10 }).should.have.ownProperty('a');
   */
  Assertion.add('ownProperty', function (name, description) {
    name = convertPropertyName(name);
    this.params = {
      actual: this.obj,
      operator: 'to have own property ' + formatProp(name),
      message: description
    };

    this.assert(shouldUtil.hasOwnProperty(this.obj, name));

    this.obj = this.obj[name];
  });

  Assertion.alias('ownProperty', 'hasOwnProperty');

  /**
   * Asserts given object is empty. For strings, arrays and arguments it checks .length property, for objects it checks keys.
   *
   * @name empty
   * @memberOf Assertion
   * @category assertion property
   * @example
   *
   * ''.should.be.empty();
   * [].should.be.empty();
   * ({}).should.be.empty();
   */
  Assertion.add('empty', function () {
    this.params = { operator: 'to be empty' };
    this.assert(shouldTypeAdaptors.isEmpty(this.obj));
  }, true);

  /**
   * Asserts given object has such keys. Compared to `properties`, `keys` does not accept Object as a argument.
   * When calling via .key current object in assertion changed to value of this key
   *
   * @name keys
   * @alias Assertion#key
   * @memberOf Assertion
   * @category assertion property
   * @param {...*} keys Keys to check
   * @example
   *
   * ({ a: 10 }).should.have.keys('a');
   * ({ a: 10, b: 20 }).should.have.keys('a', 'b');
   * (new Map([[1, 2]])).should.have.key(1);
   *
   * json.should.have.only.keys('type', 'version')
   */
  Assertion.add('keys', function (keys) {
    keys = aSlice.call(arguments);

    var obj = Object(this.obj);

    // first check if some keys are missing
    var missingKeys = keys.filter(function (key) {
      return !shouldTypeAdaptors.has(obj, key);
    });

    var verb = 'to have ' + (this.onlyThis ? 'only ' : '') + (keys.length === 1 ? 'key ' : 'keys ');

    this.params = { operator: verb + keys.join(', ') };

    if (missingKeys.length > 0) {
      this.params.operator += '\n\tmissing keys: ' + missingKeys.join(', ');
    }

    this.assert(missingKeys.length === 0);

    if (this.onlyThis) {
      obj.should.have.size(keys.length);
    }
  });

  Assertion.add('key', function (key) {
    this.have.keys(key);
    this.obj = shouldTypeAdaptors.get(this.obj, key);
  });

  /**
   * Asserts given object has such value for given key
   *
   * @name value
   * @memberOf Assertion
   * @category assertion property
   * @param {*} key Key to check
   * @param {*} value Value to check
   * @example
   *
   * ({ a: 10 }).should.have.value('a', 10);
   * (new Map([[1, 2]])).should.have.value(1, 2);
   */
  Assertion.add('value', function (key, value) {
    this.have.key(key).which.is.eql(value);
  });

  /**
   * Asserts given object has such size.
   *
   * @name size
   * @memberOf Assertion
   * @category assertion property
   * @param {number} s Size to check
   * @example
   *
   * ({ a: 10 }).should.have.size(1);
   * (new Map([[1, 2]])).should.have.size(1);
   */
  Assertion.add('size', function (s) {
    this.params = { operator: 'to have size ' + s };
    shouldTypeAdaptors.size(this.obj).should.be.exactly(s);
  });

  /**
   * Asserts given object has nested property in depth by path. **On success it change given object to be value of final property**.
   *
   * @name propertyByPath
   * @memberOf Assertion
   * @category assertion property
   * @param {Array|...string} properties Properties path to search
   * @example
   *
   * ({ a: {b: 10}}).should.have.propertyByPath('a', 'b').eql(10);
   */
  Assertion.add('propertyByPath', function (properties) {
    var this$1 = this;

    properties = aSlice.call(arguments);

    var allProps = properties.map(formatProp);

    properties = properties.map(convertPropertyName);

    var obj = should(Object(this.obj));

    var foundProperties = [];

    var currentProperty;
    while (properties.length) {
      currentProperty = properties.shift();
      this$1.params = { operator: 'to have property by path ' + allProps.join(', ') + ' - failed on ' + formatProp(currentProperty) };
      obj = obj.have.property(currentProperty);
      foundProperties.push(currentProperty);
    }

    this.params = { obj: this.obj, operator: 'to have property by path ' + allProps.join(', ') };

    this.obj = obj.obj;
  });
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */
var errorAssertions = function (should, Assertion) {
  var i = should.format;

  /**
   * Assert given function throws error with such message.
   *
   * @name throw
   * @memberOf Assertion
   * @category assertion errors
   * @alias Assertion#throwError
   * @param {string|RegExp|Function|Object|GeneratorFunction|GeneratorObject} [message] Message to match or properties
   * @param {Object} [properties] Optional properties that will be matched to thrown error
   * @example
   *
   * (function(){ throw new Error('fail') }).should.throw();
   * (function(){ throw new Error('fail') }).should.throw('fail');
   * (function(){ throw new Error('fail') }).should.throw(/fail/);
   *
   * (function(){ throw new Error('fail') }).should.throw(Error);
   * var error = new Error();
   * error.a = 10;
   * (function(){ throw error; }).should.throw(Error, { a: 10 });
   * (function(){ throw error; }).should.throw({ a: 10 });
   * (function*() {
   *   yield throwError();
   * }).should.throw();
   */
  Assertion.add('throw', function (message, properties) {
    var fn = this.obj;
    var err = {};
    var errorInfo = '';
    var thrown = false;

    if (shouldUtil.isGeneratorFunction(fn)) {
      return should(fn()).throw(message, properties);
    } else if (shouldUtil.isIterator(fn)) {
      return should(fn.next.bind(fn)).throw(message, properties);
    }

    this.is.a.Function();

    var errorMatched = true;

    try {
      fn();
    } catch (e) {
      thrown = true;
      err = e;
    }

    if (thrown) {
      if (message) {
        if ('string' == typeof message) {
          errorMatched = message == err.message;
        } else if (message instanceof RegExp) {
          errorMatched = message.test(err.message);
        } else if ('function' == typeof message) {
          errorMatched = err instanceof message;
        } else if (null != message) {
          try {
            should(err).match(message);
          } catch (e) {
            if (e instanceof should.AssertionError) {
              errorInfo = ": " + e.message;
              errorMatched = false;
            } else {
              throw e;
            }
          }
        }

        if (!errorMatched) {
          if ('string' == typeof message || message instanceof RegExp) {
            errorInfo = " with a message matching " + i(message) + ", but got '" + err.message + "'";
          } else if ('function' == typeof message) {
            errorInfo = " of type " + functionName(message) + ", but got " + functionName(err.constructor);
          }
        } else if ('function' == typeof message && properties) {
          try {
            should(err).match(properties);
          } catch (e) {
            if (e instanceof should.AssertionError) {
              errorInfo = ": " + e.message;
              errorMatched = false;
            } else {
              throw e;
            }
          }
        }
      } else {
        errorInfo = " (got " + i(err) + ")";
      }
    }

    this.params = { operator: 'to throw exception' + errorInfo };

    this.assert(thrown);
    this.assert(errorMatched);
  });

  Assertion.alias('throw', 'throwError');
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */

var matchingAssertions = function (should, Assertion) {
  var i = should.format;

  /**
   * Asserts if given object match `other` object, using some assumptions:
   * First object matched if they are equal,
   * If `other` is a regexp and given object is a string check on matching with regexp
   * If `other` is a regexp and given object is an array check if all elements matched regexp
   * If `other` is a regexp and given object is an object check values on matching regexp
   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched
   * If `other` is an object check if the same keys matched with above rules
   * All other cases failed.
   *
   * Usually it is right idea to add pre type assertions, like `.String()` or `.Object()` to be sure assertions will do what you are expecting.
   * Object iteration happen by keys (properties with enumerable: true), thus some objects can cause small pain. Typical example is js
   * Error - it by default has 2 properties `name` and `message`, but they both non-enumerable. In this case make sure you specify checking props (see examples).
   *
   * @name match
   * @memberOf Assertion
   * @category assertion matching
   * @param {*} other Object to match
   * @param {string} [description] Optional message
   * @example
   * 'foobar'.should.match(/^foo/);
   * 'foobar'.should.not.match(/^bar/);
   *
   * ({ a: 'foo', c: 'barfoo' }).should.match(/foo$/);
   *
   * ['a', 'b', 'c'].should.match(/[a-z]/);
   *
   * (5).should.not.match(function(n) {
   *   return n < 0;
   * });
   * (5).should.not.match(function(it) {
   *    it.should.be.an.Array();
   * });
   * ({ a: 10, b: 'abc', c: { d: 10 }, d: 0 }).should
   * .match({ a: 10, b: /c$/, c: function(it) {
   *    return it.should.have.property('d', 10);
   * }});
   *
   * [10, 'abc', { d: 10 }, 0].should
   * .match({ '0': 10, '1': /c$/, '2': function(it) {
   *    return it.should.have.property('d', 10);
   * }});
   *
   * var myString = 'abc';
   *
   * myString.should.be.a.String().and.match(/abc/);
   *
   * myString = {};
   *
   * myString.should.match(/abc/); //yes this will pass
   * //better to do
   * myString.should.be.an.Object().and.not.empty().and.match(/abc/);//fixed
   *
   * (new Error('boom')).should.match(/abc/);//passed because no keys
   * (new Error('boom')).should.not.match({ message: /abc/ });//check specified property
   */
  Assertion.add('match', function (other, description) {
    this.params = { operator: 'to match ' + i(other), message: description };

    if (eql(this.obj, other).length !== 0) {
      if (other instanceof RegExp) {
        // something - regex

        if (typeof this.obj == 'string') {

          this.assert(other.exec(this.obj));
        } else if (null != this.obj && typeof this.obj == 'object') {

          var notMatchedProps = [],
              matchedProps = [];
          shouldTypeAdaptors.forEach(this.obj, function (value, name) {
            if (other.exec(value)) {
              matchedProps.push(formatProp(name));
            } else {
              notMatchedProps.push(formatProp(name) + ' (' + i(value) + ')');
            }
          }, this);

          if (notMatchedProps.length) {
            this.params.operator += '\n    not matched properties: ' + notMatchedProps.join(', ');
          }
          if (matchedProps.length) {
            this.params.operator += '\n    matched properties: ' + matchedProps.join(', ');
          }

          this.assert(notMatchedProps.length === 0);
        } // should we try to convert to String and exec?
        else {
            this.assert(false);
          }
      } else if (typeof other == 'function') {
        var res;

        res = other(this.obj);

        //if we throw exception ok - it is used .should inside
        if (typeof res == 'boolean') {
          this.assert(res); // if it is just boolean function assert on it
        }
      } else if (other != null && this.obj != null && typeof other == 'object' && typeof this.obj == 'object') {
        // try to match properties (for Object and Array)
        notMatchedProps = [];
        matchedProps = [];

        shouldTypeAdaptors.forEach(other, function (value, key) {
          try {
            should(this.obj).have.property(key).which.match(value);
            matchedProps.push(formatProp(key));
          } catch (e) {
            if (e instanceof should.AssertionError) {
              notMatchedProps.push(formatProp(key) + ' (' + i(this.obj[key]) + ')');
            } else {
              throw e;
            }
          }
        }, this);

        if (notMatchedProps.length) {
          this.params.operator += '\n    not matched properties: ' + notMatchedProps.join(', ');
        }
        if (matchedProps.length) {
          this.params.operator += '\n    matched properties: ' + matchedProps.join(', ');
        }

        this.assert(notMatchedProps.length === 0);
      } else {
        this.assert(false);
      }
    }
  });

  /**
   * Asserts if given object values or array elements all match `other` object, using some assumptions:
   * First object matched if they are equal,
   * If `other` is a regexp - matching with regexp
   * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched
   * All other cases check if this `other` equal to each element
   *
   * @name matchEach
   * @memberOf Assertion
   * @category assertion matching
   * @alias Assertion#matchEvery
   * @param {*} other Object to match
   * @param {string} [description] Optional message
   * @example
   * [ 'a', 'b', 'c'].should.matchEach(/\w+/);
   * [ 'a', 'a', 'a'].should.matchEach('a');
   *
   * [ 'a', 'a', 'a'].should.matchEach(function(value) { value.should.be.eql('a') });
   *
   * { a: 'a', b: 'a', c: 'a' }.should.matchEach(function(value) { value.should.be.eql('a') });
   */
  Assertion.add('matchEach', function (other, description) {
    this.params = { operator: 'to match each ' + i(other), message: description };

    shouldTypeAdaptors.forEach(this.obj, function (value) {
      should(value).match(other);
    }, this);
  });

  /**
  * Asserts if any of given object values or array elements match `other` object, using some assumptions:
  * First object matched if they are equal,
  * If `other` is a regexp - matching with regexp
  * If `other` is a function check if this function throws AssertionError on given object or return false - it will be assumed as not matched
  * All other cases check if this `other` equal to each element
  *
  * @name matchAny
  * @memberOf Assertion
  * @category assertion matching
  * @param {*} other Object to match
  * @alias Assertion#matchSome
  * @param {string} [description] Optional message
  * @example
  * [ 'a', 'b', 'c'].should.matchAny(/\w+/);
  * [ 'a', 'b', 'c'].should.matchAny('a');
  *
  * [ 'a', 'b', 'c'].should.matchAny(function(value) { value.should.be.eql('a') });
  *
  * { a: 'a', b: 'b', c: 'c' }.should.matchAny(function(value) { value.should.be.eql('a') });
  */
  Assertion.add('matchAny', function (other, description) {
    this.params = { operator: 'to match any ' + i(other), message: description };

    this.assert(shouldTypeAdaptors.some(this.obj, function (value) {
      try {
        should(value).match(other);
        return true;
      } catch (e) {
        if (e instanceof should.AssertionError) {
          // Caught an AssertionError, return false to the iterator
          return false;
        }
        throw e;
      }
    }));
  });

  Assertion.alias('matchAny', 'matchSome');
  Assertion.alias('matchEach', 'matchEvery');
};

/*
 * should.js - assertion library
 * Copyright(c) 2010-2013 TJ Holowaychuk <tj@vision-media.ca>
 * Copyright(c) 2013-2016 Denis Bardadym <bardadymchik@gmail.com>
 * MIT Licensed
 */
/**
 * Our function should
 *
 * @param {*} obj Object to assert
 * @returns {should.Assertion} Returns new Assertion for beginning assertion chain
 * @example
 *
 * var should = require('should');
 * should('abc').be.a.String();
 */
function should(obj) {
  return new Assertion(obj);
}

should.AssertionError = AssertionError;
should.Assertion = Assertion;

// exposing modules dirty way
should.modules = {
  format: sformat,
  type: getType,
  equal: eql
};
should.format = format;

/**
 * Object with configuration.
 * It contains such properties:
 * * `checkProtoEql` boolean - Affect if `.eql` will check objects prototypes
 * * `plusZeroAndMinusZeroEqual` boolean - Affect if `.eql` will treat +0 and -0 as equal
 * Also it can contain options for should-format.
 *
 * @type {Object}
 * @memberOf should
 * @static
 * @example
 *
 * var a = { a: 10 }, b = Object.create(null);
 * b.a = 10;
 *
 * a.should.be.eql(b);
 * //not throws
 *
 * should.config.checkProtoEql = true;
 * a.should.be.eql(b);
 * //throws AssertionError: expected { a: 10 } to equal { a: 10 } (because A and B have different prototypes)
 */
should.config = config;

/**
 * Allow to extend given prototype with should property using given name. This getter will **unwrap** all standard wrappers like `Number`, `Boolean`, `String`.
 * Using `should(obj)` is the equivalent of using `obj.should` with known issues (like nulls and method calls etc).
 *
 * To add new assertions, need to use Assertion.add method.
 *
 * @param {string} [propertyName] Name of property to add. Default is `'should'`.
 * @param {Object} [proto] Prototype to extend with. Default is `Object.prototype`.
 * @memberOf should
 * @returns {{ name: string, descriptor: Object, proto: Object }} Descriptor enough to return all back
 * @static
 * @example
 *
 * var prev = should.extend('must', Object.prototype);
 *
 * 'abc'.must.startWith('a');
 *
 * var should = should.noConflict(prev);
 * should.not.exist(Object.prototype.must);
 */
should.extend = function (propertyName, proto) {
  propertyName = propertyName || 'should';
  proto = proto || Object.prototype;

  var prevDescriptor = Object.getOwnPropertyDescriptor(proto, propertyName);

  Object.defineProperty(proto, propertyName, {
    set: function () {},
    get: function () {
      return should(isWrapperType(this) ? this.valueOf() : this);
    },
    configurable: true
  });

  return { name: propertyName, descriptor: prevDescriptor, proto: proto };
};

/**
 * Delete previous extension. If `desc` missing it will remove default extension.
 *
 * @param {{ name: string, descriptor: Object, proto: Object }} [desc] Returned from `should.extend` object
 * @memberOf should
 * @returns {Function} Returns should function
 * @static
 * @example
 *
 * var should = require('should').noConflict();
 *
 * should(Object.prototype).not.have.property('should');
 *
 * var prev = should.extend('must', Object.prototype);
 * 'abc'.must.startWith('a');
 * should.noConflict(prev);
 *
 * should(Object.prototype).not.have.property('must');
 */
should.noConflict = function (desc) {
  desc = desc || should._prevShould;

  if (desc) {
    delete desc.proto[desc.name];

    if (desc.descriptor) {
      Object.defineProperty(desc.proto, desc.name, desc.descriptor);
    }
  }
  return should;
};

/**
 * Simple utility function for a bit more easier should assertion extension
 * @param {Function} f So called plugin function. It should accept 2 arguments: `should` function and `Assertion` constructor
 * @memberOf should
 * @returns {Function} Returns `should` function
 * @static
 * @example
 *
 * should.use(function(should, Assertion) {
 *   Assertion.add('asset', function() {
 *      this.params = { operator: 'to be asset' };
 *
 *      this.obj.should.have.property('id').which.is.a.Number();
 *      this.obj.should.have.property('path');
 *  })
 * })
 */
should.use = function (f) {
  f(should, should.Assertion);
  return this;
};

should.use(assertExtensions).use(chainAssertions).use(booleanAssertions).use(numberAssertions).use(equalityAssertions).use(typeAssertions).use(stringAssertions).use(propertyAssertions).use(errorAssertions).use(matchingAssertions).use(containAssertions).use(promiseAssertions);

module.exports = should;


},{"should-equal":274,"should-format":275,"should-type":277,"should-type-adaptors":276,"should-util":278}],281:[function(require,module,exports){
'use strict';

var should = require('./cjs/should');

var defaultProto = Object.prototype;
var defaultProperty = 'should';

//Expose api via `Object#should`.
try {
  var prevShould = should.extend(defaultProperty, defaultProto);
  should._prevShould = prevShould;
} catch (e) {
  //ignore errors
}

module.exports = should;


},{"./cjs/should":280}],282:[function(require,module,exports){
'use strict';

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}


},{}],283:[function(require,module,exports){
'use strict';

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};


},{}],284:[function(require,module,exports){
(function (process,global){
'use strict';

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  var arguments$1 = arguments;

  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments$1[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') { return '%'; }
    if (i >= len) { return x; }
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) { debugEnviron = process.env.NODE_DEBUG || ''; }
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) { ctx.depth = arguments[2]; }
  if (arguments.length >= 4) { ctx.colors = arguments[3]; }
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) { ctx.showHidden = false; }
  if (isUndefined(ctx.depth)) { ctx.depth = 2; }
  if (isUndefined(ctx.colors)) { ctx.colors = false; }
  if (isUndefined(ctx.customInspect)) { ctx.customInspect = true; }
  if (ctx.colors) { ctx.stylize = stylizeWithColor; }
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};

  array.forEach(function (val, idx) {
    hash[val] = true;
  });

  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) { return ctx.stylize('undefined', 'undefined'); }
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) { return ctx.stylize('' + value, 'number'); }
  if (isBoolean(value)) { return ctx.stylize('' + value, 'boolean'); }
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) { return ctx.stylize('null', 'null'); }
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) { numLinesEst++; }
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) { return origin; }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}


}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":283,"_process":270,"inherits":282}],285:[function(require,module,exports){
'use strict';

module.exports.VectorTile = require('./lib/vectortile.js');
module.exports.VectorTileFeature = require('./lib/vectortilefeature.js');
module.exports.VectorTileLayer = require('./lib/vectortilelayer.js');


},{"./lib/vectortile.js":286,"./lib/vectortilefeature.js":287,"./lib/vectortilelayer.js":288}],286:[function(require,module,exports){
'use strict';

var VectorTileLayer = require('./vectortilelayer');

module.exports = VectorTile;

function VectorTile(pbf, end) {
    this.layers = pbf.readFields(readTile, {}, end);
}

function readTile(tag, layers, pbf) {
    if (tag === 3) {
        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);
        if (layer.length) { layers[layer.name] = layer; }
    }
}


},{"./vectortilelayer":288}],287:[function(require,module,exports){
'use strict';

var Point = require('point-geometry');

module.exports = VectorTileFeature;

function VectorTileFeature(pbf, end, extent, keys, values) {
    // Public
    this.properties = {};
    this.extent = extent;
    this.type = 0;

    // Private
    this._pbf = pbf;
    this._geometry = -1;
    this._keys = keys;
    this._values = values;

    pbf.readFields(readFeature, this, end);
}

function readFeature(tag, feature, pbf) {
    if (tag == 1) { feature.id = pbf.readVarint(); }else if (tag == 2) { readTag(pbf, feature); }else if (tag == 3) { feature.type = pbf.readVarint(); }else if (tag == 4) { feature._geometry = pbf.pos; }
}

function readTag(pbf, feature) {
    var end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var key = feature._keys[pbf.readVarint()],
            value = feature._values[pbf.readVarint()];
        feature.properties[key] = value;
    }
}

VectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];

VectorTileFeature.prototype.loadGeometry = function () {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        lines = [],
        line;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();

            if (cmd === 1) {
                // moveTo
                if (line) { lines.push(line); }
                line = [];
            }

            line.push(new Point(x, y));
        } else if (cmd === 7) {

            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90
            if (line) {
                line.push(line[0].clone()); // closePolygon
            }
        } else {
            throw new Error('unknown command ' + cmd);
        }
    }

    if (line) { lines.push(line); }

    return lines;
};

VectorTileFeature.prototype.bbox = function () {
    var pbf = this._pbf;
    pbf.pos = this._geometry;

    var end = pbf.readVarint() + pbf.pos,
        cmd = 1,
        length = 0,
        x = 0,
        y = 0,
        x1 = Infinity,
        x2 = -Infinity,
        y1 = Infinity,
        y2 = -Infinity;

    while (pbf.pos < end) {
        if (!length) {
            var cmdLen = pbf.readVarint();
            cmd = cmdLen & 0x7;
            length = cmdLen >> 3;
        }

        length--;

        if (cmd === 1 || cmd === 2) {
            x += pbf.readSVarint();
            y += pbf.readSVarint();
            if (x < x1) { x1 = x; }
            if (x > x2) { x2 = x; }
            if (y < y1) { y1 = y; }
            if (y > y2) { y2 = y; }
        } else if (cmd !== 7) {
            throw new Error('unknown command ' + cmd);
        }
    }

    return [x1, y1, x2, y2];
};

VectorTileFeature.prototype.toGeoJSON = function (x, y, z) {
    var size = this.extent * Math.pow(2, z),
        x0 = this.extent * x,
        y0 = this.extent * y,
        coords = this.loadGeometry(),
        type = VectorTileFeature.types[this.type],
        i,
        j;

    function project(line) {
        for (var j = 0; j < line.length; j++) {
            var p = line[j],
                y2 = 180 - (p.y + y0) * 360 / size;
            line[j] = [(p.x + x0) * 360 / size - 180, 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90];
        }
    }

    switch (this.type) {
        case 1:
            var points = [];
            for (i = 0; i < coords.length; i++) {
                points[i] = coords[i][0];
            }
            coords = points;
            project(coords);
            break;

        case 2:
            for (i = 0; i < coords.length; i++) {
                project(coords[i]);
            }
            break;

        case 3:
            coords = classifyRings(coords);
            for (i = 0; i < coords.length; i++) {
                for (j = 0; j < coords[i].length; j++) {
                    project(coords[i][j]);
                }
            }
            break;
    }

    if (coords.length === 1) {
        coords = coords[0];
    } else {
        type = 'Multi' + type;
    }

    var result = {
        type: "Feature",
        geometry: {
            type: type,
            coordinates: coords
        },
        properties: this.properties
    };

    if ('id' in this) {
        result.id = this.id;
    }

    return result;
};

// classifies an array of rings into polygons with outer rings and holes

function classifyRings(rings) {
    var len = rings.length;

    if (len <= 1) { return [rings]; }

    var polygons = [],
        polygon,
        ccw;

    for (var i = 0; i < len; i++) {
        var area = signedArea(rings[i]);
        if (area === 0) { continue; }

        if (ccw === undefined) { ccw = area < 0; }

        if (ccw === area < 0) {
            if (polygon) { polygons.push(polygon); }
            polygon = [rings[i]];
        } else {
            polygon.push(rings[i]);
        }
    }
    if (polygon) { polygons.push(polygon); }

    return polygons;
}

function signedArea(ring) {
    var sum = 0;
    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {
        p1 = ring[i];
        p2 = ring[j];
        sum += (p2.x - p1.x) * (p1.y + p2.y);
    }
    return sum;
}


},{"point-geometry":269}],288:[function(require,module,exports){
'use strict';

var VectorTileFeature = require('./vectortilefeature.js');

module.exports = VectorTileLayer;

function VectorTileLayer(pbf, end) {
    // Public
    this.version = 1;
    this.name = null;
    this.extent = 4096;
    this.length = 0;

    // Private
    this._pbf = pbf;
    this._keys = [];
    this._values = [];
    this._features = [];

    pbf.readFields(readLayer, this, end);

    this.length = this._features.length;
}

function readLayer(tag, layer, pbf) {
    if (tag === 15) { layer.version = pbf.readVarint(); }else if (tag === 1) { layer.name = pbf.readString(); }else if (tag === 5) { layer.extent = pbf.readVarint(); }else if (tag === 2) { layer._features.push(pbf.pos); }else if (tag === 3) { layer._keys.push(pbf.readString()); }else if (tag === 4) { layer._values.push(readValueMessage(pbf)); }
}

function readValueMessage(pbf) {
    var value = null,
        end = pbf.readVarint() + pbf.pos;

    while (pbf.pos < end) {
        var tag = pbf.readVarint() >> 3;

        value = tag === 1 ? pbf.readString() : tag === 2 ? pbf.readFloat() : tag === 3 ? pbf.readDouble() : tag === 4 ? pbf.readVarint64() : tag === 5 ? pbf.readVarint() : tag === 6 ? pbf.readSVarint() : tag === 7 ? pbf.readBoolean() : null;
    }

    return value;
}

// return feature `i` from this layer as a `VectorTileFeature`
VectorTileLayer.prototype.feature = function (i) {
    if (i < 0 || i >= this._features.length) { throw new Error('feature index out of bounds'); }

    this._pbf.pos = this._features[i];

    var end = this._pbf.readVarint() + this._pbf.pos;
    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);
};


},{"./vectortilefeature.js":287}],289:[function(require,module,exports){
"use strict";

/* Web Font Loader v1.6.27 - (c) Adobe Systems, Google. License: Apache 2.0 */(function () {
  function aa(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }function ba(a, b, c) {
    if (!a) { throw Error(); }if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);return function () {
        var c = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c, d);return a.apply(b, c);
      };
    }return function () {
      return a.apply(b, arguments);
    };
  }function p(a, b, c) {
    p = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? aa : ba;return p.apply(null, arguments);
  }var q = Date.now || function () {
    return +new Date();
  };function ca(a, b) {
    this.a = a;this.m = b || a;this.c = this.m.document;
  }var da = !!window.FontFace;function t(a, b, c, d) {
    b = a.c.createElement(b);if (c) { for (var e in c) { c.hasOwnProperty(e) && ("style" == e ? b.style.cssText = c[e] : b.setAttribute(e, c[e])); } }d && b.appendChild(a.c.createTextNode(d));return b;
  }function u(a, b, c) {
    a = a.c.getElementsByTagName(b)[0];a || (a = document.documentElement);a.insertBefore(c, a.lastChild);
  }function v(a) {
    a.parentNode && a.parentNode.removeChild(a);
  }
  function w(a, b, c) {
    b = b || [];c = c || [];for (var d = a.className.split(/\s+/), e = 0; e < b.length; e += 1) {
      for (var f = !1, g = 0; g < d.length; g += 1) { if (b[e] === d[g]) {
        f = !0;break;
      } }f || d.push(b[e]);
    }b = [];for (e = 0; e < d.length; e += 1) {
      f = !1;for (g = 0; g < c.length; g += 1) { if (d[e] === c[g]) {
        f = !0;break;
      } }f || b.push(d[e]);
    }a.className = b.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "");
  }function y(a, b) {
    for (var c = a.className.split(/\s+/), d = 0, e = c.length; d < e; d++) { if (c[d] == b) { return !0; } }return !1;
  }
  function z(a) {
    if ("string" === typeof a.f) { return a.f; }var b = a.m.location.protocol;"about:" == b && (b = a.a.location.protocol);return "https:" == b ? "https:" : "http:";
  }function ea(a) {
    return a.m.location.hostname || a.a.location.hostname;
  }
  function A(a, b, c) {
    function d() {
      k && e && f && (k(g), k = null);
    }b = t(a, "link", { rel: "stylesheet", href: b, media: "all" });var e = !1,
        f = !0,
        g = null,
        k = c || null;da ? (b.onload = function () {
      e = !0;d();
    }, b.onerror = function () {
      e = !0;g = Error("Stylesheet failed to load");d();
    }) : setTimeout(function () {
      e = !0;d();
    }, 0);u(a, "head", b);
  }
  function B(a, b, c, d) {
    var e = a.c.getElementsByTagName("head")[0];if (e) {
      var f = t(a, "script", { src: b }),
          g = !1;f.onload = f.onreadystatechange = function () {
        g || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (g = !0, c && c(null), f.onload = f.onreadystatechange = null, "HEAD" == f.parentNode.tagName && e.removeChild(f));
      };e.appendChild(f);setTimeout(function () {
        g || (g = !0, c && c(Error("Script load timeout")));
      }, d || 5E3);return f;
    }return null;
  };function C() {
    this.a = 0;this.c = null;
  }function D(a) {
    a.a++;return function () {
      a.a--;E(a);
    };
  }function F(a, b) {
    a.c = b;E(a);
  }function E(a) {
    0 == a.a && a.c && (a.c(), a.c = null);
  };function G(a) {
    this.a = a || "-";
  }G.prototype.c = function (a) {
    var arguments$1 = arguments;

    for (var b = [], c = 0; c < arguments.length; c++) { b.push(arguments$1[c].replace(/[\W_]+/g, "").toLowerCase()); }return b.join(this.a);
  };function H(a, b) {
    this.c = a;this.f = 4;this.a = "n";var c = (b || "n4").match(/^([nio])([1-9])$/i);c && (this.a = c[1], this.f = parseInt(c[2], 10));
  }function fa(a) {
    return I(a) + " " + (a.f + "00") + " 300px " + J(a.c);
  }function J(a) {
    var b = [];a = a.split(/,\s*/);for (var c = 0; c < a.length; c++) {
      var d = a[c].replace(/['"]/g, "");-1 != d.indexOf(" ") || /^\d/.test(d) ? b.push("'" + d + "'") : b.push(d);
    }return b.join(",");
  }function K(a) {
    return a.a + a.f;
  }function I(a) {
    var b = "normal";"o" === a.a ? b = "oblique" : "i" === a.a && (b = "italic");return b;
  }
  function ga(a) {
    var b = 4,
        c = "n",
        d = null;a && ((d = a.match(/(normal|oblique|italic)/i)) && d[1] && (c = d[1].substr(0, 1).toLowerCase()), (d = a.match(/([1-9]00|normal|bold)/i)) && d[1] && (/bold/i.test(d[1]) ? b = 7 : /[1-9]00/.test(d[1]) && (b = parseInt(d[1].substr(0, 1), 10))));return c + b;
  };function ha(a, b) {
    this.c = a;this.f = a.m.document.documentElement;this.h = b;this.a = new G("-");this.j = !1 !== b.events;this.g = !1 !== b.classes;
  }function ia(a) {
    a.g && w(a.f, [a.a.c("wf", "loading")]);L(a, "loading");
  }function M(a) {
    if (a.g) {
      var b = y(a.f, a.a.c("wf", "active")),
          c = [],
          d = [a.a.c("wf", "loading")];b || c.push(a.a.c("wf", "inactive"));w(a.f, c, d);
    }L(a, "inactive");
  }function L(a, b, c) {
    if (a.j && a.h[b]) { if (c) { a.h[b](c.c, K(c)); }else { a.h[b](); } }
  };function ja() {
    this.c = {};
  }function ka(a, b, c) {
    var d = [],
        e;for (e in b) { if (b.hasOwnProperty(e)) {
      var f = a.c[e];f && d.push(f(b[e], c));
    } }return d;
  };function N(a, b) {
    this.c = a;this.f = b;this.a = t(this.c, "span", { "aria-hidden": "true" }, this.f);
  }function O(a) {
    u(a.c, "body", a.a);
  }function P(a) {
    return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + J(a.c) + ";" + ("font-style:" + I(a) + ";font-weight:" + (a.f + "00") + ";");
  };function Q(a, b, c, d, e, f) {
    this.g = a;this.j = b;this.a = d;this.c = c;this.f = e || 3E3;this.h = f || void 0;
  }Q.prototype.start = function () {
    var a = this.c.m.document,
        b = this,
        c = q(),
        d = new Promise(function (d, e) {
      function k() {
        q() - c >= b.f ? e() : a.fonts.load(fa(b.a), b.h).then(function (a) {
          1 <= a.length ? d() : setTimeout(k, 25);
        }, function () {
          e();
        });
      }k();
    }),
        e = new Promise(function (a, d) {
      setTimeout(d, b.f);
    });Promise.race([e, d]).then(function () {
      b.g(b.a);
    }, function () {
      b.j(b.a);
    });
  };function R(a, b, c, d, e, f, g) {
    this.v = a;this.B = b;this.c = c;this.a = d;this.s = g || "BESbswy";this.f = {};this.w = e || 3E3;this.u = f || null;this.o = this.j = this.h = this.g = null;this.g = new N(this.c, this.s);this.h = new N(this.c, this.s);this.j = new N(this.c, this.s);this.o = new N(this.c, this.s);a = new H(this.a.c + ",serif", K(this.a));a = P(a);this.g.a.style.cssText = a;a = new H(this.a.c + ",sans-serif", K(this.a));a = P(a);this.h.a.style.cssText = a;a = new H("serif", K(this.a));a = P(a);this.j.a.style.cssText = a;a = new H("sans-serif", K(this.a));a = P(a);this.o.a.style.cssText = a;O(this.g);O(this.h);O(this.j);O(this.o);
  }var S = { D: "serif", C: "sans-serif" },
      T = null;function U() {
    if (null === T) {
      var a = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);T = !!a && (536 > parseInt(a[1], 10) || 536 === parseInt(a[1], 10) && 11 >= parseInt(a[2], 10));
    }return T;
  }R.prototype.start = function () {
    this.f.serif = this.j.a.offsetWidth;this.f["sans-serif"] = this.o.a.offsetWidth;this.A = q();la(this);
  };
  function ma(a, b, c) {
    for (var d in S) { if (S.hasOwnProperty(d) && b === a.f[S[d]] && c === a.f[S[d]]) { return !0; } }return !1;
  }function la(a) {
    var b = a.g.a.offsetWidth,
        c = a.h.a.offsetWidth,
        d;(d = b === a.f.serif && c === a.f["sans-serif"]) || (d = U() && ma(a, b, c));d ? q() - a.A >= a.w ? U() && ma(a, b, c) && (null === a.u || a.u.hasOwnProperty(a.a.c)) ? V(a, a.v) : V(a, a.B) : na(a) : V(a, a.v);
  }function na(a) {
    setTimeout(p(function () {
      la(this);
    }, a), 50);
  }function V(a, b) {
    setTimeout(p(function () {
      v(this.g.a);v(this.h.a);v(this.j.a);v(this.o.a);b(this.a);
    }, a), 0);
  };function W(a, b, c) {
    this.c = a;this.a = b;this.f = 0;this.o = this.j = !1;this.s = c;
  }var X = null;W.prototype.g = function (a) {
    var b = this.a;b.g && w(b.f, [b.a.c("wf", a.c, K(a).toString(), "active")], [b.a.c("wf", a.c, K(a).toString(), "loading"), b.a.c("wf", a.c, K(a).toString(), "inactive")]);L(b, "fontactive", a);this.o = !0;oa(this);
  };
  W.prototype.h = function (a) {
    var b = this.a;if (b.g) {
      var c = y(b.f, b.a.c("wf", a.c, K(a).toString(), "active")),
          d = [],
          e = [b.a.c("wf", a.c, K(a).toString(), "loading")];c || d.push(b.a.c("wf", a.c, K(a).toString(), "inactive"));w(b.f, d, e);
    }L(b, "fontinactive", a);oa(this);
  };function oa(a) {
    0 == --a.f && a.j && (a.o ? (a = a.a, a.g && w(a.f, [a.a.c("wf", "active")], [a.a.c("wf", "loading"), a.a.c("wf", "inactive")]), L(a, "active")) : M(a.a));
  };function pa(a) {
    this.j = a;this.a = new ja();this.h = 0;this.f = this.g = !0;
  }pa.prototype.load = function (a) {
    this.c = new ca(this.j, a.context || this.j);this.g = !1 !== a.events;this.f = !1 !== a.classes;qa(this, new ha(this.c, a), a);
  };
  function ra(a, b, c, d, e) {
    var f = 0 == --a.h;(a.f || a.g) && setTimeout(function () {
      var a = e || null,
          k = d || null || {};if (0 === c.length && f) { M(b.a); }else {
        b.f += c.length;f && (b.j = f);var h,
            m = [];for (h = 0; h < c.length; h++) {
          var l = c[h],
              n = k[l.c],
              r = b.a,
              x = l;r.g && w(r.f, [r.a.c("wf", x.c, K(x).toString(), "loading")]);L(r, "fontloading", x);r = null;if (null === X) { if (window.FontFace) {
            var x = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                ya = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
            X = x ? 42 < parseInt(x[1], 10) : ya ? !1 : !0;
          } else { X = !1; } }X ? r = new Q(p(b.g, b), p(b.h, b), b.c, l, b.s, n) : r = new R(p(b.g, b), p(b.h, b), b.c, l, b.s, a, n);m.push(r);
        }for (h = 0; h < m.length; h++) { m[h].start(); }
      }
    }, 0);
  }function qa(a, b, c) {
    var d = [],
        e = c.timeout;ia(b);var d = ka(a.a, c, a.c),
        f = new W(a.c, b, e);a.h = d.length;b = 0;for (c = d.length; b < c; b++) { d[b].load(function (b, d, c) {
      ra(a, f, b, d, c);
    }); }
  };function sa(a, b) {
    this.c = a;this.a = b;
  }function ta(a, b, c) {
    var d = z(a.c);a = (a.a.api || "fast.fonts.net/jsapi").replace(/^.*http(s?):(\/\/)?/, "");return d + "//" + a + "/" + b + ".js" + (c ? "?v=" + c : "");
  }
  sa.prototype.load = function (a) {
    function b() {
      if (f["__mti_fntLst" + d]) {
        var c = f["__mti_fntLst" + d](),
            e = [],
            h;if (c) { for (var m = 0; m < c.length; m++) {
          var l = c[m].fontfamily;void 0 != c[m].fontStyle && void 0 != c[m].fontWeight ? (h = c[m].fontStyle + c[m].fontWeight, e.push(new H(l, h))) : e.push(new H(l));
        } }a(e);
      } else { setTimeout(function () {
        b();
      }, 50); }
    }var c = this,
        d = c.a.projectId,
        e = c.a.version;if (d) {
      var f = c.c.m;B(this.c, ta(c, d, e), function (e) {
        e ? a([]) : (f["__MonotypeConfiguration__" + d] = function () {
          return c.a;
        }, b());
      }).id = "__MonotypeAPIScript__" + d;
    } else { a([]); }
  };function ua(a, b) {
    this.c = a;this.a = b;
  }ua.prototype.load = function (a) {
    var this$1 = this;

    var b,
        c,
        d = this.a.urls || [],
        e = this.a.families || [],
        f = this.a.testStrings || {},
        g = new C();b = 0;for (c = d.length; b < c; b++) { A(this$1.c, d[b], D(g)); }var k = [];b = 0;for (c = e.length; b < c; b++) { if (d = e[b].split(":"), d[1]) { for (var h = d[1].split(","), m = 0; m < h.length; m += 1) { k.push(new H(d[0], h[m])); } }else { k.push(new H(d[0])); } }F(g, function () {
      a(k, f);
    });
  };function va(a, b, c) {
    a ? this.c = a : this.c = b + wa;this.a = [];this.f = [];this.g = c || "";
  }var wa = "//fonts.googleapis.com/css";function xa(a, b) {
    for (var c = b.length, d = 0; d < c; d++) {
      var e = b[d].split(":");3 == e.length && a.f.push(e.pop());var f = "";2 == e.length && "" != e[1] && (f = ":");a.a.push(e.join(f));
    }
  }
  function za(a) {
    if (0 == a.a.length) { throw Error("No fonts to load!"); }if (-1 != a.c.indexOf("kit=")) { return a.c; }for (var b = a.a.length, c = [], d = 0; d < b; d++) { c.push(a.a[d].replace(/ /g, "+")); }b = a.c + "?family=" + c.join("%7C");0 < a.f.length && (b += "&subset=" + a.f.join(","));0 < a.g.length && (b += "&text=" + encodeURIComponent(a.g));return b;
  };function Aa(a) {
    this.f = a;this.a = [];this.c = {};
  }
  var Ba = { latin: "BESbswy", "latin-ext": "\u00e7\u00f6\u00fc\u011f\u015f", cyrillic: "\u0439\u044f\u0416", greek: "\u03b1\u03b2\u03a3", khmer: "\u1780\u1781\u1782", Hanuman: "\u1780\u1781\u1782" },
      Ca = { thin: "1", extralight: "2", "extra-light": "2", ultralight: "2", "ultra-light": "2", light: "3", regular: "4", book: "4", medium: "5", "semi-bold": "6", semibold: "6", "demi-bold": "6", demibold: "6", bold: "7", "extra-bold": "8", extrabold: "8", "ultra-bold": "8", ultrabold: "8", black: "9", heavy: "9", l: "3", r: "4", b: "7" },
      Da = { i: "i", italic: "i", n: "n", normal: "n" },
      Ea = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
  function Fa(a) {
    for (var b = a.f.length, c = 0; c < b; c++) {
      var d = a.f[c].split(":"),
          e = d[0].replace(/\+/g, " "),
          f = ["n4"];if (2 <= d.length) {
        var g;var k = d[1];g = [];if (k) { for (var k = k.split(","), h = k.length, m = 0; m < h; m++) {
          var l;l = k[m];if (l.match(/^[\w-]+$/)) {
            var n = Ea.exec(l.toLowerCase());if (null == n) { l = ""; }else {
              l = n[2];l = null == l || "" == l ? "n" : Da[l];n = n[1];if (null == n || "" == n) { n = "4"; }else { var r = Ca[n],
                  n = r ? r : isNaN(n) ? "4" : n.substr(0, 1); }l = [l, n].join("");
            }
          } else { l = ""; }l && g.push(l);
        } }0 < g.length && (f = g);3 == d.length && (d = d[2], g = [], d = d ? d.split(",") : g, 0 < d.length && (d = Ba[d[0]]) && (a.c[e] = d));
      }a.c[e] || (d = Ba[e]) && (a.c[e] = d);for (d = 0; d < f.length; d += 1) { a.a.push(new H(e, f[d])); }
    }
  };function Ga(a, b) {
    this.c = a;this.a = b;
  }var Ha = { Arimo: !0, Cousine: !0, Tinos: !0 };Ga.prototype.load = function (a) {
    var b = new C(),
        c = this.c,
        d = new va(this.a.api, z(c), this.a.text),
        e = this.a.families;xa(d, e);var f = new Aa(e);Fa(f);A(c, za(d), D(b));F(b, function () {
      a(f.a, f.c, Ha);
    });
  };function Ia(a, b) {
    this.c = a;this.a = b;
  }Ia.prototype.load = function (a) {
    var b = this.a.id,
        c = this.c.m;b ? B(this.c, (this.a.api || "https://use.typekit.net") + "/" + b + ".js", function (b) {
      if (b) { a([]); }else if (c.Typekit && c.Typekit.config && c.Typekit.config.fn) {
        b = c.Typekit.config.fn;for (var e = [], f = 0; f < b.length; f += 2) { for (var g = b[f], k = b[f + 1], h = 0; h < k.length; h++) { e.push(new H(g, k[h])); } }try {
          c.Typekit.load({ events: !1, classes: !1, async: !0 });
        } catch (m) {}a(e);
      }
    }, 2E3) : a([]);
  };function Ja(a, b) {
    this.c = a;this.f = b;this.a = [];
  }Ja.prototype.load = function (a) {
    var b = this.f.id,
        c = this.c.m,
        d = this;b ? (c.__webfontfontdeckmodule__ || (c.__webfontfontdeckmodule__ = {}), c.__webfontfontdeckmodule__[b] = function (b, c) {
      for (var g = 0, k = c.fonts.length; g < k; ++g) {
        var h = c.fonts[g];d.a.push(new H(h.name, ga("font-weight:" + h.weight + ";font-style:" + h.style)));
      }a(d.a);
    }, B(this.c, z(this.c) + (this.f.api || "//f.fontdeck.com/s/css/js/") + ea(this.c) + "/" + b + ".js", function (b) {
      b && a([]);
    })) : a([]);
  };var Y = new pa(window);Y.a.c.custom = function (a, b) {
    return new ua(b, a);
  };Y.a.c.fontdeck = function (a, b) {
    return new Ja(b, a);
  };Y.a.c.monotype = function (a, b) {
    return new sa(b, a);
  };Y.a.c.typekit = function (a, b) {
    return new Ia(b, a);
  };Y.a.c.google = function (a, b) {
    return new Ga(b, a);
  };var Z = { load: p(Y.load, Y) };"function" === typeof define && define.amd ? define(function () {
    return Z;
  }) : "undefined" !== typeof module && module.exports ? module.exports = Z : (window.WebFont = Z, window.WebFontConfig && Y.load(window.WebFontConfig));
})();


},{}],290:[function(require,module,exports){
'use strict';

var _asFunction = require('should/as-function');

var _asFunction2 = _interopRequireDefault(_asFunction);

require('should-approximately-deep');

var _ = require('../');

var _map = require('ol/map');

var _map2 = _interopRequireDefault(_map);

var _tile = require('ol/source/tile');

var _tile2 = _interopRequireDefault(_tile);

var _vector = require('ol/source/vector');

var _vector2 = _interopRequireDefault(_vector);

var _vectortile = require('ol/layer/vectortile');

var _vectortile2 = _interopRequireDefault(_vectortile);

var _vectortile3 = require('ol/source/vectortile');

var _vectortile4 = _interopRequireDefault(_vectortile3);

var _proj = require('ol/proj');

var _proj2 = _interopRequireDefault(_proj);

var _tilegrid = require('ol/tilegrid');

var _tilegrid2 = _interopRequireDefault(_tilegrid);

var _brightV = require('../node_modules/mapbox-gl-styles/styles/bright-v9.json');

var _brightV2 = _interopRequireDefault(_brightV);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

delete _brightV2.default.sprite;

describe('ol-mapbox-style', function () {

  describe('applyBackground', function () {
    it('applies a background to a map container', function () {
      var target = document.createElement('div');
      target.style.width = target.style.height = '100px';
      var map = new _map2.default({ target: target });
      (0, _.applyBackground)(map, _brightV2.default);
      (0, _asFunction2.default)(target.style.backgroundColor).be.exactly('rgb(248, 244, 240)');
    });
  });

  describe('applyStyle', function () {
    var layer = new _vectortile2.default({
      source: new _vectortile4.default({
        tileGrid: _tilegrid2.default.createXYZ({ tileSize: 512, maxZoom: 22 })
      })
    });
    it('applies a style function to a layer and resolves promise', function (done) {
      (0, _asFunction2.default)(layer.getStyle()).be.null;
      (0, _.applyStyle)(layer, _brightV2.default, 'mapbox').then(function () {
        (0, _asFunction2.default)(layer.getStyle()).be.a.Function();
        done();
      });
    });
  });

  describe('apply', function (done) {

    var target;
    beforeEach(function () {
      target = document.createElement('div');
    });

    it('returns a map instance and adds a layer with a style function', function (done) {
      var style = 'data:application/json;base64,' + btoa(JSON.stringify(_brightV2.default));
      var map = (0, _.apply)(target, style);
      (0, _asFunction2.default)(map instanceof _map2.default).be.ok();
      map.getLayers().once('add', function () {
        (0, _asFunction2.default)(map.getLayers().item(0).getStyle()).be.a.Function();
        done();
      });
    });

    it('handles raster sources', function (done) {
      var map = (0, _.apply)(target, '../example/data/wms.json');
      var count = 0;
      map.getLayers().on('add', function () {
        ++count;
        if (count == 2) {
          var osm = map.getLayers().item(0);
          var wms = map.getLayers().item(1);
          (0, _asFunction2.default)(osm.getSource().getUrls()).eql(['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png', 'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png', 'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png']);
          (0, _asFunction2.default)(osm.getSource().getAttributions()[0].getHTML()).equal('&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors.');
          (0, _asFunction2.default)(wms.getSource().getTileGrid().getTileSize()).eql(256);
          (0, _asFunction2.default)(wms.getSource().getTileGrid().getMaxZoom()).eql(12);
          done();
        }
      });
    });

    it('handles geojson sources', function (done) {
      var map = (0, _.apply)(target, '../example/data/geojson.json');
      map.getLayers().once('add', function (e) {
        var layer = e.element;
        var source = layer.getSource();
        (0, _asFunction2.default)(source).be.instanceof(_vector2.default);
        (0, _asFunction2.default)(layer.getStyle()).be.a.Function();
        done();
      });
    });

    it('handles geojson sources with inline GeoJSON', function (done) {
      var map = new _map2.default({ target: target });
      map.getLayers().once('add', function (e) {
        var layer = e.element;
        var source = layer.getSource();
        (0, _asFunction2.default)(source).be.instanceof(_vector2.default);
        (0, _asFunction2.default)(source.getFeatures()).have.length(100);
        (0, _asFunction2.default)(layer.getStyle()).be.a.Function();
        done();
      });
      (0, _.apply)(map, '../example/data/geojson-inline.json');
    });

    it('handles raster sources from TileJSON', function (done) {
      var map = (0, _.apply)(target, '../example/data/tilejson.json');
      map.getLayers().once('add', function (e) {
        var source = e.element.getSource();
        (0, _asFunction2.default)(source).be.instanceof(_tile2.default);
        source.once('change', function () {
          var tileGrid = source.getTileGrid();
          (0, _asFunction2.default)(tileGrid.getMaxZoom()).equal(8);
          done();
        });
      });
    });

    it('handles vector sources from TileJSON', function (done) {
      var map = (0, _.apply)(target, 'https://rawgit.com/PetersonGIS/CamoStyle/b783aadd625bf0d874f77daa6c597b585f0b63fd/camo3d.json');
      map.getLayers().once('add', function (e) {
        (0, _asFunction2.default)(_proj2.default.toLonLat(map.getView().getCenter())).be.approximatelyDeep([7.1434, 50.7338], 1e-4);
        (0, _asFunction2.default)(map.getView().getZoom()).equal(14.11);
        var layer = e.element;
        layer.once('change:source', function () {
          var source = layer.getSource();
          (0, _asFunction2.default)(source).be.instanceof(_vectortile4.default);
          (0, _asFunction2.default)(layer.getStyle()).be.a.Function();
          (0, _asFunction2.default)(source.getAttributions()[0].getHTML()).equal('Tegola OSM');
          done();
        });
      });
    });
  });
});


},{"../":1,"../node_modules/mapbox-gl-styles/styles/bright-v9.json":8,"ol/layer/vectortile":133,"ol/map":136,"ol/proj":158,"ol/source/tile":220,"ol/source/vector":225,"ol/source/vectortile":227,"ol/tilegrid":248,"should-approximately-deep":273,"should/as-function":279}]},{},[290]);
